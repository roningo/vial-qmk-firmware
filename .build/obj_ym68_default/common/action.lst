   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB15:
  15               		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "action_layer.h"
  24:tmk_core/common/action.c **** #include "action_tapping.h"
  25:tmk_core/common/action.c **** #include "action_macro.h"
  26:tmk_core/common/action.c **** #include "action_util.h"
  27:tmk_core/common/action.c **** #include "action.h"
  28:tmk_core/common/action.c **** #include "wait.h"
  29:tmk_core/common/action.c **** 
  30:tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
  31:tmk_core/common/action.c **** #    include "backlight.h"
  32:tmk_core/common/action.c **** #endif
  33:tmk_core/common/action.c **** 
  34:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  35:tmk_core/common/action.c **** #    include "debug.h"
  36:tmk_core/common/action.c **** #else
  37:tmk_core/common/action.c **** #    include "nodebug.h"
  38:tmk_core/common/action.c **** #endif
  39:tmk_core/common/action.c **** 
  40:tmk_core/common/action.c **** #ifdef POINTING_DEVICE_ENABLE
  41:tmk_core/common/action.c **** #    include "pointing_device.h"
  42:tmk_core/common/action.c **** #endif
  43:tmk_core/common/action.c **** 
  44:tmk_core/common/action.c **** int tp_buttons;
  45:tmk_core/common/action.c **** 
  46:tmk_core/common/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  47:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  48:tmk_core/common/action.c **** #endif
  49:tmk_core/common/action.c **** 
  50:tmk_core/common/action.c **** #ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
  51:tmk_core/common/action.c **** __attribute__((weak)) bool get_ignore_mod_tap_interrupt(uint16_t keycode, keyrecord_t *record) { re
  52:tmk_core/common/action.c **** #endif
  53:tmk_core/common/action.c **** 
  54:tmk_core/common/action.c **** #ifdef RETRO_TAPPING_PER_KEY
  55:tmk_core/common/action.c **** __attribute__((weak)) bool get_retro_tapping(uint16_t keycode, keyrecord_t *record) { return false;
  56:tmk_core/common/action.c **** #endif
  57:tmk_core/common/action.c **** 
  58:tmk_core/common/action.c **** #ifndef TAP_CODE_DELAY
  59:tmk_core/common/action.c **** #    define TAP_CODE_DELAY 0
  60:tmk_core/common/action.c **** #endif
  61:tmk_core/common/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  62:tmk_core/common/action.c **** #    define TAP_HOLD_CAPS_DELAY 80
  63:tmk_core/common/action.c **** #endif
  64:tmk_core/common/action.c **** /** \brief Called to execute an action.
  65:tmk_core/common/action.c ****  *
  66:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  67:tmk_core/common/action.c ****  */
  68:tmk_core/common/action.c **** void action_exec(keyevent_t event) {
  16               		.loc 1 68 36 view -0
  17               		.cfi_startproc
  18 0000 DF92      		push r13
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 13, -2
  22 0002 EF92      		push r14
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 14, -3
  26 0004 FF92      		push r15
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 15, -4
  30 0006 0F93      		push r16
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 16, -5
  34 0008 1F93      		push r17
  35               	.LCFI4:
  36               		.cfi_def_cfa_offset 7
  37               		.cfi_offset 17, -6
  38 000a CF93      		push r28
  39               	.LCFI5:
  40               		.cfi_def_cfa_offset 8
  41               		.cfi_offset 28, -7
  42 000c DF93      		push r29
  43               	.LCFI6:
  44               		.cfi_def_cfa_offset 9
  45               		.cfi_offset 29, -8
  46 000e CDB7      		in r28,__SP_L__
  47 0010 DEB7      		in r29,__SP_H__
  48               	.LCFI7:
  49               		.cfi_def_cfa_register 28
  50 0012 2B97      		sbiw r28,11
  51               	.LCFI8:
  52               		.cfi_def_cfa_offset 20
  53 0014 0FB6      		in __tmp_reg__,__SREG__
  54 0016 F894      		cli
  55 0018 DEBF      		out __SP_H__,r29
  56 001a 0FBE      		out __SREG__,__tmp_reg__
  57 001c CDBF      		out __SP_L__,r28
  58               	/* prologue: function */
  59               	/* frame size = 11 */
  60               	/* stack size = 18 */
  61               	.L__stack_usage = 18
  62 001e 7A87      		std Y+10,r23
  63 0020 8B87      		std Y+11,r24
  64 0022 F42E      		mov r15,r20
  65               	.LVL0:
  66               		.loc 1 68 36 is_stmt 0 view .LVU1
  67 0024 052F      		mov r16,r21
  68               	.LVL1:
  69               		.loc 1 68 36 view .LVU2
  70 0026 162F      		mov r17,r22
  71               	.LVL2:
  72               		.loc 1 68 36 view .LVU3
  73 0028 E72E      		mov r14,r23
  74 002a D82E      		mov r13,r24
  75               	.LVL3:
  69:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  76               		.loc 1 69 5 is_stmt 1 view .LVU4
  70:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  71:tmk_core/common/action.c ****         dprint("EVENT: ");
  72:tmk_core/common/action.c ****         debug_event(event);
  73:tmk_core/common/action.c ****         dprintln();
  77               		.loc 1 73 19 view .LVU5
  74:tmk_core/common/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  75:tmk_core/common/action.c ****         retro_tapping_counter++;
  76:tmk_core/common/action.c **** #endif
  77:tmk_core/common/action.c ****     }
  78:tmk_core/common/action.c **** 
  79:tmk_core/common/action.c ****     if (event.pressed) {
  78               		.loc 1 79 5 view .LVU6
  79               		.loc 1 79 8 is_stmt 0 view .LVU7
  80 002c 6111      		cpse r22,__zero_reg__
  80:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
  81:tmk_core/common/action.c ****         clear_weak_mods();
  81               		.loc 1 81 9 is_stmt 1 view .LVU8
  82 002e 0E94 0000 		call clear_weak_mods
  83               	.LVL4:
  84               	.L2:
  82:tmk_core/common/action.c ****     }
  83:tmk_core/common/action.c **** 
  84:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  85:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  86:tmk_core/common/action.c ****         process_hand_swap(&event);
  87:tmk_core/common/action.c ****     }
  88:tmk_core/common/action.c **** #endif
  89:tmk_core/common/action.c **** 
  90:tmk_core/common/action.c ****     keyrecord_t record = {.event = event};
  85               		.loc 1 90 5 view .LVU9
  86               		.loc 1 90 17 is_stmt 0 view .LVU10
  87 0032 1E82      		std Y+6,__zero_reg__
  88 0034 1D82      		std Y+5,__zero_reg__
  89 0036 7E2D      		mov r23,r14
  90 0038 EC82      		std Y+4,r14
  91 003a DD82      		std Y+5,r13
  91:tmk_core/common/action.c **** 
  92:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
  93:tmk_core/common/action.c **** #    if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  94:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  95:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  96:tmk_core/common/action.c ****     }
  97:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  98:tmk_core/common/action.c ****         clear_oneshot_mods();
  99:tmk_core/common/action.c ****     }
 100:tmk_core/common/action.c **** #        ifdef SWAP_HANDS_ENABLE
 101:tmk_core/common/action.c ****     if (has_oneshot_swaphands_timed_out()) {
 102:tmk_core/common/action.c ****         clear_oneshot_swaphands();
 103:tmk_core/common/action.c ****     }
 104:tmk_core/common/action.c **** #        endif
 105:tmk_core/common/action.c **** #    endif
 106:tmk_core/common/action.c **** #endif
 107:tmk_core/common/action.c **** 
 108:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 109:tmk_core/common/action.c ****     action_tapping_process(record);
  92               		.loc 1 109 5 is_stmt 1 view .LVU11
  93 003c 4F2D      		mov r20,r15
  94 003e 502F      		mov r21,r16
  95 0040 612F      		mov r22,r17
  96 0042 8D2D      		mov r24,r13
  97 0044 9E81      		ldd r25,Y+6
  98               	/* epilogue start */
 110:tmk_core/common/action.c **** #else
 111:tmk_core/common/action.c ****     process_record(&record);
 112:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
 113:tmk_core/common/action.c ****         dprint("processed: ");
 114:tmk_core/common/action.c ****         debug_record(record);
 115:tmk_core/common/action.c ****         dprintln();
 116:tmk_core/common/action.c ****     }
 117:tmk_core/common/action.c **** #endif
 118:tmk_core/common/action.c **** }
  99               		.loc 1 118 1 is_stmt 0 view .LVU12
 100 0046 2B96      		adiw r28,11
 101 0048 0FB6      		in __tmp_reg__,__SREG__
 102 004a F894      		cli
 103 004c DEBF      		out __SP_H__,r29
 104 004e 0FBE      		out __SREG__,__tmp_reg__
 105 0050 CDBF      		out __SP_L__,r28
 106 0052 DF91      		pop r29
 107 0054 CF91      		pop r28
 108 0056 1F91      		pop r17
 109               	.LVL5:
 110               		.loc 1 118 1 view .LVU13
 111 0058 0F91      		pop r16
 112               	.LVL6:
 113               		.loc 1 118 1 view .LVU14
 114 005a FF90      		pop r15
 115               	.LVL7:
 116               		.loc 1 118 1 view .LVU15
 117 005c EF90      		pop r14
 118               	.LVL8:
 119               		.loc 1 118 1 view .LVU16
 120 005e DF90      		pop r13
 121               	.LVL9:
 109:tmk_core/common/action.c **** #else
 122               		.loc 1 109 5 view .LVU17
 123 0060 0C94 0000 		jmp action_tapping_process
 124               	.LVL10:
 109:tmk_core/common/action.c **** #else
 125               		.loc 1 109 5 view .LVU18
 126               		.cfi_endproc
 127               	.LFE15:
 129               		.section	.text.process_record_quantum,"ax",@progbits
 130               		.weak	process_record_quantum
 132               	process_record_quantum:
 133               	.LVL11:
 134               	.LFB17:
 119:tmk_core/common/action.c **** 
 120:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 121:tmk_core/common/action.c **** bool swap_hands = false;
 122:tmk_core/common/action.c **** bool swap_held  = false;
 123:tmk_core/common/action.c **** 
 124:tmk_core/common/action.c **** /** \brief Process Hand Swap
 125:tmk_core/common/action.c ****  *
 126:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 127:tmk_core/common/action.c ****  */
 128:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 129:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 130:tmk_core/common/action.c **** 
 131:tmk_core/common/action.c ****     keypos_t         pos     = event->key;
 132:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
 133:tmk_core/common/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
 134:tmk_core/common/action.c **** 
 135:tmk_core/common/action.c ****     if (do_swap) {
 136:tmk_core/common/action.c ****         event->key.row = pgm_read_byte(&hand_swap_config[pos.row][pos.col].row);
 137:tmk_core/common/action.c ****         event->key.col = pgm_read_byte(&hand_swap_config[pos.row][pos.col].col);
 138:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 139:tmk_core/common/action.c ****     } else {
 140:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 141:tmk_core/common/action.c ****     }
 142:tmk_core/common/action.c **** }
 143:tmk_core/common/action.c **** #endif
 144:tmk_core/common/action.c **** 
 145:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 146:tmk_core/common/action.c **** bool disable_action_cache = false;
 147:tmk_core/common/action.c **** 
 148:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) {
 149:tmk_core/common/action.c ****     disable_action_cache = true;
 150:tmk_core/common/action.c ****     process_record(record);
 151:tmk_core/common/action.c ****     disable_action_cache = false;
 152:tmk_core/common/action.c **** }
 153:tmk_core/common/action.c **** #else
 154:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 155:tmk_core/common/action.c **** #endif
 156:tmk_core/common/action.c **** 
 157:tmk_core/common/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
 135               		.loc 1 157 72 is_stmt 1 view -0
 136               		.cfi_startproc
 137               	/* prologue: function */
 138               	/* frame size = 0 */
 139               	/* stack size = 0 */
 140               	.L__stack_usage = 0
 141               		.loc 1 157 74 view .LVU20
 142               		.loc 1 157 1 is_stmt 0 view .LVU21
 143 0000 81E0      		ldi r24,lo8(1)
 144               	.LVL12:
 145               	/* epilogue start */
 146               		.loc 1 157 1 view .LVU22
 147 0002 0895      		ret
 148               		.cfi_endproc
 149               	.LFE17:
 151               		.section	.text.post_process_record_quantum,"ax",@progbits
 152               		.weak	post_process_record_quantum
 154               	post_process_record_quantum:
 155               	.LVL13:
 156               	.LFB18:
 158:tmk_core/common/action.c **** 
 159:tmk_core/common/action.c **** __attribute__((weak)) void post_process_record_quantum(keyrecord_t *record) {}
 157               		.loc 1 159 77 is_stmt 1 view -0
 158               		.cfi_startproc
 159               	/* prologue: function */
 160               	/* frame size = 0 */
 161               	/* stack size = 0 */
 162               	.L__stack_usage = 0
 163               		.loc 1 159 78 view .LVU24
 164               	/* epilogue start */
 165               		.loc 1 159 1 is_stmt 0 view .LVU25
 166 0000 0895      		ret
 167               		.cfi_endproc
 168               	.LFE18:
 170               		.section	.text.process_record_tap_hint,"ax",@progbits
 171               	.global	process_record_tap_hint
 173               	process_record_tap_hint:
 174               	.LVL14:
 175               	.LFB19:
 160:tmk_core/common/action.c **** 
 161:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 162:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 163:tmk_core/common/action.c ****  *
 164:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 165:tmk_core/common/action.c ****  */
 166:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 176               		.loc 1 166 51 is_stmt 1 view -0
 177               		.cfi_startproc
 178               	/* prologue: function */
 179               	/* frame size = 0 */
 180               	/* stack size = 0 */
 181               	.L__stack_usage = 0
 167:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 182               		.loc 1 167 5 view .LVU27
 183               		.loc 1 167 23 is_stmt 0 view .LVU28
 184 0000 FC01      		movw r30,r24
 185 0002 8081      		ld r24,Z
 186 0004 9181      		ldd r25,Z+1
 187               	.LVL15:
 188               		.loc 1 167 23 view .LVU29
 189 0006 0C94 0000 		jmp layer_switch_get_action
 190               	.LVL16:
 191               		.loc 1 167 23 view .LVU30
 192               		.cfi_endproc
 193               	.LFE19:
 195               		.section	.text.register_code,"ax",@progbits
 196               	.global	register_code
 198               	register_code:
 199               	.LVL17:
 200               	.LFB23:
 168:tmk_core/common/action.c **** 
 169:tmk_core/common/action.c ****     switch (action.kind.id) {
 170:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 171:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 172:tmk_core/common/action.c ****             switch (action.swap.code) {
 173:tmk_core/common/action.c ****                 case OP_SH_ONESHOT:
 174:tmk_core/common/action.c ****                     break;
 175:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 176:tmk_core/common/action.c ****                 default:
 177:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 178:tmk_core/common/action.c ****                     swap_held  = true;
 179:tmk_core/common/action.c ****             }
 180:tmk_core/common/action.c ****             break;
 181:tmk_core/common/action.c **** #    endif
 182:tmk_core/common/action.c ****     }
 183:tmk_core/common/action.c **** }
 184:tmk_core/common/action.c **** #endif
 185:tmk_core/common/action.c **** 
 186:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 187:tmk_core/common/action.c ****  *
 188:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 189:tmk_core/common/action.c ****  */
 190:tmk_core/common/action.c **** void process_record(keyrecord_t *record) {
 191:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 192:tmk_core/common/action.c ****         return;
 193:tmk_core/common/action.c ****     }
 194:tmk_core/common/action.c **** 
 195:tmk_core/common/action.c ****     if (!process_record_quantum(record)) {
 196:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 197:tmk_core/common/action.c ****         if (is_oneshot_layer_active() && record->event.pressed) {
 198:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 199:tmk_core/common/action.c ****         }
 200:tmk_core/common/action.c **** #endif
 201:tmk_core/common/action.c ****         return;
 202:tmk_core/common/action.c ****     }
 203:tmk_core/common/action.c **** 
 204:tmk_core/common/action.c ****     process_record_handler(record);
 205:tmk_core/common/action.c ****     post_process_record_quantum(record);
 206:tmk_core/common/action.c **** }
 207:tmk_core/common/action.c **** 
 208:tmk_core/common/action.c **** void process_record_handler(keyrecord_t *record) {
 209:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 210:tmk_core/common/action.c ****     dprint("ACTION: ");
 211:tmk_core/common/action.c ****     debug_action(action);
 212:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 213:tmk_core/common/action.c ****     dprint(" layer_state: ");
 214:tmk_core/common/action.c ****     layer_debug();
 215:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 216:tmk_core/common/action.c ****     default_layer_debug();
 217:tmk_core/common/action.c **** #endif
 218:tmk_core/common/action.c ****     dprintln();
 219:tmk_core/common/action.c **** 
 220:tmk_core/common/action.c ****     process_action(record, action);
 221:tmk_core/common/action.c **** }
 222:tmk_core/common/action.c **** 
 223:tmk_core/common/action.c **** #if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 224:tmk_core/common/action.c **** void register_button(bool pressed, enum mouse_buttons button) {
 225:tmk_core/common/action.c **** #    ifdef PS2_MOUSE_ENABLE
 226:tmk_core/common/action.c ****     tp_buttons = pressed ? tp_buttons | button : tp_buttons & ~button;
 227:tmk_core/common/action.c **** #    endif
 228:tmk_core/common/action.c **** #    ifdef POINTING_DEVICE_ENABLE
 229:tmk_core/common/action.c ****     report_mouse_t currentReport = pointing_device_get_report();
 230:tmk_core/common/action.c ****     currentReport.buttons        = pressed ? currentReport.buttons | button : currentReport.buttons
 231:tmk_core/common/action.c ****     pointing_device_set_report(currentReport);
 232:tmk_core/common/action.c **** #    endif
 233:tmk_core/common/action.c **** }
 234:tmk_core/common/action.c **** #endif
 235:tmk_core/common/action.c **** 
 236:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 237:tmk_core/common/action.c ****  *
 238:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 239:tmk_core/common/action.c ****  */
 240:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action) {
 241:tmk_core/common/action.c ****     keyevent_t event = record->event;
 242:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 243:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 244:tmk_core/common/action.c **** #endif
 245:tmk_core/common/action.c **** 
 246:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 247:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 248:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 249:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && (action.kind.id == ACT_USAGE || !IS_MOD(actio
 250:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 251:tmk_core/common/action.c ****         && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)
 252:tmk_core/common/action.c **** #    endif
 253:tmk_core/common/action.c ****     ) {
 254:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 255:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 256:tmk_core/common/action.c ****     }
 257:tmk_core/common/action.c **** #endif
 258:tmk_core/common/action.c **** 
 259:tmk_core/common/action.c ****     switch (action.kind.id) {
 260:tmk_core/common/action.c ****         /* Key and Mods */
 261:tmk_core/common/action.c ****         case ACT_LMODS:
 262:tmk_core/common/action.c ****         case ACT_RMODS: {
 263:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 264:tmk_core/common/action.c ****             if (event.pressed) {
 265:tmk_core/common/action.c ****                 if (mods) {
 266:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 267:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 268:tmk_core/common/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 269:tmk_core/common/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 270:tmk_core/common/action.c ****                         add_mods(mods);
 271:tmk_core/common/action.c ****                     } else {
 272:tmk_core/common/action.c ****                         add_weak_mods(mods);
 273:tmk_core/common/action.c ****                     }
 274:tmk_core/common/action.c ****                     send_keyboard_report();
 275:tmk_core/common/action.c ****                 }
 276:tmk_core/common/action.c ****                 register_code(action.key.code);
 277:tmk_core/common/action.c ****             } else {
 278:tmk_core/common/action.c ****                 unregister_code(action.key.code);
 279:tmk_core/common/action.c ****                 if (mods) {
 280:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 281:tmk_core/common/action.c ****                         del_mods(mods);
 282:tmk_core/common/action.c ****                     } else {
 283:tmk_core/common/action.c ****                         del_weak_mods(mods);
 284:tmk_core/common/action.c ****                     }
 285:tmk_core/common/action.c ****                     send_keyboard_report();
 286:tmk_core/common/action.c ****                 }
 287:tmk_core/common/action.c ****             }
 288:tmk_core/common/action.c ****         } break;
 289:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 290:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 291:tmk_core/common/action.c ****         case ACT_RMODS_TAP: {
 292:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 293:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 294:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 295:tmk_core/common/action.c ****                 case MODS_ONESHOT:
 296:tmk_core/common/action.c ****                     // Oneshot modifier
 297:tmk_core/common/action.c ****                     if (event.pressed) {
 298:tmk_core/common/action.c ****                         if (tap_count == 0) {
 299:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 300:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 301:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 302:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 303:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 304:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 305:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 306:tmk_core/common/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 307:tmk_core/common/action.c ****                             clear_oneshot_mods();
 308:tmk_core/common/action.c ****                             set_oneshot_locked_mods(mods);
 309:tmk_core/common/action.c ****                             register_mods(mods);
 310:tmk_core/common/action.c **** #        endif
 311:tmk_core/common/action.c ****                         } else {
 312:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 313:tmk_core/common/action.c ****                         }
 314:tmk_core/common/action.c ****                     } else {
 315:tmk_core/common/action.c ****                         if (tap_count == 0) {
 316:tmk_core/common/action.c ****                             clear_oneshot_mods();
 317:tmk_core/common/action.c ****                             unregister_mods(mods);
 318:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 319:tmk_core/common/action.c ****                             // Retain Oneshot mods
 320:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 321:tmk_core/common/action.c ****                             if (mods & get_mods()) {
 322:tmk_core/common/action.c ****                                 clear_oneshot_locked_mods();
 323:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 324:tmk_core/common/action.c ****                                 unregister_mods(mods);
 325:tmk_core/common/action.c ****                             }
 326:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 327:tmk_core/common/action.c ****                             // Toggle Oneshot Layer
 328:tmk_core/common/action.c **** #        endif
 329:tmk_core/common/action.c ****                         } else {
 330:tmk_core/common/action.c ****                             clear_oneshot_mods();
 331:tmk_core/common/action.c ****                             unregister_mods(mods);
 332:tmk_core/common/action.c ****                         }
 333:tmk_core/common/action.c ****                     }
 334:tmk_core/common/action.c ****                     break;
 335:tmk_core/common/action.c **** #    endif
 336:tmk_core/common/action.c ****                 case MODS_TAP_TOGGLE:
 337:tmk_core/common/action.c ****                     if (event.pressed) {
 338:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 339:tmk_core/common/action.c ****                             register_mods(mods);
 340:tmk_core/common/action.c ****                         }
 341:tmk_core/common/action.c ****                     } else {
 342:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 343:tmk_core/common/action.c ****                             unregister_mods(mods);
 344:tmk_core/common/action.c ****                         }
 345:tmk_core/common/action.c ****                     }
 346:tmk_core/common/action.c ****                     break;
 347:tmk_core/common/action.c ****                 default:
 348:tmk_core/common/action.c ****                     if (event.pressed) {
 349:tmk_core/common/action.c ****                         if (tap_count > 0) {
 350:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 351:tmk_core/common/action.c ****                             if (
 352:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 353:tmk_core/common/action.c ****                                 !get_ignore_mod_tap_interrupt(get_event_keycode(record->event, fals
 354:tmk_core/common/action.c **** #        endif
 355:tmk_core/common/action.c ****                                 record->tap.interrupted) {
 356:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 357:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 358:tmk_core/common/action.c ****                                 record->tap.count = 0;
 359:tmk_core/common/action.c ****                                 register_mods(mods);
 360:tmk_core/common/action.c ****                             } else
 361:tmk_core/common/action.c **** #    endif
 362:tmk_core/common/action.c ****                             {
 363:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 364:tmk_core/common/action.c ****                                 register_code(action.key.code);
 365:tmk_core/common/action.c ****                             }
 366:tmk_core/common/action.c ****                         } else {
 367:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 368:tmk_core/common/action.c ****                             register_mods(mods);
 369:tmk_core/common/action.c ****                         }
 370:tmk_core/common/action.c ****                     } else {
 371:tmk_core/common/action.c ****                         if (tap_count > 0) {
 372:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 373:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 374:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 375:tmk_core/common/action.c ****                             } else {
 376:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 377:tmk_core/common/action.c ****                             }
 378:tmk_core/common/action.c ****                             unregister_code(action.key.code);
 379:tmk_core/common/action.c ****                         } else {
 380:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 381:tmk_core/common/action.c ****                             unregister_mods(mods);
 382:tmk_core/common/action.c ****                         }
 383:tmk_core/common/action.c ****                     }
 384:tmk_core/common/action.c ****                     break;
 385:tmk_core/common/action.c ****             }
 386:tmk_core/common/action.c ****         } break;
 387:tmk_core/common/action.c **** #endif
 388:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 389:tmk_core/common/action.c ****         /* other HID usage */
 390:tmk_core/common/action.c ****         case ACT_USAGE:
 391:tmk_core/common/action.c ****             switch (action.usage.page) {
 392:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 393:tmk_core/common/action.c ****                     if (event.pressed) {
 394:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 395:tmk_core/common/action.c ****                     } else {
 396:tmk_core/common/action.c ****                         host_system_send(0);
 397:tmk_core/common/action.c ****                     }
 398:tmk_core/common/action.c ****                     break;
 399:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 400:tmk_core/common/action.c ****                     if (event.pressed) {
 401:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 402:tmk_core/common/action.c ****                     } else {
 403:tmk_core/common/action.c ****                         host_consumer_send(0);
 404:tmk_core/common/action.c ****                     }
 405:tmk_core/common/action.c ****                     break;
 406:tmk_core/common/action.c ****             }
 407:tmk_core/common/action.c ****             break;
 408:tmk_core/common/action.c **** #endif
 409:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 410:tmk_core/common/action.c ****         /* Mouse key */
 411:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 412:tmk_core/common/action.c ****             if (event.pressed) {
 413:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 414:tmk_core/common/action.c ****             } else {
 415:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 416:tmk_core/common/action.c ****             }
 417:tmk_core/common/action.c ****             switch (action.key.code) {
 418:tmk_core/common/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 419:tmk_core/common/action.c **** #        ifdef POINTING_DEVICE_ENABLE
 420:tmk_core/common/action.c ****                 case KC_MS_BTN1 ... KC_MS_BTN8:
 421:tmk_core/common/action.c **** #        else
 422:tmk_core/common/action.c ****                 case KC_MS_BTN1 ... KC_MS_BTN3:
 423:tmk_core/common/action.c **** #        endif
 424:tmk_core/common/action.c ****                     register_button(event.pressed, MOUSE_BTN_MASK(action.key.code - KC_MS_BTN1));
 425:tmk_core/common/action.c ****                     break;
 426:tmk_core/common/action.c **** #    endif
 427:tmk_core/common/action.c ****                 default:
 428:tmk_core/common/action.c ****                     mousekey_send();
 429:tmk_core/common/action.c ****                     break;
 430:tmk_core/common/action.c ****             }
 431:tmk_core/common/action.c ****             break;
 432:tmk_core/common/action.c **** #endif
 433:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 434:tmk_core/common/action.c ****         case ACT_LAYER:
 435:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 436:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 437:tmk_core/common/action.c ****                 if (!event.pressed) {
 438:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 439:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 440:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 441:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 442:tmk_core/common/action.c ****                         case OP_BIT_AND:
 443:tmk_core/common/action.c ****                             default_layer_and(bits | mask);
 444:tmk_core/common/action.c ****                             break;
 445:tmk_core/common/action.c ****                         case OP_BIT_OR:
 446:tmk_core/common/action.c ****                             default_layer_or(bits | mask);
 447:tmk_core/common/action.c ****                             break;
 448:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 449:tmk_core/common/action.c ****                             default_layer_xor(bits | mask);
 450:tmk_core/common/action.c ****                             break;
 451:tmk_core/common/action.c ****                         case OP_BIT_SET:
 452:tmk_core/common/action.c ****                             default_layer_set(bits | mask);
 453:tmk_core/common/action.c ****                             break;
 454:tmk_core/common/action.c ****                     }
 455:tmk_core/common/action.c ****                 }
 456:tmk_core/common/action.c ****             } else {
 457:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 458:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 459:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 460:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 461:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 462:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 463:tmk_core/common/action.c ****                         case OP_BIT_AND:
 464:tmk_core/common/action.c ****                             layer_and(bits | mask);
 465:tmk_core/common/action.c ****                             break;
 466:tmk_core/common/action.c ****                         case OP_BIT_OR:
 467:tmk_core/common/action.c ****                             layer_or(bits | mask);
 468:tmk_core/common/action.c ****                             break;
 469:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 470:tmk_core/common/action.c ****                             layer_xor(bits | mask);
 471:tmk_core/common/action.c ****                             break;
 472:tmk_core/common/action.c ****                         case OP_BIT_SET:
 473:tmk_core/common/action.c ****                             layer_state_set(bits | mask);
 474:tmk_core/common/action.c ****                             break;
 475:tmk_core/common/action.c ****                     }
 476:tmk_core/common/action.c ****                 }
 477:tmk_core/common/action.c ****             }
 478:tmk_core/common/action.c ****             break;
 479:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 480:tmk_core/common/action.c ****             if (event.pressed) {
 481:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 482:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 483:tmk_core/common/action.c ****             } else {
 484:tmk_core/common/action.c ****                 unregister_mods(action.layer_mods.mods);
 485:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 486:tmk_core/common/action.c ****             }
 487:tmk_core/common/action.c ****             break;
 488:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 489:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 490:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 491:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 492:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 493:tmk_core/common/action.c ****                     /* tap toggle */
 494:tmk_core/common/action.c ****                     if (event.pressed) {
 495:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 496:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 497:tmk_core/common/action.c ****                         }
 498:tmk_core/common/action.c ****                     } else {
 499:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 500:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 501:tmk_core/common/action.c ****                         }
 502:tmk_core/common/action.c ****                     }
 503:tmk_core/common/action.c ****                     break;
 504:tmk_core/common/action.c ****                 case OP_ON_OFF:
 505:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 506:tmk_core/common/action.c ****                     break;
 507:tmk_core/common/action.c ****                 case OP_OFF_ON:
 508:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 509:tmk_core/common/action.c ****                     break;
 510:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 511:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 512:tmk_core/common/action.c ****                     break;
 513:tmk_core/common/action.c **** #        ifndef NO_ACTION_ONESHOT
 514:tmk_core/common/action.c ****                 case OP_ONESHOT:
 515:tmk_core/common/action.c ****                     // Oneshot modifier
 516:tmk_core/common/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 517:tmk_core/common/action.c ****                     do_release_oneshot = false;
 518:tmk_core/common/action.c ****                     if (event.pressed) {
 519:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 520:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 521:tmk_core/common/action.c ****                             reset_oneshot_layer();
 522:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 523:tmk_core/common/action.c ****                             break;
 524:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 525:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 526:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 527:tmk_core/common/action.c ****                         }
 528:tmk_core/common/action.c ****                     } else {
 529:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 530:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 531:tmk_core/common/action.c ****                             reset_oneshot_layer();
 532:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 533:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 534:tmk_core/common/action.c ****                         } else {
 535:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 536:tmk_core/common/action.c ****                         }
 537:tmk_core/common/action.c ****                     }
 538:tmk_core/common/action.c **** #            else
 539:tmk_core/common/action.c ****                     if (event.pressed) {
 540:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 541:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 542:tmk_core/common/action.c ****                     } else {
 543:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 544:tmk_core/common/action.c ****                         if (tap_count > 1) {
 545:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 546:tmk_core/common/action.c ****                         }
 547:tmk_core/common/action.c ****                     }
 548:tmk_core/common/action.c **** #            endif
 549:tmk_core/common/action.c ****                     break;
 550:tmk_core/common/action.c **** #        endif
 551:tmk_core/common/action.c ****                 default:
 552:tmk_core/common/action.c ****                     /* tap key */
 553:tmk_core/common/action.c ****                     if (event.pressed) {
 554:tmk_core/common/action.c ****                         if (tap_count > 0) {
 555:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 556:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 557:tmk_core/common/action.c ****                         } else {
 558:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 559:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 560:tmk_core/common/action.c ****                         }
 561:tmk_core/common/action.c ****                     } else {
 562:tmk_core/common/action.c ****                         if (tap_count > 0) {
 563:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 564:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 565:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 566:tmk_core/common/action.c ****                             } else {
 567:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 568:tmk_core/common/action.c ****                             }
 569:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 570:tmk_core/common/action.c ****                         } else {
 571:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 572:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 573:tmk_core/common/action.c ****                         }
 574:tmk_core/common/action.c ****                     }
 575:tmk_core/common/action.c ****                     break;
 576:tmk_core/common/action.c ****             }
 577:tmk_core/common/action.c ****             break;
 578:tmk_core/common/action.c **** #    endif
 579:tmk_core/common/action.c **** #endif
 580:tmk_core/common/action.c ****             /* Extentions */
 581:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 582:tmk_core/common/action.c ****         case ACT_MACRO:
 583:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 584:tmk_core/common/action.c ****             break;
 585:tmk_core/common/action.c **** #endif
 586:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 587:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 588:tmk_core/common/action.c ****             switch (action.swap.code) {
 589:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 590:tmk_core/common/action.c ****                     if (event.pressed) {
 591:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 592:tmk_core/common/action.c ****                     }
 593:tmk_core/common/action.c ****                     break;
 594:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 595:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 596:tmk_core/common/action.c ****                     break;
 597:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 598:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 599:tmk_core/common/action.c ****                     break;
 600:tmk_core/common/action.c ****                 case OP_SH_ON:
 601:tmk_core/common/action.c ****                     if (!event.pressed) {
 602:tmk_core/common/action.c ****                         swap_hands = true;
 603:tmk_core/common/action.c ****                     }
 604:tmk_core/common/action.c ****                     break;
 605:tmk_core/common/action.c ****                 case OP_SH_OFF:
 606:tmk_core/common/action.c ****                     if (!event.pressed) {
 607:tmk_core/common/action.c ****                         swap_hands = false;
 608:tmk_core/common/action.c ****                     }
 609:tmk_core/common/action.c ****                     break;
 610:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 611:tmk_core/common/action.c ****                 case OP_SH_ONESHOT:
 612:tmk_core/common/action.c ****                     if (event.pressed) {
 613:tmk_core/common/action.c ****                         set_oneshot_swaphands();
 614:tmk_core/common/action.c ****                     } else {
 615:tmk_core/common/action.c ****                         release_oneshot_swaphands();
 616:tmk_core/common/action.c ****                     }
 617:tmk_core/common/action.c ****                     break;
 618:tmk_core/common/action.c **** #    endif
 619:tmk_core/common/action.c **** 
 620:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 621:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 622:tmk_core/common/action.c ****                     /* tap toggle */
 623:tmk_core/common/action.c **** 
 624:tmk_core/common/action.c ****                     if (event.pressed) {
 625:tmk_core/common/action.c ****                         if (swap_held) {
 626:tmk_core/common/action.c ****                             swap_held = false;
 627:tmk_core/common/action.c ****                         } else {
 628:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 629:tmk_core/common/action.c ****                         }
 630:tmk_core/common/action.c ****                     } else {
 631:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 632:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 633:tmk_core/common/action.c ****                         }
 634:tmk_core/common/action.c ****                     }
 635:tmk_core/common/action.c ****                     break;
 636:tmk_core/common/action.c ****                 default:
 637:tmk_core/common/action.c ****                     /* tap key */
 638:tmk_core/common/action.c ****                     if (tap_count > 0) {
 639:tmk_core/common/action.c ****                         if (swap_held) {
 640:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 641:tmk_core/common/action.c ****                             swap_held  = false;
 642:tmk_core/common/action.c ****                         }
 643:tmk_core/common/action.c ****                         if (event.pressed) {
 644:tmk_core/common/action.c ****                             register_code(action.swap.code);
 645:tmk_core/common/action.c ****                         } else {
 646:tmk_core/common/action.c ****                             wait_ms(TAP_CODE_DELAY);
 647:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 648:tmk_core/common/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 649:tmk_core/common/action.c ****                         }
 650:tmk_core/common/action.c ****                     } else {
 651:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 652:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 653:tmk_core/common/action.c ****                             swap_held  = false;
 654:tmk_core/common/action.c ****                         }
 655:tmk_core/common/action.c ****                     }
 656:tmk_core/common/action.c **** #    endif
 657:tmk_core/common/action.c ****             }
 658:tmk_core/common/action.c **** #endif
 659:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 660:tmk_core/common/action.c ****         case ACT_FUNCTION:
 661:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 662:tmk_core/common/action.c ****             break;
 663:tmk_core/common/action.c **** #endif
 664:tmk_core/common/action.c ****         default:
 665:tmk_core/common/action.c ****             break;
 666:tmk_core/common/action.c ****     }
 667:tmk_core/common/action.c **** 
 668:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 669:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 670:tmk_core/common/action.c ****     switch (action.kind.id) {
 671:tmk_core/common/action.c ****         case ACT_LAYER:
 672:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 673:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 674:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 675:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 676:tmk_core/common/action.c **** #    endif
 677:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 678:tmk_core/common/action.c ****             break;
 679:tmk_core/common/action.c ****         default:
 680:tmk_core/common/action.c ****             break;
 681:tmk_core/common/action.c ****     }
 682:tmk_core/common/action.c **** #endif
 683:tmk_core/common/action.c **** 
 684:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 685:tmk_core/common/action.c **** #    if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
 686:tmk_core/common/action.c ****     if (!is_tap_action(action)) {
 687:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 688:tmk_core/common/action.c ****     } else {
 689:tmk_core/common/action.c ****         if (event.pressed) {
 690:tmk_core/common/action.c ****             if (tap_count > 0) {
 691:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 692:tmk_core/common/action.c ****             }
 693:tmk_core/common/action.c ****         } else {
 694:tmk_core/common/action.c ****             if (tap_count > 0) {
 695:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 696:tmk_core/common/action.c ****             } else {
 697:tmk_core/common/action.c ****                 if (
 698:tmk_core/common/action.c **** #        ifdef RETRO_TAPPING_PER_KEY
 699:tmk_core/common/action.c ****                     get_retro_tapping(get_event_keycode(record->event, false), record) &&
 700:tmk_core/common/action.c **** #        endif
 701:tmk_core/common/action.c ****                     retro_tapping_counter == 2) {
 702:tmk_core/common/action.c ****                     tap_code(action.layer_tap.code);
 703:tmk_core/common/action.c ****                 }
 704:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 705:tmk_core/common/action.c ****             }
 706:tmk_core/common/action.c ****         }
 707:tmk_core/common/action.c ****     }
 708:tmk_core/common/action.c **** #    endif
 709:tmk_core/common/action.c **** #endif
 710:tmk_core/common/action.c **** 
 711:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 712:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 713:tmk_core/common/action.c ****     if (event.pressed && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)) 
 714:tmk_core/common/action.c ****         use_oneshot_swaphands();
 715:tmk_core/common/action.c ****     }
 716:tmk_core/common/action.c **** #    endif
 717:tmk_core/common/action.c **** #endif
 718:tmk_core/common/action.c **** 
 719:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 720:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 721:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 722:tmk_core/common/action.c ****      */
 723:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 724:tmk_core/common/action.c ****         record->event.pressed = false;
 725:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 726:tmk_core/common/action.c ****         process_record(record);
 727:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 728:tmk_core/common/action.c ****     }
 729:tmk_core/common/action.c **** #endif
 730:tmk_core/common/action.c **** }
 731:tmk_core/common/action.c **** 
 732:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 733:tmk_core/common/action.c ****  *
 734:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 735:tmk_core/common/action.c ****  */
 736:tmk_core/common/action.c **** void register_code(uint8_t code) {
 201               		.loc 1 736 34 is_stmt 1 view -0
 202               		.cfi_startproc
 203               		.loc 1 736 34 is_stmt 0 view .LVU32
 204 0000 CF93      		push r28
 205               	.LCFI9:
 206               		.cfi_def_cfa_offset 3
 207               		.cfi_offset 28, -2
 208               	/* prologue: function */
 209               	/* frame size = 0 */
 210               	/* stack size = 1 */
 211               	.L__stack_usage = 1
 212 0002 C82F      		mov r28,r24
 737:tmk_core/common/action.c ****     if (code == KC_NO) {
 213               		.loc 1 737 5 is_stmt 1 view .LVU33
 214               		.loc 1 737 8 is_stmt 0 view .LVU34
 215 0004 8823      		tst r24
 216 0006 01F4      		brne .+2
 217 0008 00C0      		rjmp .L9
 738:tmk_core/common/action.c ****         return;
 739:tmk_core/common/action.c ****     }
 740:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 741:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 742:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 743:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 744:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 745:tmk_core/common/action.c **** #    endif
 746:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 747:tmk_core/common/action.c ****         send_keyboard_report();
 748:tmk_core/common/action.c ****         wait_ms(100);
 749:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 750:tmk_core/common/action.c ****         send_keyboard_report();
 751:tmk_core/common/action.c ****     }
 752:tmk_core/common/action.c **** 
 753:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 754:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 755:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 756:tmk_core/common/action.c **** #    endif
 757:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 758:tmk_core/common/action.c ****         send_keyboard_report();
 759:tmk_core/common/action.c ****         wait_ms(100);
 760:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 761:tmk_core/common/action.c ****         send_keyboard_report();
 762:tmk_core/common/action.c ****     }
 763:tmk_core/common/action.c **** 
 764:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 765:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 766:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 767:tmk_core/common/action.c **** #    endif
 768:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 769:tmk_core/common/action.c ****         send_keyboard_report();
 770:tmk_core/common/action.c ****         wait_ms(100);
 771:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 772:tmk_core/common/action.c ****         send_keyboard_report();
 773:tmk_core/common/action.c ****     }
 774:tmk_core/common/action.c **** #endif
 775:tmk_core/common/action.c **** 
 776:tmk_core/common/action.c ****     else if IS_KEY (code) {
 218               		.loc 1 776 10 is_stmt 1 view .LVU35
 219               		.loc 1 776 13 is_stmt 0 view .LVU36
 220 000a 8CEF      		ldi r24,lo8(-4)
 221               	.LVL18:
 222               		.loc 1 776 13 view .LVU37
 223 000c 8C0F      		add r24,r28
 224 000e 813A      		cpi r24,lo8(-95)
 225 0010 00F4      		brsh .L11
 777:tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 778:tmk_core/common/action.c ****         if (command_proc(code)) return;
 226               		.loc 1 778 9 is_stmt 1 view .LVU38
 779:tmk_core/common/action.c **** 
 780:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 781:tmk_core/common/action.c **** /* TODO: remove
 782:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 783:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 784:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 785:tmk_core/common/action.c **** 
 786:tmk_core/common/action.c ****             add_key(code);
 787:tmk_core/common/action.c ****             send_keyboard_report();
 788:tmk_core/common/action.c **** 
 789:tmk_core/common/action.c ****             set_mods(tmp_mods);
 790:tmk_core/common/action.c ****             send_keyboard_report();
 791:tmk_core/common/action.c ****             oneshot_cancel();
 792:tmk_core/common/action.c ****         } else
 793:tmk_core/common/action.c **** */
 794:tmk_core/common/action.c **** #endif
 795:tmk_core/common/action.c ****         {
 796:tmk_core/common/action.c ****             // Force a new key press if the key is already pressed
 797:tmk_core/common/action.c ****             // without this, keys with the same keycode, but different
 798:tmk_core/common/action.c ****             // modifiers will be reported incorrectly, see issue #1708
 799:tmk_core/common/action.c ****             if (is_key_pressed(keyboard_report, code)) {
 227               		.loc 1 799 13 view .LVU39
 228               		.loc 1 799 17 is_stmt 0 view .LVU40
 229 0012 6C2F      		mov r22,r28
 230 0014 8091 0000 		lds r24,keyboard_report
 231 0018 9091 0000 		lds r25,keyboard_report+1
 232 001c 0E94 0000 		call is_key_pressed
 233               	.LVL19:
 234               		.loc 1 799 16 view .LVU41
 235 0020 8823      		tst r24
 236 0022 01F0      		breq .L12
 800:tmk_core/common/action.c ****                 del_key(code);
 237               		.loc 1 800 17 is_stmt 1 view .LVU42
 238 0024 8C2F      		mov r24,r28
 239 0026 0E94 0000 		call del_key
 240               	.LVL20:
 801:tmk_core/common/action.c ****                 send_keyboard_report();
 241               		.loc 1 801 17 view .LVU43
 242 002a 0E94 0000 		call send_keyboard_report
 243               	.LVL21:
 244               	.L12:
 802:tmk_core/common/action.c ****             }
 803:tmk_core/common/action.c ****             add_key(code);
 245               		.loc 1 803 13 view .LVU44
 246 002e 8C2F      		mov r24,r28
 247 0030 0E94 0000 		call add_key
 248               	.LVL22:
 804:tmk_core/common/action.c ****             send_keyboard_report();
 249               		.loc 1 804 13 view .LVU45
 250               	.L22:
 805:tmk_core/common/action.c ****         }
 806:tmk_core/common/action.c ****     } else if IS_MOD (code) {
 807:tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 808:tmk_core/common/action.c ****         send_keyboard_report();
 251               		.loc 1 808 9 view .LVU46
 252               	/* epilogue start */
 809:tmk_core/common/action.c ****     }
 810:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 811:tmk_core/common/action.c ****     else if IS_SYSTEM (code) {
 812:tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 813:tmk_core/common/action.c ****     } else if IS_CONSUMER (code) {
 814:tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 815:tmk_core/common/action.c ****     }
 816:tmk_core/common/action.c **** #endif
 817:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 818:tmk_core/common/action.c ****     else if IS_MOUSEKEY (code) {
 819:tmk_core/common/action.c ****         mousekey_on(code);
 820:tmk_core/common/action.c ****         mousekey_send();
 821:tmk_core/common/action.c ****     }
 822:tmk_core/common/action.c **** #endif
 823:tmk_core/common/action.c **** }
 253               		.loc 1 823 1 is_stmt 0 view .LVU47
 254 0034 CF91      		pop r28
 808:tmk_core/common/action.c ****     }
 255               		.loc 1 808 9 view .LVU48
 256 0036 0C94 0000 		jmp send_keyboard_report
 257               	.LVL23:
 258               	.L11:
 806:tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 259               		.loc 1 806 12 is_stmt 1 view .LVU49
 806:tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 260               		.loc 1 806 15 is_stmt 0 view .LVU50
 261 003a 80E2      		ldi r24,lo8(32)
 262 003c 8C0F      		add r24,r28
 263 003e 8830      		cpi r24,lo8(8)
 264 0040 00F4      		brsh .L13
 807:tmk_core/common/action.c ****         send_keyboard_report();
 265               		.loc 1 807 9 is_stmt 1 view .LVU51
 807:tmk_core/common/action.c ****         send_keyboard_report();
 266               		.loc 1 807 18 is_stmt 0 view .LVU52
 267 0042 C770      		andi r28,lo8(7)
 268               	.LVL24:
 807:tmk_core/common/action.c ****         send_keyboard_report();
 269               		.loc 1 807 9 view .LVU53
 270 0044 81E0      		ldi r24,lo8(1)
 271 0046 00C0      		rjmp 2f
 272               		1:
 273 0048 880F      		lsl r24
 274               		2:
 275 004a CA95      		dec r28
 276 004c 02F4      		brpl 1b
 277 004e 0E94 0000 		call add_mods
 278               	.LVL25:
 279 0052 00C0      		rjmp .L22
 280               	.LVL26:
 281               	.L13:
 811:tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 282               		.loc 1 811 10 is_stmt 1 view .LVU54
 811:tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 283               		.loc 1 811 13 is_stmt 0 view .LVU55
 284 0054 EBE5      		ldi r30,lo8(91)
 285 0056 EC0F      		add r30,r28
 286 0058 E330      		cpi r30,lo8(3)
 287 005a 00F4      		brsh .L14
 812:tmk_core/common/action.c ****     } else if IS_CONSUMER (code) {
 288               		.loc 1 812 9 is_stmt 1 view .LVU56
 289               	.LVL27:
 290               	.LBB21:
 291               	.LBI21:
 292               		.file 2 "tmk_core/common/report.h"
   1:tmk_core/common/report.h **** /*
   2:tmk_core/common/report.h **** Copyright 2011,2012 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/report.h **** 
   4:tmk_core/common/report.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/report.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/report.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/report.h **** (at your option) any later version.
   8:tmk_core/common/report.h **** 
   9:tmk_core/common/report.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/report.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/report.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/report.h **** GNU General Public License for more details.
  13:tmk_core/common/report.h **** 
  14:tmk_core/common/report.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/report.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/report.h **** */
  17:tmk_core/common/report.h **** 
  18:tmk_core/common/report.h **** #pragma once
  19:tmk_core/common/report.h **** 
  20:tmk_core/common/report.h **** #include <stdint.h>
  21:tmk_core/common/report.h **** #include <stdbool.h>
  22:tmk_core/common/report.h **** #include "keycode.h"
  23:tmk_core/common/report.h **** 
  24:tmk_core/common/report.h **** // clang-format off
  25:tmk_core/common/report.h **** 
  26:tmk_core/common/report.h **** /* HID report IDs */
  27:tmk_core/common/report.h **** enum hid_report_ids {
  28:tmk_core/common/report.h ****     REPORT_ID_KEYBOARD = 1,
  29:tmk_core/common/report.h ****     REPORT_ID_MOUSE,
  30:tmk_core/common/report.h ****     REPORT_ID_SYSTEM,
  31:tmk_core/common/report.h ****     REPORT_ID_CONSUMER,
  32:tmk_core/common/report.h ****     REPORT_ID_NKRO,
  33:tmk_core/common/report.h ****     REPORT_ID_JOYSTICK
  34:tmk_core/common/report.h **** };
  35:tmk_core/common/report.h **** 
  36:tmk_core/common/report.h **** /* Mouse buttons */
  37:tmk_core/common/report.h **** #define MOUSE_BTN_MASK(n) (1 << (n))
  38:tmk_core/common/report.h **** enum mouse_buttons {
  39:tmk_core/common/report.h ****     MOUSE_BTN1 = MOUSE_BTN_MASK(0),
  40:tmk_core/common/report.h ****     MOUSE_BTN2 = MOUSE_BTN_MASK(1),
  41:tmk_core/common/report.h ****     MOUSE_BTN3 = MOUSE_BTN_MASK(2),
  42:tmk_core/common/report.h ****     MOUSE_BTN4 = MOUSE_BTN_MASK(3),
  43:tmk_core/common/report.h ****     MOUSE_BTN5 = MOUSE_BTN_MASK(4),
  44:tmk_core/common/report.h ****     MOUSE_BTN6 = MOUSE_BTN_MASK(5),
  45:tmk_core/common/report.h ****     MOUSE_BTN7 = MOUSE_BTN_MASK(6),
  46:tmk_core/common/report.h ****     MOUSE_BTN8 = MOUSE_BTN_MASK(7)
  47:tmk_core/common/report.h **** };
  48:tmk_core/common/report.h **** 
  49:tmk_core/common/report.h **** /* Consumer Page (0x0C)
  50:tmk_core/common/report.h ****  *
  51:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=75
  52:tmk_core/common/report.h ****  */
  53:tmk_core/common/report.h **** enum consumer_usages {
  54:tmk_core/common/report.h ****     // 15.5 Display Controls
  55:tmk_core/common/report.h ****     SNAPSHOT               = 0x065,
  56:tmk_core/common/report.h ****     BRIGHTNESS_UP          = 0x06F, // https://www.usb.org/sites/default/files/hutrr41_0.pdf
  57:tmk_core/common/report.h ****     BRIGHTNESS_DOWN        = 0x070,
  58:tmk_core/common/report.h ****     // 15.7 Transport Controls
  59:tmk_core/common/report.h ****     TRANSPORT_RECORD       = 0x0B2,
  60:tmk_core/common/report.h ****     TRANSPORT_FAST_FORWARD = 0x0B3,
  61:tmk_core/common/report.h ****     TRANSPORT_REWIND       = 0x0B4,
  62:tmk_core/common/report.h ****     TRANSPORT_NEXT_TRACK   = 0x0B5,
  63:tmk_core/common/report.h ****     TRANSPORT_PREV_TRACK   = 0x0B6,
  64:tmk_core/common/report.h ****     TRANSPORT_STOP         = 0x0B7,
  65:tmk_core/common/report.h ****     TRANSPORT_EJECT        = 0x0B8,
  66:tmk_core/common/report.h ****     TRANSPORT_RANDOM_PLAY  = 0x0B9,
  67:tmk_core/common/report.h ****     TRANSPORT_STOP_EJECT   = 0x0CC,
  68:tmk_core/common/report.h ****     TRANSPORT_PLAY_PAUSE   = 0x0CD,
  69:tmk_core/common/report.h ****     // 15.9.1 Audio Controls - Volume
  70:tmk_core/common/report.h ****     AUDIO_MUTE             = 0x0E2,
  71:tmk_core/common/report.h ****     AUDIO_VOL_UP           = 0x0E9,
  72:tmk_core/common/report.h ****     AUDIO_VOL_DOWN         = 0x0EA,
  73:tmk_core/common/report.h ****     // 15.15 Application Launch Buttons
  74:tmk_core/common/report.h ****     AL_CC_CONFIG           = 0x183,
  75:tmk_core/common/report.h ****     AL_EMAIL               = 0x18A,
  76:tmk_core/common/report.h ****     AL_CALCULATOR          = 0x192,
  77:tmk_core/common/report.h ****     AL_LOCAL_BROWSER       = 0x194,
  78:tmk_core/common/report.h ****     AL_LOCK                = 0x19E,
  79:tmk_core/common/report.h ****     AL_CONTROL_PANEL       = 0x19F,
  80:tmk_core/common/report.h ****     AL_ASSISTANT           = 0x1CB,
  81:tmk_core/common/report.h ****     AL_KEYBOARD_LAYOUT     = 0x1AE,
  82:tmk_core/common/report.h ****     // 15.16 Generic GUI Application Controls
  83:tmk_core/common/report.h ****     AC_NEW                 = 0x201,
  84:tmk_core/common/report.h ****     AC_OPEN                = 0x202,
  85:tmk_core/common/report.h ****     AC_CLOSE               = 0x203,
  86:tmk_core/common/report.h ****     AC_EXIT                = 0x204,
  87:tmk_core/common/report.h ****     AC_MAXIMIZE            = 0x205,
  88:tmk_core/common/report.h ****     AC_MINIMIZE            = 0x206,
  89:tmk_core/common/report.h ****     AC_SAVE                = 0x207,
  90:tmk_core/common/report.h ****     AC_PRINT               = 0x208,
  91:tmk_core/common/report.h ****     AC_PROPERTIES          = 0x209,
  92:tmk_core/common/report.h ****     AC_UNDO                = 0x21A,
  93:tmk_core/common/report.h ****     AC_COPY                = 0x21B,
  94:tmk_core/common/report.h ****     AC_CUT                 = 0x21C,
  95:tmk_core/common/report.h ****     AC_PASTE               = 0x21D,
  96:tmk_core/common/report.h ****     AC_SELECT_ALL          = 0x21E,
  97:tmk_core/common/report.h ****     AC_FIND                = 0x21F,
  98:tmk_core/common/report.h ****     AC_SEARCH              = 0x221,
  99:tmk_core/common/report.h ****     AC_HOME                = 0x223,
 100:tmk_core/common/report.h ****     AC_BACK                = 0x224,
 101:tmk_core/common/report.h ****     AC_FORWARD             = 0x225,
 102:tmk_core/common/report.h ****     AC_STOP                = 0x226,
 103:tmk_core/common/report.h ****     AC_REFRESH             = 0x227,
 104:tmk_core/common/report.h ****     AC_BOOKMARKS           = 0x22A
 105:tmk_core/common/report.h **** };
 106:tmk_core/common/report.h **** 
 107:tmk_core/common/report.h **** /* Generic Desktop Page (0x01)
 108:tmk_core/common/report.h ****  *
 109:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=26
 110:tmk_core/common/report.h ****  */
 111:tmk_core/common/report.h **** enum desktop_usages {
 112:tmk_core/common/report.h ****     // 4.5.1 System Controls - Power Controls
 113:tmk_core/common/report.h ****     SYSTEM_POWER_DOWN             = 0x81,
 114:tmk_core/common/report.h ****     SYSTEM_SLEEP                  = 0x82,
 115:tmk_core/common/report.h ****     SYSTEM_WAKE_UP                = 0x83,
 116:tmk_core/common/report.h ****     SYSTEM_RESTART                = 0x8F,
 117:tmk_core/common/report.h ****     // 4.10 System Display Controls
 118:tmk_core/common/report.h ****     SYSTEM_DISPLAY_TOGGLE_INT_EXT = 0xB5
 119:tmk_core/common/report.h **** };
 120:tmk_core/common/report.h **** 
 121:tmk_core/common/report.h **** // clang-format on
 122:tmk_core/common/report.h **** 
 123:tmk_core/common/report.h **** #define NKRO_SHARED_EP
 124:tmk_core/common/report.h **** /* key report size(NKRO or boot mode) */
 125:tmk_core/common/report.h **** #if defined(NKRO_ENABLE)
 126:tmk_core/common/report.h **** #    if defined(PROTOCOL_LUFA) || defined(PROTOCOL_CHIBIOS)
 127:tmk_core/common/report.h **** #        include "protocol/usb_descriptor.h"
 128:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (SHARED_EPSIZE - 2)
 129:tmk_core/common/report.h **** #    elif defined(PROTOCOL_ARM_ATSAM)
 130:tmk_core/common/report.h **** #        include "protocol/arm_atsam/usb/udi_device_epsize.h"
 131:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (NKRO_EPSIZE - 1)
 132:tmk_core/common/report.h **** #        undef NKRO_SHARED_EP
 133:tmk_core/common/report.h **** #        undef MOUSE_SHARED_EP
 134:tmk_core/common/report.h **** #    else
 135:tmk_core/common/report.h **** #        error "NKRO not supported with this protocol"
 136:tmk_core/common/report.h **** #    endif
 137:tmk_core/common/report.h **** #endif
 138:tmk_core/common/report.h **** 
 139:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 140:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 9
 141:tmk_core/common/report.h **** #else
 142:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 8
 143:tmk_core/common/report.h **** #endif
 144:tmk_core/common/report.h **** 
 145:tmk_core/common/report.h **** #define KEYBOARD_REPORT_KEYS 6
 146:tmk_core/common/report.h **** 
 147:tmk_core/common/report.h **** #ifdef __cplusplus
 148:tmk_core/common/report.h **** extern "C" {
 149:tmk_core/common/report.h **** #endif
 150:tmk_core/common/report.h **** 
 151:tmk_core/common/report.h **** /*
 152:tmk_core/common/report.h ****  * keyboard report is 8-byte array retains state of 8 modifiers and 6 keys.
 153:tmk_core/common/report.h ****  *
 154:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7
 155:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 156:tmk_core/common/report.h ****  * desc |mods    |reserved|keys[0] |keys[1] |keys[2] |keys[3] |keys[4] |keys[5]
 157:tmk_core/common/report.h ****  *
 158:tmk_core/common/report.h ****  * It is exended to 16 bytes to retain 120keys+8mods when NKRO mode.
 159:tmk_core/common/report.h ****  *
 160:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7        ... |15
 161:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------     +--------
 162:tmk_core/common/report.h ****  * desc |mods    |bits[0] |bits[1] |bits[2] |bits[3] |bits[4] |bits[5] |bits[6]  ... |bit[14]
 163:tmk_core/common/report.h ****  *
 164:tmk_core/common/report.h ****  * mods retains state of 8 modifiers.
 165:tmk_core/common/report.h ****  *
 166:tmk_core/common/report.h ****  *  bit |0       |1       |2       |3       |4       |5       |6       |7
 167:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 168:tmk_core/common/report.h ****  * desc |Lcontrol|Lshift  |Lalt    |Lgui    |Rcontrol|Rshift  |Ralt    |Rgui
 169:tmk_core/common/report.h ****  *
 170:tmk_core/common/report.h ****  */
 171:tmk_core/common/report.h **** typedef union {
 172:tmk_core/common/report.h ****     uint8_t raw[KEYBOARD_REPORT_SIZE];
 173:tmk_core/common/report.h ****     struct {
 174:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 175:tmk_core/common/report.h ****         uint8_t report_id;
 176:tmk_core/common/report.h **** #endif
 177:tmk_core/common/report.h ****         uint8_t mods;
 178:tmk_core/common/report.h ****         uint8_t reserved;
 179:tmk_core/common/report.h ****         uint8_t keys[KEYBOARD_REPORT_KEYS];
 180:tmk_core/common/report.h ****     };
 181:tmk_core/common/report.h **** #ifdef NKRO_ENABLE
 182:tmk_core/common/report.h ****     struct nkro_report {
 183:tmk_core/common/report.h **** #    ifdef NKRO_SHARED_EP
 184:tmk_core/common/report.h ****         uint8_t report_id;
 185:tmk_core/common/report.h **** #    endif
 186:tmk_core/common/report.h ****         uint8_t mods;
 187:tmk_core/common/report.h ****         uint8_t bits[KEYBOARD_REPORT_BITS];
 188:tmk_core/common/report.h ****     } nkro;
 189:tmk_core/common/report.h **** #endif
 190:tmk_core/common/report.h **** } __attribute__((packed)) report_keyboard_t;
 191:tmk_core/common/report.h **** 
 192:tmk_core/common/report.h **** typedef struct {
 193:tmk_core/common/report.h ****     uint8_t  report_id;
 194:tmk_core/common/report.h ****     uint16_t usage;
 195:tmk_core/common/report.h **** } __attribute__((packed)) report_extra_t;
 196:tmk_core/common/report.h **** 
 197:tmk_core/common/report.h **** typedef struct {
 198:tmk_core/common/report.h **** #ifdef MOUSE_SHARED_EP
 199:tmk_core/common/report.h ****     uint8_t report_id;
 200:tmk_core/common/report.h **** #endif
 201:tmk_core/common/report.h ****     uint8_t buttons;
 202:tmk_core/common/report.h ****     int8_t  x;
 203:tmk_core/common/report.h ****     int8_t  y;
 204:tmk_core/common/report.h ****     int8_t  v;
 205:tmk_core/common/report.h ****     int8_t  h;
 206:tmk_core/common/report.h **** } __attribute__((packed)) report_mouse_t;
 207:tmk_core/common/report.h **** 
 208:tmk_core/common/report.h **** typedef struct {
 209:tmk_core/common/report.h **** #if JOYSTICK_AXES_COUNT > 0
 210:tmk_core/common/report.h **** #    if JOYSTICK_AXES_RESOLUTION > 8
 211:tmk_core/common/report.h ****     int16_t axes[JOYSTICK_AXES_COUNT];
 212:tmk_core/common/report.h **** #    else
 213:tmk_core/common/report.h ****     int8_t axes[JOYSTICK_AXES_COUNT];
 214:tmk_core/common/report.h **** #    endif
 215:tmk_core/common/report.h **** #endif
 216:tmk_core/common/report.h **** 
 217:tmk_core/common/report.h **** #if JOYSTICK_BUTTON_COUNT > 0
 218:tmk_core/common/report.h ****     uint8_t buttons[(JOYSTICK_BUTTON_COUNT - 1) / 8 + 1];
 219:tmk_core/common/report.h **** #endif
 220:tmk_core/common/report.h **** } __attribute__((packed)) joystick_report_t;
 221:tmk_core/common/report.h **** 
 222:tmk_core/common/report.h **** /* keycode to system usage */
 223:tmk_core/common/report.h **** static inline uint16_t KEYCODE2SYSTEM(uint8_t key) {
 293               		.loc 2 223 24 view .LVU57
 294               	.LBE21:
 224:tmk_core/common/report.h ****     switch (key) {
 295               		.loc 2 224 5 view .LVU58
 812:tmk_core/common/action.c ****     } else if IS_CONSUMER (code) {
 296               		.loc 1 812 9 is_stmt 0 view .LVU59
 297 005c F0E0      		ldi r31,0
 298 005e E050      		subi r30,lo8(-(CSWTCH.11))
 299 0060 F040      		sbci r31,hi8(-(CSWTCH.11))
 300 0062 8081      		ld r24,Z
 301 0064 90E0      		ldi r25,0
 302               	/* epilogue start */
 303               		.loc 1 823 1 view .LVU60
 304 0066 CF91      		pop r28
 305               	.LVL28:
 812:tmk_core/common/action.c ****     } else if IS_CONSUMER (code) {
 306               		.loc 1 812 9 view .LVU61
 307 0068 0C94 0000 		jmp host_system_send
 308               	.LVL29:
 309               	.L14:
 813:tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 310               		.loc 1 813 12 is_stmt 1 view .LVU62
 813:tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 311               		.loc 1 813 15 is_stmt 0 view .LVU63
 312 006c E8E5      		ldi r30,lo8(88)
 313 006e EC0F      		add r30,r28
 314 0070 E731      		cpi r30,lo8(23)
 315 0072 00F4      		brsh .L15
 814:tmk_core/common/action.c ****     }
 316               		.loc 1 814 9 is_stmt 1 view .LVU64
 317               	.LVL30:
 318               	.LBB22:
 319               	.LBI22:
 225:tmk_core/common/report.h ****         case KC_SYSTEM_POWER:
 226:tmk_core/common/report.h ****             return SYSTEM_POWER_DOWN;
 227:tmk_core/common/report.h ****         case KC_SYSTEM_SLEEP:
 228:tmk_core/common/report.h ****             return SYSTEM_SLEEP;
 229:tmk_core/common/report.h ****         case KC_SYSTEM_WAKE:
 230:tmk_core/common/report.h ****             return SYSTEM_WAKE_UP;
 231:tmk_core/common/report.h ****         default:
 232:tmk_core/common/report.h ****             return 0;
 233:tmk_core/common/report.h ****     }
 234:tmk_core/common/report.h **** }
 235:tmk_core/common/report.h **** 
 236:tmk_core/common/report.h **** /* keycode to consumer usage */
 237:tmk_core/common/report.h **** static inline uint16_t KEYCODE2CONSUMER(uint8_t key) {
 320               		.loc 2 237 24 view .LVU65
 321               	.LBE22:
 238:tmk_core/common/report.h ****     switch (key) {
 322               		.loc 2 238 5 view .LVU66
 814:tmk_core/common/action.c ****     }
 323               		.loc 1 814 9 is_stmt 0 view .LVU67
 324 0074 F0E0      		ldi r31,0
 325 0076 EE0F      		lsl r30
 326 0078 FF1F      		rol r31
 327 007a E050      		subi r30,lo8(-(CSWTCH.12))
 328 007c F040      		sbci r31,hi8(-(CSWTCH.12))
 329 007e 8081      		ld r24,Z
 330 0080 9181      		ldd r25,Z+1
 331               	/* epilogue start */
 332               		.loc 1 823 1 view .LVU68
 333 0082 CF91      		pop r28
 334               	.LVL31:
 814:tmk_core/common/action.c ****     }
 335               		.loc 1 814 9 view .LVU69
 336 0084 0C94 0000 		jmp host_consumer_send
 337               	.LVL32:
 338               	.L15:
 818:tmk_core/common/action.c ****         mousekey_on(code);
 339               		.loc 1 818 10 is_stmt 1 view .LVU70
 818:tmk_core/common/action.c ****         mousekey_on(code);
 340               		.loc 1 818 13 is_stmt 0 view .LVU71
 341 0088 CD3E      		cpi r28,lo8(-19)
 342 008a 00F0      		brlo .L9
 819:tmk_core/common/action.c ****         mousekey_send();
 343               		.loc 1 819 9 is_stmt 1 view .LVU72
 344 008c 8C2F      		mov r24,r28
 345 008e 0E94 0000 		call mousekey_on
 346               	.LVL33:
 820:tmk_core/common/action.c ****     }
 347               		.loc 1 820 9 view .LVU73
 348               	/* epilogue start */
 349               		.loc 1 823 1 is_stmt 0 view .LVU74
 350 0092 CF91      		pop r28
 351               	.LVL34:
 820:tmk_core/common/action.c ****     }
 352               		.loc 1 820 9 view .LVU75
 353 0094 0C94 0000 		jmp mousekey_send
 354               	.LVL35:
 355               	.L9:
 356               	/* epilogue start */
 357               		.loc 1 823 1 view .LVU76
 358 0098 CF91      		pop r28
 359               	.LVL36:
 360               		.loc 1 823 1 view .LVU77
 361 009a 0895      		ret
 362               		.cfi_endproc
 363               	.LFE23:
 365               		.section	.text.unregister_code,"ax",@progbits
 366               	.global	unregister_code
 368               	unregister_code:
 369               	.LVL37:
 370               	.LFB24:
 824:tmk_core/common/action.c **** 
 825:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 826:tmk_core/common/action.c ****  *
 827:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 828:tmk_core/common/action.c ****  */
 829:tmk_core/common/action.c **** void unregister_code(uint8_t code) {
 371               		.loc 1 829 36 is_stmt 1 view -0
 372               		.cfi_startproc
 373               	/* prologue: function */
 374               	/* frame size = 0 */
 375               	/* stack size = 0 */
 376               	.L__stack_usage = 0
 830:tmk_core/common/action.c ****     if (code == KC_NO) {
 377               		.loc 1 830 5 view .LVU79
 378               		.loc 1 830 8 is_stmt 0 view .LVU80
 379 0000 8823      		tst r24
 380 0002 01F0      		breq .L23
 831:tmk_core/common/action.c ****         return;
 832:tmk_core/common/action.c ****     }
 833:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 834:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 835:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 836:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 837:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 838:tmk_core/common/action.c **** #    endif
 839:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 840:tmk_core/common/action.c ****         send_keyboard_report();
 841:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 842:tmk_core/common/action.c ****         send_keyboard_report();
 843:tmk_core/common/action.c ****     }
 844:tmk_core/common/action.c **** 
 845:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 846:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 847:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 848:tmk_core/common/action.c **** #    endif
 849:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 850:tmk_core/common/action.c ****         send_keyboard_report();
 851:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 852:tmk_core/common/action.c ****         send_keyboard_report();
 853:tmk_core/common/action.c ****     }
 854:tmk_core/common/action.c **** 
 855:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 856:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 857:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 858:tmk_core/common/action.c **** #    endif
 859:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 860:tmk_core/common/action.c ****         send_keyboard_report();
 861:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 862:tmk_core/common/action.c ****         send_keyboard_report();
 863:tmk_core/common/action.c ****     }
 864:tmk_core/common/action.c **** #endif
 865:tmk_core/common/action.c **** 
 866:tmk_core/common/action.c ****     else if IS_KEY (code) {
 381               		.loc 1 866 10 is_stmt 1 view .LVU81
 382               		.loc 1 866 13 is_stmt 0 view .LVU82
 383 0004 9CEF      		ldi r25,lo8(-4)
 384 0006 980F      		add r25,r24
 385 0008 913A      		cpi r25,lo8(-95)
 386 000a 00F4      		brsh .L25
 867:tmk_core/common/action.c ****         del_key(code);
 387               		.loc 1 867 9 is_stmt 1 view .LVU83
 388 000c 0E94 0000 		call del_key
 389               	.LVL38:
 868:tmk_core/common/action.c ****         send_keyboard_report();
 390               		.loc 1 868 9 view .LVU84
 391               	.L32:
 869:tmk_core/common/action.c ****     } else if IS_MOD (code) {
 870:tmk_core/common/action.c ****         del_mods(MOD_BIT(code));
 871:tmk_core/common/action.c ****         send_keyboard_report();
 392               		.loc 1 871 9 view .LVU85
 393 0010 0C94 0000 		jmp send_keyboard_report
 394               	.LVL39:
 395               	.L25:
 869:tmk_core/common/action.c ****     } else if IS_MOD (code) {
 396               		.loc 1 869 12 view .LVU86
 869:tmk_core/common/action.c ****     } else if IS_MOD (code) {
 397               		.loc 1 869 15 is_stmt 0 view .LVU87
 398 0014 90E2      		ldi r25,lo8(32)
 399 0016 980F      		add r25,r24
 400 0018 9830      		cpi r25,lo8(8)
 401 001a 00F4      		brsh .L26
 870:tmk_core/common/action.c ****         send_keyboard_report();
 402               		.loc 1 870 9 is_stmt 1 view .LVU88
 870:tmk_core/common/action.c ****         send_keyboard_report();
 403               		.loc 1 870 18 is_stmt 0 view .LVU89
 404 001c 8770      		andi r24,lo8(7)
 405               	.LVL40:
 870:tmk_core/common/action.c ****         send_keyboard_report();
 406               		.loc 1 870 9 view .LVU90
 407 001e 91E0      		ldi r25,lo8(1)
 408 0020 00C0      		rjmp 2f
 409               		1:
 410 0022 990F      		lsl r25
 411               		2:
 412 0024 8A95      		dec r24
 413 0026 02F4      		brpl 1b
 414 0028 892F      		mov r24,r25
 415 002a 0E94 0000 		call del_mods
 416               	.LVL41:
 417 002e 00C0      		rjmp .L32
 418               	.LVL42:
 419               	.L26:
 872:tmk_core/common/action.c ****     } else if IS_SYSTEM (code) {
 420               		.loc 1 872 12 is_stmt 1 view .LVU91
 421               		.loc 1 872 15 is_stmt 0 view .LVU92
 422 0030 9BE5      		ldi r25,lo8(91)
 423 0032 980F      		add r25,r24
 424 0034 9330      		cpi r25,lo8(3)
 425 0036 00F4      		brsh .L27
 873:tmk_core/common/action.c ****         host_system_send(0);
 426               		.loc 1 873 9 is_stmt 1 view .LVU93
 427 0038 90E0      		ldi r25,0
 428 003a 80E0      		ldi r24,0
 429               	.LVL43:
 430               		.loc 1 873 9 is_stmt 0 view .LVU94
 431 003c 0C94 0000 		jmp host_system_send
 432               	.LVL44:
 433               	.L27:
 874:tmk_core/common/action.c ****     } else if IS_CONSUMER (code) {
 434               		.loc 1 874 12 is_stmt 1 view .LVU95
 435               		.loc 1 874 15 is_stmt 0 view .LVU96
 436 0040 98E5      		ldi r25,lo8(88)
 437 0042 980F      		add r25,r24
 438 0044 9731      		cpi r25,lo8(23)
 439 0046 00F4      		brsh .L28
 875:tmk_core/common/action.c ****         host_consumer_send(0);
 440               		.loc 1 875 9 is_stmt 1 view .LVU97
 441 0048 90E0      		ldi r25,0
 442 004a 80E0      		ldi r24,0
 443               	.LVL45:
 444               		.loc 1 875 9 is_stmt 0 view .LVU98
 445 004c 0C94 0000 		jmp host_consumer_send
 446               	.LVL46:
 447               	.L28:
 876:tmk_core/common/action.c ****     }
 877:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 878:tmk_core/common/action.c ****     else if IS_MOUSEKEY (code) {
 448               		.loc 1 878 10 is_stmt 1 view .LVU99
 449               		.loc 1 878 13 is_stmt 0 view .LVU100
 450 0050 8D3E      		cpi r24,lo8(-19)
 451 0052 00F0      		brlo .L23
 879:tmk_core/common/action.c ****         mousekey_off(code);
 452               		.loc 1 879 9 is_stmt 1 view .LVU101
 453 0054 0E94 0000 		call mousekey_off
 454               	.LVL47:
 880:tmk_core/common/action.c ****         mousekey_send();
 455               		.loc 1 880 9 view .LVU102
 456 0058 0C94 0000 		jmp mousekey_send
 457               	.LVL48:
 458               	.L23:
 459               	/* epilogue start */
 881:tmk_core/common/action.c ****     }
 882:tmk_core/common/action.c **** #endif
 883:tmk_core/common/action.c **** }
 460               		.loc 1 883 1 is_stmt 0 view .LVU103
 461 005c 0895      		ret
 462               		.cfi_endproc
 463               	.LFE24:
 465               		.section	.text.tap_code_delay,"ax",@progbits
 466               	.global	tap_code_delay
 468               	tap_code_delay:
 469               	.LVL49:
 470               	.LFB25:
 884:tmk_core/common/action.c **** 
 885:tmk_core/common/action.c **** /** \brief Tap a keycode with a delay.
 886:tmk_core/common/action.c ****  *
 887:tmk_core/common/action.c ****  * \param code The basic keycode to tap.
 888:tmk_core/common/action.c ****  * \param delay The amount of time in milliseconds to leave the keycode registered, before unregist
 889:tmk_core/common/action.c ****  */
 890:tmk_core/common/action.c **** void tap_code_delay(uint8_t code, uint16_t delay) {
 471               		.loc 1 890 51 is_stmt 1 view -0
 472               		.cfi_startproc
 473               		.loc 1 890 51 is_stmt 0 view .LVU105
 474 0000 1F93      		push r17
 475               	.LCFI10:
 476               		.cfi_def_cfa_offset 3
 477               		.cfi_offset 17, -2
 478 0002 CF93      		push r28
 479               	.LCFI11:
 480               		.cfi_def_cfa_offset 4
 481               		.cfi_offset 28, -3
 482 0004 DF93      		push r29
 483               	.LCFI12:
 484               		.cfi_def_cfa_offset 5
 485               		.cfi_offset 29, -4
 486               	/* prologue: function */
 487               	/* frame size = 0 */
 488               	/* stack size = 3 */
 489               	.L__stack_usage = 3
 490 0006 182F      		mov r17,r24
 491 0008 EB01      		movw r28,r22
 891:tmk_core/common/action.c ****     register_code(code);
 492               		.loc 1 891 5 is_stmt 1 view .LVU106
 493 000a 0E94 0000 		call register_code
 494               	.LVL50:
 892:tmk_core/common/action.c ****     for (uint16_t i = delay; i > 0; i--) {
 495               		.loc 1 892 5 view .LVU107
 496               	.LBB23:
 497               		.loc 1 892 10 view .LVU108
 498               	.L34:
 499               		.loc 1 892 30 discriminator 1 view .LVU109
 500               		.loc 1 892 5 is_stmt 0 discriminator 1 view .LVU110
 501 000e 2097      		sbiw r28,0
 502 0010 01F4      		brne .L35
 503               		.loc 1 892 5 discriminator 1 view .LVU111
 504               	.LBE23:
 893:tmk_core/common/action.c ****         wait_ms(1);
 894:tmk_core/common/action.c ****     }
 895:tmk_core/common/action.c ****     unregister_code(code);
 505               		.loc 1 895 5 is_stmt 1 view .LVU112
 506 0012 812F      		mov r24,r17
 507               	/* epilogue start */
 896:tmk_core/common/action.c **** }
 508               		.loc 1 896 1 is_stmt 0 view .LVU113
 509 0014 DF91      		pop r29
 510 0016 CF91      		pop r28
 511               	.LVL51:
 512               		.loc 1 896 1 view .LVU114
 513 0018 1F91      		pop r17
 514               	.LVL52:
 895:tmk_core/common/action.c **** }
 515               		.loc 1 895 5 view .LVU115
 516 001a 0C94 0000 		jmp unregister_code
 517               	.LVL53:
 518               	.L35:
 519               	.LBB26:
 893:tmk_core/common/action.c ****         wait_ms(1);
 520               		.loc 1 893 9 is_stmt 1 view .LVU116
 521               	.LBB24:
 522               	.LBI24:
 523               		.file 3 "e:\\game\\msys2\\mingw64\\avr\\include\\util\\delay.h"
   1:e:\game\msys2\mingw64\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:e:\game\msys2\mingw64\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:e:\game\msys2\mingw64\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:e:\game\msys2\mingw64\avr\include\util\delay.h ****    All rights reserved.
   5:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
   6:e:\game\msys2\mingw64\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:e:\game\msys2\mingw64\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
   9:e:\game\msys2\mingw64\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:e:\game\msys2\mingw64\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  12:e:\game\msys2\mingw64\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:e:\game\msys2\mingw64\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:e:\game\msys2\mingw64\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:e:\game\msys2\mingw64\avr\include\util\delay.h ****      distribution.
  16:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  17:e:\game\msys2\mingw64\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:e:\game\msys2\mingw64\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:e:\game\msys2\mingw64\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  21:e:\game\msys2\mingw64\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:e:\game\msys2\mingw64\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:e:\game\msys2\mingw64\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:e:\game\msys2\mingw64\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:e:\game\msys2\mingw64\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:e:\game\msys2\mingw64\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:e:\game\msys2\mingw64\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:e:\game\msys2\mingw64\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:e:\game\msys2\mingw64\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:e:\game\msys2\mingw64\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:e:\game\msys2\mingw64\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  33:e:\game\msys2\mingw64\avr\include\util\delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  35:e:\game\msys2\mingw64\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:e:\game\msys2\mingw64\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  38:e:\game\msys2\mingw64\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:e:\game\msys2\mingw64\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:e:\game\msys2\mingw64\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:e:\game\msys2\mingw64\avr\include\util\delay.h **** #  endif
  42:e:\game\msys2\mingw64\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  44:e:\game\msys2\mingw64\avr\include\util\delay.h **** #include <inttypes.h>
  45:e:\game\msys2\mingw64\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:e:\game\msys2\mingw64\avr\include\util\delay.h **** #include <math.h>
  47:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  48:e:\game\msys2\mingw64\avr\include\util\delay.h **** /** \file */
  49:e:\game\msys2\mingw64\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:e:\game\msys2\mingw64\avr\include\util\delay.h ****     \code
  51:e:\game\msys2\mingw64\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:e:\game\msys2\mingw64\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:e:\game\msys2\mingw64\avr\include\util\delay.h ****     #include <util/delay.h>
  54:e:\game\msys2\mingw64\avr\include\util\delay.h ****     \endcode
  55:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  56:e:\game\msys2\mingw64\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:e:\game\msys2\mingw64\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:e:\game\msys2\mingw64\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:e:\game\msys2\mingw64\avr\include\util\delay.h ****     used.
  60:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  61:e:\game\msys2\mingw64\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:e:\game\msys2\mingw64\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:e:\game\msys2\mingw64\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:e:\game\msys2\mingw64\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:e:\game\msys2\mingw64\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:e:\game\msys2\mingw64\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:e:\game\msys2\mingw64\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:e:\game\msys2\mingw64\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  70:e:\game\msys2\mingw64\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:e:\game\msys2\mingw64\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:e:\game\msys2\mingw64\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:e:\game\msys2\mingw64\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:e:\game\msys2\mingw64\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:e:\game\msys2\mingw64\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:e:\game\msys2\mingw64\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:e:\game\msys2\mingw64\avr\include\util\delay.h ****     routines linked into the application.
  78:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  79:e:\game\msys2\mingw64\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:e:\game\msys2\mingw64\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:e:\game\msys2\mingw64\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  83:e:\game\msys2\mingw64\avr\include\util\delay.h **** */
  84:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  85:e:\game\msys2\mingw64\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:e:\game\msys2\mingw64\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:e:\game\msys2\mingw64\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:e:\game\msys2\mingw64\avr\include\util\delay.h **** #endif
  89:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  90:e:\game\msys2\mingw64\avr\include\util\delay.h **** #ifndef F_CPU
  91:e:\game\msys2\mingw64\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:e:\game\msys2\mingw64\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:e:\game\msys2\mingw64\avr\include\util\delay.h **** /** \ingroup util_delay
  94:e:\game\msys2\mingw64\avr\include\util\delay.h ****     \def F_CPU
  95:e:\game\msys2\mingw64\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  97:e:\game\msys2\mingw64\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:e:\game\msys2\mingw64\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:e:\game\msys2\mingw64\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:e:\game\msys2\mingw64\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:e:\game\msys2\mingw64\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 103:e:\game\msys2\mingw64\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:e:\game\msys2\mingw64\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:e:\game\msys2\mingw64\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:e:\game\msys2\mingw64\avr\include\util\delay.h ****     integer value.
 107:e:\game\msys2\mingw64\avr\include\util\delay.h ****  */
 108:e:\game\msys2\mingw64\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:e:\game\msys2\mingw64\avr\include\util\delay.h **** #endif
 110:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 111:e:\game\msys2\mingw64\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:e:\game\msys2\mingw64\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:e:\game\msys2\mingw64\avr\include\util\delay.h **** #endif
 114:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 115:e:\game\msys2\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:e:\game\msys2\mingw64\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:e:\game\msys2\mingw64\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:e:\game\msys2\mingw64\avr\include\util\delay.h **** #  include <math.h>
 119:e:\game\msys2\mingw64\avr\include\util\delay.h **** #endif
 120:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 121:e:\game\msys2\mingw64\avr\include\util\delay.h **** /**
 122:e:\game\msys2\mingw64\avr\include\util\delay.h ****    \ingroup util_delay
 123:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 124:e:\game\msys2\mingw64\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 126:e:\game\msys2\mingw64\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:e:\game\msys2\mingw64\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 129:e:\game\msys2\mingw64\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 131:e:\game\msys2\mingw64\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:e:\game\msys2\mingw64\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:e:\game\msys2\mingw64\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:e:\game\msys2\mingw64\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:e:\game\msys2\mingw64\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 137:e:\game\msys2\mingw64\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:e:\game\msys2\mingw64\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:e:\game\msys2\mingw64\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:e:\game\msys2\mingw64\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 142:e:\game\msys2\mingw64\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:e:\game\msys2\mingw64\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:e:\game\msys2\mingw64\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:e:\game\msys2\mingw64\avr\include\util\delay.h ****    microseconds of delay.
 146:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 147:e:\game\msys2\mingw64\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:e:\game\msys2\mingw64\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:e:\game\msys2\mingw64\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:e:\game\msys2\mingw64\avr\include\util\delay.h ****    respectively.
 151:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 152:e:\game\msys2\mingw64\avr\include\util\delay.h ****    \note
 153:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 154:e:\game\msys2\mingw64\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:e:\game\msys2\mingw64\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:e:\game\msys2\mingw64\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:e:\game\msys2\mingw64\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:e:\game\msys2\mingw64\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:e:\game\msys2\mingw64\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:e:\game\msys2\mingw64\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:e:\game\msys2\mingw64\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:e:\game\msys2\mingw64\avr\include\util\delay.h ****    not available to the compiler then.
 163:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 164:e:\game\msys2\mingw64\avr\include\util\delay.h ****  */
 165:e:\game\msys2\mingw64\avr\include\util\delay.h **** void
 166:e:\game\msys2\mingw64\avr\include\util\delay.h **** _delay_ms(double __ms)
 524               		.loc 3 166 1 view .LVU117
 525               	.LBB25:
 167:e:\game\msys2\mingw64\avr\include\util\delay.h **** {
 168:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	double __tmp ;
 526               		.loc 3 168 2 view .LVU118
 169:e:\game\msys2\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:e:\game\msys2\mingw64\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:e:\game\msys2\mingw64\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 527               		.loc 3 172 2 view .LVU119
 173:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 528               		.loc 3 173 2 view .LVU120
 174:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 529               		.loc 3 174 2 view .LVU121
 175:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 176:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:e:\game\msys2\mingw64\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 179:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:e:\game\msys2\mingw64\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 182:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	#else
 183:e:\game\msys2\mingw64\avr\include\util\delay.h **** 		//round up by default
 184:e:\game\msys2\mingw64\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 530               		.loc 3 184 3 view .LVU122
 185:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	#endif
 186:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 187:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 531               		.loc 3 187 2 view .LVU123
 532 001e 8FE9      		ldi r24,lo8(3999)
 533 0020 9FE0      		ldi r25,hi8(3999)
 534 0022 0197      	1:	sbiw r24,1
 535 0024 01F4      		brne 1b
 536 0026 00C0      		rjmp .
 537 0028 0000      		nop
 538               	.LVL54:
 539               		.loc 3 187 2 is_stmt 0 view .LVU124
 540               	.LBE25:
 541               	.LBE24:
 892:tmk_core/common/action.c ****         wait_ms(1);
 542               		.loc 1 892 37 is_stmt 1 view .LVU125
 892:tmk_core/common/action.c ****         wait_ms(1);
 543               		.loc 1 892 38 is_stmt 0 view .LVU126
 544 002a 2197      		sbiw r28,1
 545               	.LVL55:
 892:tmk_core/common/action.c ****         wait_ms(1);
 546               		.loc 1 892 38 view .LVU127
 547 002c 00C0      		rjmp .L34
 548               	.LBE26:
 549               		.cfi_endproc
 550               	.LFE25:
 552               		.section	.text.tap_code,"ax",@progbits
 553               	.global	tap_code
 555               	tap_code:
 556               	.LVL56:
 557               	.LFB26:
 897:tmk_core/common/action.c **** 
 898:tmk_core/common/action.c **** /** \brief Tap a keycode with the default delay.
 899:tmk_core/common/action.c ****  *
 900:tmk_core/common/action.c ****  * \param code The basic keycode to tap. If `code` is `KC_CAPS`, the delay will be `TAP_HOLD_CAPS_D
 901:tmk_core/common/action.c ****  */
 902:tmk_core/common/action.c **** void tap_code(uint8_t code) { tap_code_delay(code, code == KC_CAPS ? TAP_HOLD_CAPS_DELAY : TAP_CODE
 558               		.loc 1 902 29 is_stmt 1 view -0
 559               		.cfi_startproc
 560               	/* prologue: function */
 561               	/* frame size = 0 */
 562               	/* stack size = 0 */
 563               	.L__stack_usage = 0
 564               		.loc 1 902 31 view .LVU129
 565 0000 70E0      		ldi r23,0
 566 0002 60E0      		ldi r22,0
 567 0004 8933      		cpi r24,lo8(57)
 568 0006 01F4      		brne .L37
 569 0008 60E5      		ldi r22,lo8(80)
 570 000a 70E0      		ldi r23,0
 571               	.L37:
 572               		.loc 1 902 31 is_stmt 0 discriminator 4 view .LVU130
 573 000c 0C94 0000 		jmp tap_code_delay
 574               	.LVL57:
 575               		.loc 1 902 31 discriminator 4 view .LVU131
 576               		.cfi_endproc
 577               	.LFE26:
 579               		.section	.text.register_mods,"ax",@progbits
 580               	.global	register_mods
 582               	register_mods:
 583               	.LVL58:
 584               	.LFB27:
 903:tmk_core/common/action.c **** 
 904:tmk_core/common/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 905:tmk_core/common/action.c ****  *
 906:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 907:tmk_core/common/action.c ****  */
 908:tmk_core/common/action.c **** void register_mods(uint8_t mods) {
 585               		.loc 1 908 34 is_stmt 1 view -0
 586               		.cfi_startproc
 587               	/* prologue: function */
 588               	/* frame size = 0 */
 589               	/* stack size = 0 */
 590               	.L__stack_usage = 0
 909:tmk_core/common/action.c ****     if (mods) {
 591               		.loc 1 909 5 view .LVU133
 592               		.loc 1 909 8 is_stmt 0 view .LVU134
 593 0000 8823      		tst r24
 594 0002 01F0      		breq .L39
 910:tmk_core/common/action.c ****         add_mods(mods);
 595               		.loc 1 910 9 is_stmt 1 view .LVU135
 596 0004 0E94 0000 		call add_mods
 597               	.LVL59:
 911:tmk_core/common/action.c ****         send_keyboard_report();
 598               		.loc 1 911 9 view .LVU136
 599 0008 0C94 0000 		jmp send_keyboard_report
 600               	.LVL60:
 601               	.L39:
 602               	/* epilogue start */
 912:tmk_core/common/action.c ****     }
 913:tmk_core/common/action.c **** }
 603               		.loc 1 913 1 is_stmt 0 view .LVU137
 604 000c 0895      		ret
 605               		.cfi_endproc
 606               	.LFE27:
 608               		.section	.text.unregister_mods,"ax",@progbits
 609               	.global	unregister_mods
 611               	unregister_mods:
 612               	.LVL61:
 613               	.LFB28:
 914:tmk_core/common/action.c **** 
 915:tmk_core/common/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 916:tmk_core/common/action.c ****  *
 917:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 918:tmk_core/common/action.c ****  */
 919:tmk_core/common/action.c **** void unregister_mods(uint8_t mods) {
 614               		.loc 1 919 36 is_stmt 1 view -0
 615               		.cfi_startproc
 616               	/* prologue: function */
 617               	/* frame size = 0 */
 618               	/* stack size = 0 */
 619               	.L__stack_usage = 0
 920:tmk_core/common/action.c ****     if (mods) {
 620               		.loc 1 920 5 view .LVU139
 621               		.loc 1 920 8 is_stmt 0 view .LVU140
 622 0000 8823      		tst r24
 623 0002 01F0      		breq .L41
 921:tmk_core/common/action.c ****         del_mods(mods);
 624               		.loc 1 921 9 is_stmt 1 view .LVU141
 625 0004 0E94 0000 		call del_mods
 626               	.LVL62:
 922:tmk_core/common/action.c ****         send_keyboard_report();
 627               		.loc 1 922 9 view .LVU142
 628 0008 0C94 0000 		jmp send_keyboard_report
 629               	.LVL63:
 630               	.L41:
 631               	/* epilogue start */
 923:tmk_core/common/action.c ****     }
 924:tmk_core/common/action.c **** }
 632               		.loc 1 924 1 is_stmt 0 view .LVU143
 633 000c 0895      		ret
 634               		.cfi_endproc
 635               	.LFE28:
 637               		.section	.text.process_action,"ax",@progbits
 638               	.global	process_action
 640               	process_action:
 641               	.LVL64:
 642               	.LFB22:
 240:tmk_core/common/action.c ****     keyevent_t event = record->event;
 643               		.loc 1 240 59 is_stmt 1 view -0
 644               		.cfi_startproc
 240:tmk_core/common/action.c ****     keyevent_t event = record->event;
 645               		.loc 1 240 59 is_stmt 0 view .LVU145
 646 0000 BF92      		push r11
 647               	.LCFI13:
 648               		.cfi_def_cfa_offset 3
 649               		.cfi_offset 11, -2
 650 0002 CF92      		push r12
 651               	.LCFI14:
 652               		.cfi_def_cfa_offset 4
 653               		.cfi_offset 12, -3
 654 0004 DF92      		push r13
 655               	.LCFI15:
 656               		.cfi_def_cfa_offset 5
 657               		.cfi_offset 13, -4
 658 0006 EF92      		push r14
 659               	.LCFI16:
 660               		.cfi_def_cfa_offset 6
 661               		.cfi_offset 14, -5
 662 0008 FF92      		push r15
 663               	.LCFI17:
 664               		.cfi_def_cfa_offset 7
 665               		.cfi_offset 15, -6
 666 000a 0F93      		push r16
 667               	.LCFI18:
 668               		.cfi_def_cfa_offset 8
 669               		.cfi_offset 16, -7
 670 000c 1F93      		push r17
 671               	.LCFI19:
 672               		.cfi_def_cfa_offset 9
 673               		.cfi_offset 17, -8
 674 000e CF93      		push r28
 675               	.LCFI20:
 676               		.cfi_def_cfa_offset 10
 677               		.cfi_offset 28, -9
 678 0010 DF93      		push r29
 679               	.LCFI21:
 680               		.cfi_def_cfa_offset 11
 681               		.cfi_offset 29, -10
 682               	/* prologue: function */
 683               	/* frame size = 0 */
 684               	/* stack size = 9 */
 685               	.L__stack_usage = 9
 686 0012 6C01      		movw r12,r24
 687 0014 D62F      		mov r29,r22
 240:tmk_core/common/action.c ****     keyevent_t event = record->event;
 688               		.loc 1 240 59 view .LVU146
 689 0016 C72F      		mov r28,r23
 241:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 690               		.loc 1 241 5 is_stmt 1 view .LVU147
 241:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 691               		.loc 1 241 16 is_stmt 0 view .LVU148
 692 0018 FC01      		movw r30,r24
 693 001a 1281      		ldd r17,Z+2
 694               	.LVL65:
 243:tmk_core/common/action.c **** #endif
 695               		.loc 1 243 5 is_stmt 1 view .LVU149
 243:tmk_core/common/action.c **** #endif
 696               		.loc 1 243 36 is_stmt 0 view .LVU150
 697 001c 0581      		ldd r16,Z+5
 698 001e 0295      		swap r16
 699 0020 0F70      		andi r16,lo8(15)
 700               	.LVL66:
 247:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 701               		.loc 1 247 5 is_stmt 1 view .LVU151
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 702               		.loc 1 249 5 view .LVU152
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 703               		.loc 1 249 9 is_stmt 0 view .LVU153
 704 0022 0E94 0000 		call is_oneshot_layer_active
 705               	.LVL67:
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 706               		.loc 1 249 9 view .LVU154
 707 0026 E82E      		mov r14,r24
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 708               		.loc 1 249 8 view .LVU155
 709 0028 8823      		tst r24
 710 002a 01F0      		breq .L44
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 711               		.loc 1 249 43 discriminator 1 view .LVU156
 712 002c E12E      		mov r14,r17
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 713               		.loc 1 249 35 discriminator 1 view .LVU157
 714 002e 1123      		tst r17
 715 0030 01F0      		breq .L44
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 716               		.loc 1 249 71 discriminator 2 view .LVU158
 717 0032 8C2F      		mov r24,r28
 718 0034 807F      		andi r24,lo8(-16)
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 719               		.loc 1 249 52 discriminator 2 view .LVU159
 720 0036 8034      		cpi r24,lo8(64)
 721 0038 01F0      		breq .L45
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 722               		.loc 1 249 87 discriminator 3 view .LVU160
 723 003a 80E2      		ldi r24,lo8(32)
 724               	.LVL68:
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 725               		.loc 1 249 87 discriminator 3 view .LVU161
 726 003c 8D0F      		add r24,r29
 247:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 727               		.loc 1 247 10 discriminator 3 view .LVU162
 728 003e E12C      		mov r14,__zero_reg__
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 729               		.loc 1 249 84 discriminator 3 view .LVU163
 730 0040 8830      		cpi r24,lo8(8)
 731 0042 00F0      		brlo .L44
 732               	.L45:
 254:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 733               		.loc 1 254 9 is_stmt 1 view .LVU164
 734 0044 82E0      		ldi r24,lo8(2)
 735 0046 0E94 0000 		call clear_oneshot_layer_state
 736               	.LVL69:
 255:tmk_core/common/action.c ****     }
 737               		.loc 1 255 9 view .LVU165
 255:tmk_core/common/action.c ****     }
 738               		.loc 1 255 31 is_stmt 0 view .LVU166
 739 004a 0E94 0000 		call is_oneshot_layer_active
 740               	.LVL70:
 255:tmk_core/common/action.c ****     }
 741               		.loc 1 255 9 view .LVU167
 742 004e 91E0      		ldi r25,lo8(1)
 743 0050 E82E      		mov r14,r24
 744 0052 E926      		eor r14,r25
 745               	.LVL71:
 746               	.L44:
 259:tmk_core/common/action.c ****         /* Key and Mods */
 747               		.loc 1 259 5 is_stmt 1 view .LVU168
 259:tmk_core/common/action.c ****         /* Key and Mods */
 748               		.loc 1 259 24 is_stmt 0 view .LVU169
 749 0054 BC2E      		mov r11,r28
 750 0056 B294      		swap r11
 751 0058 9FE0      		ldi r25,lo8(15)
 752 005a B922      		and r11,r25
 259:tmk_core/common/action.c ****         /* Key and Mods */
 753               		.loc 1 259 5 view .LVU170
 754 005c EB2D      		mov r30,r11
 755 005e F0E0      		ldi r31,0
 756 0060 E050      		subi r30,lo8(-(gs(.L48)))
 757 0062 F040      		sbci r31,hi8(-(gs(.L48)))
 758 0064 0C94 0000 		jmp __tablejump2__
 759               		.section	.jumptables.gcc.process_action,"a",@progbits
 760               		.p2align	1
 761               	.L48:
 762 0000 0000      		.word gs(.L56)
 763 0002 0000      		.word gs(.L56)
 764 0004 0000      		.word gs(.L55)
 765 0006 0000      		.word gs(.L55)
 766 0008 0000      		.word gs(.L54)
 767 000a 0000      		.word gs(.L53)
 768 000c 0000      		.word gs(.L46)
 769 000e 0000      		.word gs(.L46)
 770 0010 0000      		.word gs(.L52)
 771 0012 0000      		.word gs(.L51)
 772 0014 0000      		.word gs(.L50)
 773 0016 0000      		.word gs(.L50)
 774 0018 0000      		.word gs(.L49)
 775 001a 0000      		.word gs(.L46)
 776 001c 0000      		.word gs(.L46)
 777 001e 0000      		.word gs(.L47)
 778               		.section	.text.process_action
 779               	.L56:
 780               	.LBB27:
 263:tmk_core/common/action.c ****             if (event.pressed) {
 781               		.loc 1 263 13 is_stmt 1 view .LVU171
 782 0068 0C2F      		mov r16,r28
 783               	.LVL72:
 263:tmk_core/common/action.c ****             if (event.pressed) {
 784               		.loc 1 263 13 is_stmt 0 view .LVU172
 785 006a 0F70      		andi r16,lo8(15)
 263:tmk_core/common/action.c ****             if (event.pressed) {
 786               		.loc 1 263 44 view .LVU173
 787 006c C07F      		andi r28,lo8(-16)
 788               	.LVL73:
 263:tmk_core/common/action.c ****             if (event.pressed) {
 789               		.loc 1 263 21 view .LVU174
 790 006e 01F0      		breq .L57
 263:tmk_core/common/action.c ****             if (event.pressed) {
 791               		.loc 1 263 21 discriminator 2 view .LVU175
 792 0070 0295      		swap r16
 793 0072 007F      		andi r16,lo8(-16)
 794               	.L57:
 795               	.LVL74:
 264:tmk_core/common/action.c ****                 if (mods) {
 796               		.loc 1 264 13 is_stmt 1 discriminator 4 view .LVU176
 264:tmk_core/common/action.c ****                 if (mods) {
 797               		.loc 1 264 16 is_stmt 0 discriminator 4 view .LVU177
 798 0074 1123      		tst r17
 799 0076 01F0      		breq .L58
 265:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 800               		.loc 1 265 17 is_stmt 1 view .LVU178
 265:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 801               		.loc 1 265 20 is_stmt 0 view .LVU179
 802 0078 0023      		tst r16
 803 007a 01F0      		breq .L155
 266:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 804               		.loc 1 266 21 is_stmt 1 view .LVU180
 266:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 805               		.loc 1 266 25 is_stmt 0 view .LVU181
 806 007c 80E2      		ldi r24,lo8(32)
 807 007e 8D0F      		add r24,r29
 266:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 808               		.loc 1 266 24 view .LVU182
 809 0080 8830      		cpi r24,lo8(8)
 810 0082 00F0      		brlo .L60
 266:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 811               		.loc 1 266 49 discriminator 1 view .LVU183
 812 0084 D111      		cpse r29,__zero_reg__
 813 0086 00C0      		rjmp .L61
 814               	.L60:
 270:tmk_core/common/action.c ****                     } else {
 815               		.loc 1 270 25 is_stmt 1 view .LVU184
 816 0088 802F      		mov r24,r16
 817 008a 0E94 0000 		call add_mods
 818               	.LVL75:
 819               	.L62:
 274:tmk_core/common/action.c ****                 }
 820               		.loc 1 274 21 view .LVU185
 821 008e 0E94 0000 		call send_keyboard_report
 822               	.LVL76:
 276:tmk_core/common/action.c ****             } else {
 823               		.loc 1 276 17 view .LVU186
 824               	.L155:
 276:tmk_core/common/action.c ****             } else {
 825               		.loc 1 276 17 is_stmt 0 view .LVU187
 826               	.LBE27:
 555:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 827               		.loc 1 555 75 is_stmt 1 view .LVU188
 556:tmk_core/common/action.c ****                         } else {
 828               		.loc 1 556 29 view .LVU189
 829 0092 8D2F      		mov r24,r29
 830 0094 0E94 0000 		call register_code
 831               	.LVL77:
 832 0098 00C0      		rjmp .L46
 833               	.LVL78:
 834               	.L61:
 835               	.LBB28:
 272:tmk_core/common/action.c ****                     }
 836               		.loc 1 272 25 view .LVU190
 837 009a 802F      		mov r24,r16
 838 009c 0E94 0000 		call add_weak_mods
 839               	.LVL79:
 840 00a0 00C0      		rjmp .L62
 841               	.L58:
 278:tmk_core/common/action.c ****                 if (mods) {
 842               		.loc 1 278 17 view .LVU191
 843 00a2 8D2F      		mov r24,r29
 844 00a4 0E94 0000 		call unregister_code
 845               	.LVL80:
 279:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 846               		.loc 1 279 17 view .LVU192
 279:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 847               		.loc 1 279 20 is_stmt 0 view .LVU193
 848 00a8 0023      		tst r16
 849 00aa 01F0      		breq .L46
 280:tmk_core/common/action.c ****                         del_mods(mods);
 850               		.loc 1 280 21 is_stmt 1 view .LVU194
 280:tmk_core/common/action.c ****                         del_mods(mods);
 851               		.loc 1 280 25 is_stmt 0 view .LVU195
 852 00ac 80E2      		ldi r24,lo8(32)
 853 00ae 8D0F      		add r24,r29
 280:tmk_core/common/action.c ****                         del_mods(mods);
 854               		.loc 1 280 24 view .LVU196
 855 00b0 8830      		cpi r24,lo8(8)
 856 00b2 00F0      		brlo .L64
 280:tmk_core/common/action.c ****                         del_mods(mods);
 857               		.loc 1 280 49 discriminator 1 view .LVU197
 858 00b4 D111      		cpse r29,__zero_reg__
 859 00b6 00C0      		rjmp .L65
 860               	.L64:
 281:tmk_core/common/action.c ****                     } else {
 861               		.loc 1 281 25 is_stmt 1 view .LVU198
 862 00b8 802F      		mov r24,r16
 863 00ba 0E94 0000 		call del_mods
 864               	.LVL81:
 865               	.L66:
 285:tmk_core/common/action.c ****                 }
 866               		.loc 1 285 21 view .LVU199
 867 00be 0E94 0000 		call send_keyboard_report
 868               	.LVL82:
 869               	.L46:
 285:tmk_core/common/action.c ****                 }
 870               		.loc 1 285 21 is_stmt 0 view .LVU200
 871               	.LBE28:
 670:tmk_core/common/action.c ****         case ACT_LAYER:
 872               		.loc 1 670 5 is_stmt 1 view .LVU201
 873 00c2 2B2D      		mov r18,r11
 874 00c4 2850      		subi r18,8
 875 00c6 330B      		sbc r19,r19
 876 00c8 2430      		cpi r18,4
 877 00ca 3105      		cpc r19,__zero_reg__
 878 00cc 00F4      		brsh .L119
 677:tmk_core/common/action.c ****             break;
 879               		.loc 1 677 13 view .LVU202
 880 00ce 0E94 0000 		call host_keyboard_leds
 881               	.LVL83:
 882 00d2 0E94 0000 		call led_set
 883               	.LVL84:
 678:tmk_core/common/action.c ****         default:
 884               		.loc 1 678 13 view .LVU203
 885               	.L119:
 723:tmk_core/common/action.c ****         record->event.pressed = false;
 886               		.loc 1 723 5 view .LVU204
 723:tmk_core/common/action.c ****         record->event.pressed = false;
 887               		.loc 1 723 8 is_stmt 0 view .LVU205
 888 00d6 EE20      		tst r14
 889 00d8 01F4      		brne .+2
 890 00da 00C0      		rjmp .L43
 723:tmk_core/common/action.c ****         record->event.pressed = false;
 891               		.loc 1 723 33 discriminator 1 view .LVU206
 892 00dc 0E94 0000 		call get_oneshot_layer_state
 893               	.LVL85:
 723:tmk_core/common/action.c ****         record->event.pressed = false;
 894               		.loc 1 723 28 discriminator 1 view .LVU207
 895 00e0 80FD      		sbrc r24,0
 896 00e2 00C0      		rjmp .L43
 724:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 897               		.loc 1 724 9 is_stmt 1 view .LVU208
 724:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 898               		.loc 1 724 31 is_stmt 0 view .LVU209
 899 00e4 F601      		movw r30,r12
 900 00e6 1282      		std Z+2,__zero_reg__
 725:tmk_core/common/action.c ****         process_record(record);
 901               		.loc 1 725 9 is_stmt 1 view .LVU210
 902 00e8 0E94 0000 		call get_oneshot_layer
 903               	.LVL86:
 904 00ec 0E94 0000 		call layer_on
 905               	.LVL87:
 726:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 906               		.loc 1 726 9 view .LVU211
 907 00f0 C601      		movw r24,r12
 908 00f2 0E94 0000 		call process_record
 909               	.LVL88:
 727:tmk_core/common/action.c ****     }
 910               		.loc 1 727 9 view .LVU212
 911 00f6 0E94 0000 		call get_oneshot_layer
 912               	.LVL89:
 913               	/* epilogue start */
 730:tmk_core/common/action.c **** 
 914               		.loc 1 730 1 is_stmt 0 view .LVU213
 915 00fa DF91      		pop r29
 916               	.LVL90:
 730:tmk_core/common/action.c **** 
 917               		.loc 1 730 1 view .LVU214
 918 00fc CF91      		pop r28
 730:tmk_core/common/action.c **** 
 919               		.loc 1 730 1 view .LVU215
 920 00fe 1F91      		pop r17
 921 0100 0F91      		pop r16
 922 0102 FF90      		pop r15
 923 0104 EF90      		pop r14
 924               	.LVL91:
 730:tmk_core/common/action.c **** 
 925               		.loc 1 730 1 view .LVU216
 926 0106 DF90      		pop r13
 927 0108 CF90      		pop r12
 928               	.LVL92:
 730:tmk_core/common/action.c **** 
 929               		.loc 1 730 1 view .LVU217
 930 010a BF90      		pop r11
 727:tmk_core/common/action.c ****     }
 931               		.loc 1 727 9 view .LVU218
 932 010c 0C94 0000 		jmp layer_off
 933               	.LVL93:
 934               	.L65:
 935               	.LBB29:
 283:tmk_core/common/action.c ****                     }
 936               		.loc 1 283 25 is_stmt 1 view .LVU219
 937 0110 802F      		mov r24,r16
 938 0112 0E94 0000 		call del_weak_mods
 939               	.LVL94:
 940 0116 00C0      		rjmp .L66
 941               	.LVL95:
 942               	.L55:
 283:tmk_core/common/action.c ****                     }
 943               		.loc 1 283 25 is_stmt 0 view .LVU220
 944               	.LBE29:
 945               	.LBB30:
 292:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 946               		.loc 1 292 13 is_stmt 1 view .LVU221
 947 0118 FC2F      		mov r31,r28
 948 011a FF70      		andi r31,lo8(15)
 949 011c FF2E      		mov r15,r31
 292:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 950               		.loc 1 292 44 is_stmt 0 view .LVU222
 951 011e C07F      		andi r28,lo8(-16)
 952               	.LVL96:
 292:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 953               		.loc 1 292 21 view .LVU223
 954 0120 C032      		cpi r28,lo8(32)
 955 0122 01F0      		breq .L67
 292:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 956               		.loc 1 292 21 discriminator 2 view .LVU224
 957 0124 F294      		swap r15
 958 0126 80EF      		ldi r24,lo8(-16)
 959 0128 F822      		and r15,r24
 960               	.L67:
 961               	.LVL97:
 293:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 962               		.loc 1 293 13 is_stmt 1 discriminator 4 view .LVU225
 963 012a DD23      		tst r29
 964 012c 01F0      		breq .L68
 965 012e D130      		cpi r29,lo8(1)
 966 0130 01F0      		breq .L69
 348:tmk_core/common/action.c ****                         if (tap_count > 0) {
 967               		.loc 1 348 21 view .LVU226
 348:tmk_core/common/action.c ****                         if (tap_count > 0) {
 968               		.loc 1 348 24 is_stmt 0 view .LVU227
 969 0132 1123      		tst r17
 970 0134 01F0      		breq .L77
 349:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 971               		.loc 1 349 25 is_stmt 1 view .LVU228
 349:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 972               		.loc 1 349 28 is_stmt 0 view .LVU229
 973 0136 0023      		tst r16
 974 0138 01F0      		breq .L78
 351:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 975               		.loc 1 351 29 is_stmt 1 view .LVU230
 355:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 976               		.loc 1 355 33 is_stmt 0 view .LVU231
 977 013a F601      		movw r30,r12
 978 013c 8581      		ldd r24,Z+5
 351:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 979               		.loc 1 351 32 view .LVU232
 980 013e 80FF      		sbrs r24,0
 981 0140 00C0      		rjmp .L155
 356:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 982               		.loc 1 356 76 is_stmt 1 view .LVU233
 358:tmk_core/common/action.c ****                                 register_mods(mods);
 983               		.loc 1 358 33 view .LVU234
 358:tmk_core/common/action.c ****                                 register_mods(mods);
 984               		.loc 1 358 51 is_stmt 0 view .LVU235
 985 0142 8F70      		andi r24,lo8(15)
 986 0144 8583      		std Z+5,r24
 359:tmk_core/common/action.c ****                             } else
 987               		.loc 1 359 33 is_stmt 1 view .LVU236
 988 0146 00C0      		rjmp .L78
 989               	.L68:
 297:tmk_core/common/action.c ****                         if (tap_count == 0) {
 990               		.loc 1 297 21 view .LVU237
 297:tmk_core/common/action.c ****                         if (tap_count == 0) {
 991               		.loc 1 297 24 is_stmt 0 view .LVU238
 992 0148 1123      		tst r17
 993 014a 01F0      		breq .L71
 298:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 994               		.loc 1 298 25 is_stmt 1 view .LVU239
 298:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 995               		.loc 1 298 28 is_stmt 0 view .LVU240
 996 014c 0111      		cpse r16,__zero_reg__
 997 014e 00C0      		rjmp .L72
 998               	.L73:
 312:tmk_core/common/action.c ****                         }
 999               		.loc 1 312 29 is_stmt 1 view .LVU241
 312:tmk_core/common/action.c ****                         }
 1000               		.loc 1 312 50 is_stmt 0 view .LVU242
 1001 0150 0E94 0000 		call get_oneshot_mods
 1002               	.LVL98:
 312:tmk_core/common/action.c ****                         }
 1003               		.loc 1 312 29 view .LVU243
 1004 0154 8F29      		or r24,r15
 1005               	.LVL99:
 1006               	.L154:
 312:tmk_core/common/action.c ****                         }
 1007               		.loc 1 312 29 view .LVU244
 1008               	.LBE30:
 482:tmk_core/common/action.c ****             } else {
 1009               		.loc 1 482 17 view .LVU245
 1010 0156 0E94 0000 		call register_mods
 1011               	.LVL100:
 1012 015a 00C0      		rjmp .L46
 1013               	.LVL101:
 1014               	.L72:
 1015               	.LBB33:
 301:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1016               		.loc 1 301 32 is_stmt 1 view .LVU246
 301:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1017               		.loc 1 301 35 is_stmt 0 view .LVU247
 1018 015c 0130      		cpi r16,lo8(1)
 1019 015e 01F4      		brne .L73
 302:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 1020               		.loc 1 302 65 is_stmt 1 view .LVU248
 303:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1021               		.loc 1 303 29 view .LVU249
 303:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1022               		.loc 1 303 53 is_stmt 0 view .LVU250
 1023 0160 0E94 0000 		call get_oneshot_mods
 1024               	.LVL102:
 303:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1025               		.loc 1 303 29 view .LVU251
 1026 0164 8F29      		or r24,r15
 1027 0166 0E94 0000 		call set_oneshot_mods
 1028               	.LVL103:
 1029 016a 00C0      		rjmp .L46
 1030               	.L71:
 315:tmk_core/common/action.c ****                             clear_oneshot_mods();
 1031               		.loc 1 315 25 is_stmt 1 view .LVU252
 315:tmk_core/common/action.c ****                             clear_oneshot_mods();
 1032               		.loc 1 315 28 is_stmt 0 view .LVU253
 1033 016c 0111      		cpse r16,__zero_reg__
 1034 016e 00C0      		rjmp .L74
 1035               	.L157:
 330:tmk_core/common/action.c ****                             unregister_mods(mods);
 1036               		.loc 1 330 29 is_stmt 1 view .LVU254
 1037 0170 0E94 0000 		call clear_oneshot_mods
 1038               	.LVL104:
 331:tmk_core/common/action.c ****                         }
 1039               		.loc 1 331 29 view .LVU255
 1040               	.L80:
 380:tmk_core/common/action.c ****                             unregister_mods(mods);
 1041               		.loc 1 380 67 view .LVU256
 381:tmk_core/common/action.c ****                         }
 1042               		.loc 1 381 29 view .LVU257
 1043 0174 8F2D      		mov r24,r15
 1044 0176 0E94 0000 		call unregister_mods
 1045               	.LVL105:
 1046 017a 00C0      		rjmp .L46
 1047               	.L74:
 318:tmk_core/common/action.c ****                             // Retain Oneshot mods
 1048               		.loc 1 318 32 view .LVU258
 318:tmk_core/common/action.c ****                             // Retain Oneshot mods
 1049               		.loc 1 318 35 is_stmt 0 view .LVU259
 1050 017c 0130      		cpi r16,lo8(1)
 1051 017e 01F4      		brne .+2
 1052 0180 00C0      		rjmp .L46
 1053 0182 00C0      		rjmp .L157
 1054               	.L69:
 337:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1055               		.loc 1 337 21 is_stmt 1 view .LVU260
 337:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1056               		.loc 1 337 24 is_stmt 0 view .LVU261
 1057 0184 1123      		tst r17
 1058 0186 01F0      		breq .L76
 338:tmk_core/common/action.c ****                             register_mods(mods);
 1059               		.loc 1 338 25 is_stmt 1 view .LVU262
 338:tmk_core/common/action.c ****                             register_mods(mods);
 1060               		.loc 1 338 28 is_stmt 0 view .LVU263
 1061 0188 0630      		cpi r16,lo8(6)
 1062 018a 00F0      		brlo .+2
 1063 018c 00C0      		rjmp .L46
 1064               	.L78:
 367:tmk_core/common/action.c ****                             register_mods(mods);
 1065               		.loc 1 367 67 is_stmt 1 view .LVU264
 368:tmk_core/common/action.c ****                         }
 1066               		.loc 1 368 29 view .LVU265
 1067 018e 8F2D      		mov r24,r15
 1068 0190 00C0      		rjmp .L154
 1069               	.L76:
 342:tmk_core/common/action.c ****                             unregister_mods(mods);
 1070               		.loc 1 342 25 view .LVU266
 342:tmk_core/common/action.c ****                             unregister_mods(mods);
 1071               		.loc 1 342 28 is_stmt 0 view .LVU267
 1072 0192 0530      		cpi r16,lo8(5)
 1073 0194 00F0      		brlo .+2
 1074 0196 00C0      		rjmp .L46
 1075 0198 00C0      		rjmp .L80
 1076               	.L77:
 371:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1077               		.loc 1 371 25 is_stmt 1 view .LVU268
 371:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1078               		.loc 1 371 28 is_stmt 0 view .LVU269
 1079 019a 0023      		tst r16
 1080 019c 01F0      		breq .L80
 372:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1081               		.loc 1 372 71 is_stmt 1 view .LVU270
 373:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1082               		.loc 1 373 29 view .LVU271
 373:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1083               		.loc 1 373 32 is_stmt 0 view .LVU272
 1084 019e D933      		cpi r29,lo8(57)
 1085 01a0 01F4      		brne .L118
 374:tmk_core/common/action.c ****                             } else {
 1086               		.loc 1 374 33 is_stmt 1 view .LVU273
 1087               	.LVL106:
 1088               	.LBB31:
 1089               	.LBI31:
 166:e:\game\msys2\mingw64\avr\include\util\delay.h **** {
 1090               		.loc 3 166 1 view .LVU274
 1091               	.LBB32:
 168:e:\game\msys2\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1092               		.loc 3 168 2 view .LVU275
 172:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1093               		.loc 3 172 2 view .LVU276
 173:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1094               		.loc 3 173 2 view .LVU277
 174:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 1095               		.loc 3 174 2 view .LVU278
 184:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	#endif
 1096               		.loc 3 184 3 view .LVU279
 1097               		.loc 3 187 2 view .LVU280
 1098 01a2 FFEF      		ldi r31,lo8(255999)
 1099 01a4 27EE      		ldi r18,hi8(255999)
 1100 01a6 33E0      		ldi r19,hlo8(255999)
 1101 01a8 F150      	1:	subi r31,1
 1102 01aa 2040      		sbci r18,0
 1103 01ac 3040      		sbci r19,0
 1104 01ae 01F4      		brne 1b
 1105               	.LVL107:
 1106               	.L158:
 1107               		.loc 3 187 2 is_stmt 0 view .LVU281
 1108               	.LBE32:
 1109               	.LBE31:
 1110               	.LBE33:
 1111               	.LBB34:
 1112               	.LBB35:
 1113 01b0 00C0      		rjmp .
 1114 01b2 0000      		nop
 1115               	.L118:
 1116               	.LBE35:
 1117               	.LBE34:
 569:tmk_core/common/action.c ****                         } else {
 1118               		.loc 1 569 29 is_stmt 1 view .LVU282
 1119 01b4 8D2F      		mov r24,r29
 1120 01b6 0E94 0000 		call unregister_code
 1121               	.LVL108:
 1122 01ba 00C0      		rjmp .L46
 1123               	.L54:
 391:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1124               		.loc 1 391 13 view .LVU283
 391:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1125               		.loc 1 391 33 is_stmt 0 view .LVU284
 1126 01bc 8C2F      		mov r24,r28
 1127 01be 8695      		lsr r24
 1128 01c0 8695      		lsr r24
 1129 01c2 8370      		andi r24,lo8(3)
 1130 01c4 01F0      		breq .L83
 1131 01c6 8130      		cpi r24,lo8(1)
 1132 01c8 01F0      		breq .+2
 1133 01ca 00C0      		rjmp .L46
 400:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1134               		.loc 1 400 21 is_stmt 1 view .LVU285
 401:tmk_core/common/action.c ****                     } else {
 1135               		.loc 1 401 25 is_stmt 0 view .LVU286
 1136 01cc 8D2F      		mov r24,r29
 1137 01ce 9C2F      		mov r25,r28
 1138 01d0 9370      		andi r25,lo8(3)
 400:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1139               		.loc 1 400 24 view .LVU287
 1140 01d2 1111      		cpse r17,__zero_reg__
 1141 01d4 00C0      		rjmp .L156
 403:tmk_core/common/action.c ****                     }
 1142               		.loc 1 403 25 is_stmt 1 view .LVU288
 1143 01d6 90E0      		ldi r25,0
 1144 01d8 80E0      		ldi r24,0
 1145               	.L156:
 1146 01da 0E94 0000 		call host_consumer_send
 1147               	.LVL109:
 1148 01de 00C0      		rjmp .L46
 1149               	.L83:
 393:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1150               		.loc 1 393 21 view .LVU289
 394:tmk_core/common/action.c ****                     } else {
 1151               		.loc 1 394 25 is_stmt 0 view .LVU290
 1152 01e0 8D2F      		mov r24,r29
 1153 01e2 9C2F      		mov r25,r28
 1154 01e4 9370      		andi r25,lo8(3)
 393:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1155               		.loc 1 393 24 view .LVU291
 1156 01e6 1111      		cpse r17,__zero_reg__
 1157 01e8 00C0      		rjmp .L152
 396:tmk_core/common/action.c ****                     }
 1158               		.loc 1 396 25 is_stmt 1 view .LVU292
 1159 01ea 90E0      		ldi r25,0
 1160 01ec 80E0      		ldi r24,0
 1161               	.L152:
 1162 01ee 0E94 0000 		call host_system_send
 1163               	.LVL110:
 1164 01f2 00C0      		rjmp .L46
 1165               	.L53:
 412:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 1166               		.loc 1 412 13 view .LVU293
 413:tmk_core/common/action.c ****             } else {
 1167               		.loc 1 413 17 is_stmt 0 view .LVU294
 1168 01f4 8D2F      		mov r24,r29
 412:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 1169               		.loc 1 412 16 view .LVU295
 1170 01f6 1123      		tst r17
 1171 01f8 01F0      		breq .L87
 413:tmk_core/common/action.c ****             } else {
 1172               		.loc 1 413 17 is_stmt 1 view .LVU296
 1173 01fa 0E94 0000 		call mousekey_on
 1174               	.LVL111:
 1175               	.L88:
 417:tmk_core/common/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 1176               		.loc 1 417 13 view .LVU297
 428:tmk_core/common/action.c ****                     break;
 1177               		.loc 1 428 21 view .LVU298
 1178 01fe 0E94 0000 		call mousekey_send
 1179               	.LVL112:
 429:tmk_core/common/action.c ****             }
 1180               		.loc 1 429 21 view .LVU299
 1181 0202 00C0      		rjmp .L46
 1182               	.L87:
 415:tmk_core/common/action.c ****             }
 1183               		.loc 1 415 17 view .LVU300
 1184 0204 0E94 0000 		call mousekey_off
 1185               	.LVL113:
 1186 0208 00C0      		rjmp .L88
 1187               	.L52:
 435:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1188               		.loc 1 435 13 view .LVU301
 435:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1189               		.loc 1 435 39 is_stmt 0 view .LVU302
 1190 020a 8C2F      		mov r24,r28
 1191 020c 8370      		andi r24,lo8(3)
 435:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1192               		.loc 1 435 16 view .LVU303
 1193 020e 01F0      		breq .+2
 1194 0210 00C0      		rjmp .L89
 437:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1195               		.loc 1 437 17 is_stmt 1 view .LVU304
 437:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1196               		.loc 1 437 20 is_stmt 0 view .LVU305
 1197 0212 1111      		cpse r17,__zero_reg__
 1198 0214 00C0      		rjmp .L46
 1199               	.LBB37:
 438:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1200               		.loc 1 438 21 is_stmt 1 view .LVU306
 1201               	.LVL114:
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1202               		.loc 1 439 21 view .LVU307
 438:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1203               		.loc 1 438 61 is_stmt 0 view .LVU308
 1204 0216 4D2F      		mov r20,r29
 1205 0218 4295      		swap r20
 1206 021a 4695      		lsr r20
 1207 021c 4770      		andi r20,lo8(7)
 438:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1208               		.loc 1 438 35 view .LVU309
 1209 021e 440F      		lsl r20
 1210 0220 440F      		lsl r20
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1211               		.loc 1 439 77 view .LVU310
 1212 0222 0D2F      		mov r16,r29
 1213               	.LVL115:
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1214               		.loc 1 439 77 view .LVU311
 1215 0224 0F70      		andi r16,lo8(15)
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1216               		.loc 1 439 44 view .LVU312
 1217 0226 10E0      		ldi r17,0
 1218               	.LVL116:
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1219               		.loc 1 439 44 view .LVU313
 1220 0228 30E0      		ldi r19,0
 1221 022a 20E0      		ldi r18,0
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1222               		.loc 1 439 35 view .LVU314
 1223 022c 042E      		mov r0,r20
 1224 022e 00C0      		rjmp 2f
 1225               		1:
 1226 0230 000F      		lsl r16
 1227 0232 111F      		rol r17
 1228 0234 221F      		rol r18
 1229 0236 331F      		rol r19
 1230               		2:
 1231 0238 0A94      		dec r0
 1232 023a 02F4      		brpl 1b
 1233               	.LVL117:
 440:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1234               		.loc 1 440 21 is_stmt 1 view .LVU315
 440:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1235               		.loc 1 440 104 is_stmt 0 view .LVU316
 1236 023c 60E0      		ldi r22,0
 1237 023e 70E0      		ldi r23,0
 1238 0240 CB01      		movw r24,r22
 1239 0242 D4FF      		sbrs r29,4
 1240 0244 00C0      		rjmp .L90
 440:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1241               		.loc 1 440 94 discriminator 1 view .LVU317
 1242 0246 6FE0      		ldi r22,lo8(15)
 1243 0248 70E0      		ldi r23,0
 1244 024a 80E0      		ldi r24,0
 1245 024c 90E0      		ldi r25,0
 1246 024e 00C0      		rjmp 2f
 1247               		1:
 1248 0250 660F      		lsl r22
 1249 0252 771F      		rol r23
 1250 0254 881F      		rol r24
 1251 0256 991F      		rol r25
 1252               		2:
 1253 0258 4A95      		dec r20
 1254 025a 02F4      		brpl 1b
 440:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1255               		.loc 1 440 104 discriminator 1 view .LVU318
 1256 025c 6095      		com r22
 1257 025e 7095      		com r23
 1258 0260 8095      		com r24
 1259 0262 9095      		com r25
 1260               	.L90:
 1261               	.LVL118:
 441:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1262               		.loc 1 441 21 is_stmt 1 discriminator 4 view .LVU319
 441:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1263               		.loc 1 441 47 is_stmt 0 discriminator 4 view .LVU320
 1264 0264 C695      		lsr r28
 1265 0266 C695      		lsr r28
 1266               	.LVL119:
 441:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1267               		.loc 1 441 47 discriminator 4 view .LVU321
 1268 0268 C370      		andi r28,lo8(3)
 1269 026a 602B      		or r22,r16
 1270               	.LVL120:
 441:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1271               		.loc 1 441 47 discriminator 4 view .LVU322
 1272 026c 712B      		or r23,r17
 1273 026e 822B      		or r24,r18
 1274 0270 932B      		or r25,r19
 1275 0272 C230      		cpi r28,lo8(2)
 1276 0274 01F0      		breq .L91
 1277 0276 00F4      		brsh .L92
 1278 0278 C130      		cpi r28,lo8(1)
 1279 027a 01F0      		breq .L93
 443:tmk_core/common/action.c ****                             break;
 1280               		.loc 1 443 29 is_stmt 1 view .LVU323
 1281 027c 0E94 0000 		call default_layer_and
 1282               	.LVL121:
 444:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1283               		.loc 1 444 29 view .LVU324
 1284 0280 00C0      		rjmp .L46
 1285               	.L93:
 446:tmk_core/common/action.c ****                             break;
 1286               		.loc 1 446 29 view .LVU325
 1287 0282 0E94 0000 		call default_layer_or
 1288               	.LVL122:
 447:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1289               		.loc 1 447 29 view .LVU326
 1290 0286 00C0      		rjmp .L46
 1291               	.L91:
 449:tmk_core/common/action.c ****                             break;
 1292               		.loc 1 449 29 view .LVU327
 1293 0288 0E94 0000 		call default_layer_xor
 1294               	.LVL123:
 450:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1295               		.loc 1 450 29 view .LVU328
 1296 028c 00C0      		rjmp .L46
 1297               	.L92:
 452:tmk_core/common/action.c ****                             break;
 1298               		.loc 1 452 29 view .LVU329
 1299 028e 0E94 0000 		call default_layer_set
 1300               	.LVL124:
 453:tmk_core/common/action.c ****                     }
 1301               		.loc 1 453 29 view .LVU330
 1302 0292 00C0      		rjmp .L46
 1303               	.LVL125:
 1304               	.L89:
 453:tmk_core/common/action.c ****                     }
 1305               		.loc 1 453 29 is_stmt 0 view .LVU331
 1306               	.LBE37:
 458:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1307               		.loc 1 458 17 is_stmt 1 view .LVU332
 458:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1308               		.loc 1 458 21 is_stmt 0 view .LVU333
 1309 0294 8695      		lsr r24
 1310 0296 1123      		tst r17
 1311 0298 01F0      		breq .L95
 458:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1312               		.loc 1 458 21 discriminator 1 view .LVU334
 1313 029a 8C2F      		mov r24,r28
 1314 029c 8170      		andi r24,lo8(1)
 1315               	.L95:
 458:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1316               		.loc 1 458 20 discriminator 4 view .LVU335
 1317 029e 8823      		tst r24
 1318 02a0 01F4      		brne .+2
 1319 02a2 00C0      		rjmp .L46
 1320               	.LBB38:
 459:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1321               		.loc 1 459 21 is_stmt 1 view .LVU336
 1322               	.LVL126:
 460:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1323               		.loc 1 460 21 view .LVU337
 459:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1324               		.loc 1 459 61 is_stmt 0 view .LVU338
 1325 02a4 4D2F      		mov r20,r29
 1326 02a6 4295      		swap r20
 1327 02a8 4695      		lsr r20
 1328 02aa 4770      		andi r20,lo8(7)
 459:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1329               		.loc 1 459 35 view .LVU339
 1330 02ac 440F      		lsl r20
 1331 02ae 440F      		lsl r20
 460:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1332               		.loc 1 460 77 view .LVU340
 1333 02b0 0D2F      		mov r16,r29
 1334               	.LVL127:
 460:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1335               		.loc 1 460 77 view .LVU341
 1336 02b2 0F70      		andi r16,lo8(15)
 460:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1337               		.loc 1 460 44 view .LVU342
 1338 02b4 10E0      		ldi r17,0
 1339               	.LVL128:
 460:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1340               		.loc 1 460 44 view .LVU343
 1341 02b6 30E0      		ldi r19,0
 1342 02b8 20E0      		ldi r18,0
 460:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1343               		.loc 1 460 35 view .LVU344
 1344 02ba 042E      		mov r0,r20
 1345 02bc 00C0      		rjmp 2f
 1346               		1:
 1347 02be 000F      		lsl r16
 1348 02c0 111F      		rol r17
 1349 02c2 221F      		rol r18
 1350 02c4 331F      		rol r19
 1351               		2:
 1352 02c6 0A94      		dec r0
 1353 02c8 02F4      		brpl 1b
 1354               	.LVL129:
 461:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1355               		.loc 1 461 21 is_stmt 1 view .LVU345
 461:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1356               		.loc 1 461 104 is_stmt 0 view .LVU346
 1357 02ca 60E0      		ldi r22,0
 1358 02cc 70E0      		ldi r23,0
 1359 02ce CB01      		movw r24,r22
 1360 02d0 D4FF      		sbrs r29,4
 1361 02d2 00C0      		rjmp .L96
 461:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1362               		.loc 1 461 94 discriminator 1 view .LVU347
 1363 02d4 6FE0      		ldi r22,lo8(15)
 1364 02d6 70E0      		ldi r23,0
 1365 02d8 80E0      		ldi r24,0
 1366 02da 90E0      		ldi r25,0
 1367 02dc 00C0      		rjmp 2f
 1368               		1:
 1369 02de 660F      		lsl r22
 1370 02e0 771F      		rol r23
 1371 02e2 881F      		rol r24
 1372 02e4 991F      		rol r25
 1373               		2:
 1374 02e6 4A95      		dec r20
 1375 02e8 02F4      		brpl 1b
 461:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1376               		.loc 1 461 104 discriminator 1 view .LVU348
 1377 02ea 6095      		com r22
 1378 02ec 7095      		com r23
 1379 02ee 8095      		com r24
 1380 02f0 9095      		com r25
 1381               	.L96:
 1382               	.LVL130:
 462:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1383               		.loc 1 462 21 is_stmt 1 discriminator 4 view .LVU349
 462:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1384               		.loc 1 462 47 is_stmt 0 discriminator 4 view .LVU350
 1385 02f2 C695      		lsr r28
 1386 02f4 C695      		lsr r28
 1387               	.LVL131:
 462:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1388               		.loc 1 462 47 discriminator 4 view .LVU351
 1389 02f6 C370      		andi r28,lo8(3)
 1390 02f8 602B      		or r22,r16
 1391               	.LVL132:
 462:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1392               		.loc 1 462 47 discriminator 4 view .LVU352
 1393 02fa 712B      		or r23,r17
 1394 02fc 822B      		or r24,r18
 1395 02fe 932B      		or r25,r19
 1396 0300 C230      		cpi r28,lo8(2)
 1397 0302 01F0      		breq .L97
 1398 0304 00F4      		brsh .L98
 1399 0306 C130      		cpi r28,lo8(1)
 1400 0308 01F0      		breq .L99
 464:tmk_core/common/action.c ****                             break;
 1401               		.loc 1 464 29 is_stmt 1 view .LVU353
 1402 030a 0E94 0000 		call layer_and
 1403               	.LVL133:
 465:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1404               		.loc 1 465 29 view .LVU354
 1405 030e 00C0      		rjmp .L46
 1406               	.L99:
 467:tmk_core/common/action.c ****                             break;
 1407               		.loc 1 467 29 view .LVU355
 1408 0310 0E94 0000 		call layer_or
 1409               	.LVL134:
 468:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1410               		.loc 1 468 29 view .LVU356
 1411 0314 00C0      		rjmp .L46
 1412               	.L97:
 470:tmk_core/common/action.c ****                             break;
 1413               		.loc 1 470 29 view .LVU357
 1414 0316 0E94 0000 		call layer_xor
 1415               	.LVL135:
 471:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1416               		.loc 1 471 29 view .LVU358
 1417 031a 00C0      		rjmp .L46
 1418               	.L98:
 473:tmk_core/common/action.c ****                             break;
 1419               		.loc 1 473 29 view .LVU359
 1420 031c 0E94 0000 		call layer_state_set
 1421               	.LVL136:
 474:tmk_core/common/action.c ****                     }
 1422               		.loc 1 474 29 view .LVU360
 1423 0320 00C0      		rjmp .L46
 1424               	.LVL137:
 1425               	.L51:
 474:tmk_core/common/action.c ****                     }
 1426               		.loc 1 474 29 is_stmt 0 view .LVU361
 1427               	.LBE38:
 480:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1428               		.loc 1 480 13 is_stmt 1 view .LVU362
 1429 0322 CF70      		andi r28,lo8(15)
 1430               	.LVL138:
 480:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1431               		.loc 1 480 16 is_stmt 0 view .LVU363
 1432 0324 1123      		tst r17
 1433 0326 01F0      		breq .L100
 481:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 1434               		.loc 1 481 17 is_stmt 1 view .LVU364
 1435 0328 8C2F      		mov r24,r28
 1436 032a 0E94 0000 		call layer_on
 1437               	.LVL139:
 482:tmk_core/common/action.c ****             } else {
 1438               		.loc 1 482 17 view .LVU365
 1439 032e 8D2F      		mov r24,r29
 1440 0330 00C0      		rjmp .L154
 1441               	.L100:
 484:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 1442               		.loc 1 484 17 view .LVU366
 1443 0332 8D2F      		mov r24,r29
 1444 0334 0E94 0000 		call unregister_mods
 1445               	.LVL140:
 485:tmk_core/common/action.c ****             }
 1446               		.loc 1 485 17 view .LVU367
 1447 0338 8C2F      		mov r24,r28
 1448               	.LVL141:
 1449               	.L151:
 572:tmk_core/common/action.c ****                         }
 1450               		.loc 1 572 29 is_stmt 0 view .LVU368
 1451 033a 0E94 0000 		call layer_off
 1452               	.LVL142:
 1453 033e 00C0      		rjmp .L46
 1454               	.L50:
 491:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1455               		.loc 1 491 13 is_stmt 1 view .LVU369
 1456 0340 D23F      		cpi r29,lo8(-14)
 1457 0342 01F0      		breq .L101
 1458 0344 00F4      		brsh .L102
 1459 0346 D03F      		cpi r29,lo8(-16)
 1460 0348 01F0      		breq .L103
 1461 034a D13F      		cpi r29,lo8(-15)
 1462 034c 01F0      		breq .L104
 1463               	.L105:
 553:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1464               		.loc 1 553 21 view .LVU370
 553:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1465               		.loc 1 553 24 is_stmt 0 view .LVU371
 1466 034e 1123      		tst r17
 1467 0350 01F4      		brne .+2
 1468 0352 00C0      		rjmp .L114
 554:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1469               		.loc 1 554 25 is_stmt 1 view .LVU372
 554:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1470               		.loc 1 554 28 is_stmt 0 view .LVU373
 1471 0354 0111      		cpse r16,__zero_reg__
 1472 0356 00C0      		rjmp .L155
 558:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 1473               		.loc 1 558 76 is_stmt 1 view .LVU374
 559:tmk_core/common/action.c ****                         }
 1474               		.loc 1 559 29 view .LVU375
 1475 0358 8C2F      		mov r24,r28
 1476 035a 8F71      		andi r24,lo8(31)
 1477 035c 00C0      		rjmp .L153
 1478               	.L102:
 1479 035e D33F      		cpi r29,lo8(-13)
 1480 0360 01F0      		breq .L106
 1481 0362 D43F      		cpi r29,lo8(-12)
 1482 0364 01F4      		brne .L105
 539:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1483               		.loc 1 539 21 view .LVU376
 539:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1484               		.loc 1 539 24 is_stmt 0 view .LVU377
 1485 0366 1123      		tst r17
 1486 0368 01F0      		breq .L113
 540:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1487               		.loc 1 540 25 is_stmt 1 view .LVU378
 540:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1488               		.loc 1 540 50 is_stmt 0 view .LVU379
 1489 036a CF71      		andi r28,lo8(31)
 1490               	.LVL143:
 540:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1491               		.loc 1 540 25 view .LVU380
 1492 036c 8C2F      		mov r24,r28
 1493 036e 0E94 0000 		call layer_on
 1494               	.LVL144:
 541:tmk_core/common/action.c ****                     } else {
 1495               		.loc 1 541 25 is_stmt 1 view .LVU381
 1496 0372 63E0      		ldi r22,lo8(3)
 1497 0374 8C2F      		mov r24,r28
 1498 0376 0E94 0000 		call set_oneshot_layer
 1499               	.LVL145:
 1500 037a 00C0      		rjmp .L46
 1501               	.LVL146:
 1502               	.L103:
 494:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1503               		.loc 1 494 21 view .LVU382
 494:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1504               		.loc 1 494 24 is_stmt 0 view .LVU383
 1505 037c 1123      		tst r17
 1506 037e 01F0      		breq .L108
 495:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1507               		.loc 1 495 25 is_stmt 1 view .LVU384
 495:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1508               		.loc 1 495 28 is_stmt 0 view .LVU385
 1509 0380 0530      		cpi r16,lo8(5)
 1510 0382 00F0      		brlo .+2
 1511 0384 00C0      		rjmp .L46
 1512               	.L109:
 496:tmk_core/common/action.c ****                         }
 1513               		.loc 1 496 29 is_stmt 1 view .LVU386
 1514 0386 8C2F      		mov r24,r28
 1515 0388 8F71      		andi r24,lo8(31)
 1516 038a 0E94 0000 		call layer_invert
 1517               	.LVL147:
 1518 038e 00C0      		rjmp .L46
 1519               	.L108:
 499:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1520               		.loc 1 499 25 view .LVU387
 499:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1521               		.loc 1 499 28 is_stmt 0 view .LVU388
 1522 0390 0630      		cpi r16,lo8(6)
 1523 0392 00F0      		brlo .+2
 1524 0394 00C0      		rjmp .L46
 1525 0396 00C0      		rjmp .L109
 1526               	.L104:
 505:tmk_core/common/action.c ****                     break;
 1527               		.loc 1 505 21 is_stmt 1 view .LVU389
 1528 0398 8C2F      		mov r24,r28
 1529 039a 8F71      		andi r24,lo8(31)
 505:tmk_core/common/action.c ****                     break;
 1530               		.loc 1 505 68 is_stmt 0 view .LVU390
 1531 039c 1123      		tst r17
 1532 039e 01F0      		breq .L151
 1533               	.L153:
 559:tmk_core/common/action.c ****                         }
 1534               		.loc 1 559 29 view .LVU391
 1535 03a0 0E94 0000 		call layer_on
 1536               	.LVL148:
 1537 03a4 00C0      		rjmp .L46
 1538               	.L101:
 508:tmk_core/common/action.c ****                     break;
 1539               		.loc 1 508 21 is_stmt 1 view .LVU392
 1540 03a6 8C2F      		mov r24,r28
 1541 03a8 8F71      		andi r24,lo8(31)
 508:tmk_core/common/action.c ****                     break;
 1542               		.loc 1 508 69 is_stmt 0 view .LVU393
 1543 03aa 1123      		tst r17
 1544 03ac 01F0      		breq .L153
 1545 03ae 00C0      		rjmp .L151
 1546               	.L106:
 511:tmk_core/common/action.c ****                     break;
 1547               		.loc 1 511 21 is_stmt 1 view .LVU394
 511:tmk_core/common/action.c ****                     break;
 1548               		.loc 1 511 70 is_stmt 0 view .LVU395
 1549 03b0 1123      		tst r17
 1550 03b2 01F0      		breq .L112
 511:tmk_core/common/action.c ****                     break;
 1551               		.loc 1 511 37 discriminator 1 view .LVU396
 1552 03b4 8C2F      		mov r24,r28
 1553 03b6 8F71      		andi r24,lo8(31)
 1554 03b8 0E94 0000 		call layer_move
 1555               	.LVL149:
 1556 03bc 00C0      		rjmp .L46
 1557               	.L112:
 511:tmk_core/common/action.c ****                     break;
 1558               		.loc 1 511 72 discriminator 2 view .LVU397
 1559 03be 0E94 0000 		call layer_clear
 1560               	.LVL150:
 1561 03c2 00C0      		rjmp .L46
 1562               	.L113:
 543:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1563               		.loc 1 543 25 is_stmt 1 view .LVU398
 1564 03c4 81E0      		ldi r24,lo8(1)
 1565 03c6 0E94 0000 		call clear_oneshot_layer_state
 1566               	.LVL151:
 544:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1567               		.loc 1 544 25 view .LVU399
 544:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1568               		.loc 1 544 28 is_stmt 0 view .LVU400
 1569 03ca 0230      		cpi r16,lo8(2)
 1570 03cc 00F4      		brsh .+2
 1571 03ce 00C0      		rjmp .L46
 545:tmk_core/common/action.c ****                         }
 1572               		.loc 1 545 29 is_stmt 1 view .LVU401
 1573 03d0 82E0      		ldi r24,lo8(2)
 1574 03d2 0E94 0000 		call clear_oneshot_layer_state
 1575               	.LVL152:
 1576 03d6 00C0      		rjmp .L46
 1577               	.L114:
 562:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1578               		.loc 1 562 25 view .LVU402
 562:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1579               		.loc 1 562 28 is_stmt 0 view .LVU403
 1580 03d8 0023      		tst r16
 1581 03da 01F0      		breq .L116
 563:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1582               		.loc 1 563 77 is_stmt 1 view .LVU404
 564:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1583               		.loc 1 564 29 view .LVU405
 564:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1584               		.loc 1 564 32 is_stmt 0 view .LVU406
 1585 03dc D933      		cpi r29,lo8(57)
 1586 03de 01F0      		breq .+2
 1587 03e0 00C0      		rjmp .L118
 565:tmk_core/common/action.c ****                             } else {
 1588               		.loc 1 565 33 is_stmt 1 view .LVU407
 1589               	.LVL153:
 1590               	.LBB39:
 1591               	.LBI34:
 166:e:\game\msys2\mingw64\avr\include\util\delay.h **** {
 1592               		.loc 3 166 1 view .LVU408
 1593               	.LBB36:
 168:e:\game\msys2\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1594               		.loc 3 168 2 view .LVU409
 172:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1595               		.loc 3 172 2 view .LVU410
 173:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1596               		.loc 3 173 2 view .LVU411
 174:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 1597               		.loc 3 174 2 view .LVU412
 184:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	#endif
 1598               		.loc 3 184 3 view .LVU413
 1599               		.loc 3 187 2 view .LVU414
 1600 03e2 8FEF      		ldi r24,lo8(255999)
 1601 03e4 97EE      		ldi r25,hi8(255999)
 1602 03e6 E3E0      		ldi r30,hlo8(255999)
 1603 03e8 8150      	1:	subi r24,1
 1604 03ea 9040      		sbci r25,0
 1605 03ec E040      		sbci r30,0
 1606 03ee 01F4      		brne 1b
 1607 03f0 00C0      		rjmp .L158
 1608               	.LVL154:
 1609               	.L116:
 1610               		.loc 3 187 2 is_stmt 0 view .LVU415
 1611               	.LBE36:
 1612               	.LBE39:
 571:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 1613               		.loc 1 571 79 is_stmt 1 view .LVU416
 572:tmk_core/common/action.c ****                         }
 1614               		.loc 1 572 29 view .LVU417
 1615 03f2 8C2F      		mov r24,r28
 1616 03f4 8F71      		andi r24,lo8(31)
 1617 03f6 00C0      		rjmp .L151
 1618               	.L49:
 583:tmk_core/common/action.c ****             break;
 1619               		.loc 1 583 13 view .LVU418
 583:tmk_core/common/action.c ****             break;
 1620               		.loc 1 583 83 is_stmt 0 view .LVU419
 1621 03f8 4C2F      		mov r20,r28
 1622 03fa 4F70      		andi r20,lo8(15)
 583:tmk_core/common/action.c ****             break;
 1623               		.loc 1 583 13 view .LVU420
 1624 03fc 6D2F      		mov r22,r29
 1625 03fe C601      		movw r24,r12
 1626 0400 0E94 0000 		call action_get_macro
 1627               	.LVL155:
 1628 0404 0E94 0000 		call action_macro_play
 1629               	.LVL156:
 584:tmk_core/common/action.c **** #endif
 1630               		.loc 1 584 13 is_stmt 1 view .LVU421
 1631 0408 00C0      		rjmp .L46
 1632               	.L47:
 661:tmk_core/common/action.c ****             break;
 1633               		.loc 1 661 13 view .LVU422
 661:tmk_core/common/action.c ****             break;
 1634               		.loc 1 661 64 is_stmt 0 view .LVU423
 1635 040a 4C2F      		mov r20,r28
 1636 040c 4F70      		andi r20,lo8(15)
 661:tmk_core/common/action.c ****             break;
 1637               		.loc 1 661 13 view .LVU424
 1638 040e 6D2F      		mov r22,r29
 1639 0410 C601      		movw r24,r12
 1640 0412 0E94 0000 		call action_function
 1641               	.LVL157:
 662:tmk_core/common/action.c **** #endif
 1642               		.loc 1 662 13 is_stmt 1 view .LVU425
 1643 0416 00C0      		rjmp .L46
 1644               	.LVL158:
 1645               	.L43:
 1646               	/* epilogue start */
 730:tmk_core/common/action.c **** 
 1647               		.loc 1 730 1 is_stmt 0 view .LVU426
 1648 0418 DF91      		pop r29
 1649               	.LVL159:
 730:tmk_core/common/action.c **** 
 1650               		.loc 1 730 1 view .LVU427
 1651 041a CF91      		pop r28
 730:tmk_core/common/action.c **** 
 1652               		.loc 1 730 1 view .LVU428
 1653 041c 1F91      		pop r17
 1654 041e 0F91      		pop r16
 1655 0420 FF90      		pop r15
 1656 0422 EF90      		pop r14
 1657               	.LVL160:
 730:tmk_core/common/action.c **** 
 1658               		.loc 1 730 1 view .LVU429
 1659 0424 DF90      		pop r13
 1660 0426 CF90      		pop r12
 1661               	.LVL161:
 730:tmk_core/common/action.c **** 
 1662               		.loc 1 730 1 view .LVU430
 1663 0428 BF90      		pop r11
 1664 042a 0895      		ret
 1665               		.cfi_endproc
 1666               	.LFE22:
 1668               		.section	.text.process_record_handler,"ax",@progbits
 1669               	.global	process_record_handler
 1671               	process_record_handler:
 1672               	.LVL162:
 1673               	.LFB21:
 208:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1674               		.loc 1 208 50 is_stmt 1 view -0
 1675               		.cfi_startproc
 208:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1676               		.loc 1 208 50 is_stmt 0 view .LVU432
 1677 0000 0F93      		push r16
 1678               	.LCFI22:
 1679               		.cfi_def_cfa_offset 3
 1680               		.cfi_offset 16, -2
 1681 0002 1F93      		push r17
 1682               	.LCFI23:
 1683               		.cfi_def_cfa_offset 4
 1684               		.cfi_offset 17, -3
 1685 0004 CF93      		push r28
 1686               	.LCFI24:
 1687               		.cfi_def_cfa_offset 5
 1688               		.cfi_offset 28, -4
 1689 0006 DF93      		push r29
 1690               	.LCFI25:
 1691               		.cfi_def_cfa_offset 6
 1692               		.cfi_offset 29, -5
 1693               	/* prologue: function */
 1694               	/* frame size = 0 */
 1695               	/* stack size = 4 */
 1696               	.L__stack_usage = 4
 1697 0008 EC01      		movw r28,r24
 209:tmk_core/common/action.c ****     dprint("ACTION: ");
 1698               		.loc 1 209 5 is_stmt 1 view .LVU433
 209:tmk_core/common/action.c ****     dprint("ACTION: ");
 1699               		.loc 1 209 23 is_stmt 0 view .LVU434
 1700 000a 6881      		ld r22,Y
 1701 000c 7981      		ldd r23,Y+1
 1702 000e 8A81      		ldd r24,Y+2
 1703               	.LVL163:
 209:tmk_core/common/action.c ****     dprint("ACTION: ");
 1704               		.loc 1 209 23 view .LVU435
 1705 0010 0E94 0000 		call store_or_get_action
 1706               	.LVL164:
 1707 0014 8C01      		movw r16,r24
 1708               	.LVL165:
 210:tmk_core/common/action.c ****     debug_action(action);
 1709               		.loc 1 210 23 is_stmt 1 view .LVU436
 211:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 1710               		.loc 1 211 5 view .LVU437
 213:tmk_core/common/action.c ****     layer_debug();
 1711               		.loc 1 213 29 view .LVU438
 214:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 1712               		.loc 1 214 5 view .LVU439
 1713 0016 0E94 0000 		call layer_debug
 1714               	.LVL166:
 215:tmk_core/common/action.c ****     default_layer_debug();
 1715               		.loc 1 215 37 view .LVU440
 216:tmk_core/common/action.c **** #endif
 1716               		.loc 1 216 5 view .LVU441
 1717 001a 0E94 0000 		call default_layer_debug
 1718               	.LVL167:
 218:tmk_core/common/action.c **** 
 1719               		.loc 1 218 15 view .LVU442
 220:tmk_core/common/action.c **** }
 1720               		.loc 1 220 5 view .LVU443
 220:tmk_core/common/action.c **** }
 1721               		.loc 1 220 5 is_stmt 0 view .LVU444
 1722 001e B801      		movw r22,r16
 1723 0020 CE01      		movw r24,r28
 1724               	/* epilogue start */
 221:tmk_core/common/action.c **** 
 1725               		.loc 1 221 1 view .LVU445
 1726 0022 DF91      		pop r29
 1727 0024 CF91      		pop r28
 1728               	.LVL168:
 221:tmk_core/common/action.c **** 
 1729               		.loc 1 221 1 view .LVU446
 1730 0026 1F91      		pop r17
 1731 0028 0F91      		pop r16
 1732               	.LVL169:
 220:tmk_core/common/action.c **** }
 1733               		.loc 1 220 5 view .LVU447
 1734 002a 0C94 0000 		jmp process_action
 1735               	.LVL170:
 220:tmk_core/common/action.c **** }
 1736               		.loc 1 220 5 view .LVU448
 1737               		.cfi_endproc
 1738               	.LFE21:
 1740               		.section	.text.process_record,"ax",@progbits
 1741               	.global	process_record
 1743               	process_record:
 1744               	.LVL171:
 1745               	.LFB20:
 190:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1746               		.loc 1 190 42 is_stmt 1 view -0
 1747               		.cfi_startproc
 190:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1748               		.loc 1 190 42 is_stmt 0 view .LVU450
 1749 0000 CF93      		push r28
 1750               	.LCFI26:
 1751               		.cfi_def_cfa_offset 3
 1752               		.cfi_offset 28, -2
 1753 0002 DF93      		push r29
 1754               	.LCFI27:
 1755               		.cfi_def_cfa_offset 4
 1756               		.cfi_offset 29, -3
 1757               	/* prologue: function */
 1758               	/* frame size = 0 */
 1759               	/* stack size = 2 */
 1760               	.L__stack_usage = 2
 1761 0004 EC01      		movw r28,r24
 191:tmk_core/common/action.c ****         return;
 1762               		.loc 1 191 5 is_stmt 1 view .LVU451
 1763               	.LBB42:
 1764               	.LBI42:
 1765               		.file 4 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #pragma once
  19:tmk_core/common/keyboard.h **** 
  20:tmk_core/common/keyboard.h **** #include <stdbool.h>
  21:tmk_core/common/keyboard.h **** #include <stdint.h>
  22:tmk_core/common/keyboard.h **** 
  23:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  24:tmk_core/common/keyboard.h **** extern "C" {
  25:tmk_core/common/keyboard.h **** #endif
  26:tmk_core/common/keyboard.h **** 
  27:tmk_core/common/keyboard.h **** /* key matrix position */
  28:tmk_core/common/keyboard.h **** typedef struct {
  29:tmk_core/common/keyboard.h ****     uint8_t col;
  30:tmk_core/common/keyboard.h ****     uint8_t row;
  31:tmk_core/common/keyboard.h **** } keypos_t;
  32:tmk_core/common/keyboard.h **** 
  33:tmk_core/common/keyboard.h **** /* key event */
  34:tmk_core/common/keyboard.h **** typedef struct {
  35:tmk_core/common/keyboard.h ****     keypos_t key;
  36:tmk_core/common/keyboard.h ****     bool     pressed;
  37:tmk_core/common/keyboard.h ****     uint16_t time;
  38:tmk_core/common/keyboard.h **** } keyevent_t;
  39:tmk_core/common/keyboard.h **** 
  40:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  41:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  42:tmk_core/common/keyboard.h **** 
  43:tmk_core/common/keyboard.h **** /* Rules for No Event:
  44:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  45:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  46:tmk_core/common/keyboard.h ****  */
  47:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1766               		.loc 4 47 20 view .LVU452
 1767               	.LBB43:
 1768               		.loc 4 47 51 view .LVU453
 1769               		.loc 4 47 74 is_stmt 0 view .LVU454
 1770 0006 8B81      		ldd r24,Y+3
 1771 0008 9C81      		ldd r25,Y+4
 1772               	.LVL172:
 1773               		.loc 4 47 74 view .LVU455
 1774 000a 892B      		or r24,r25
 1775 000c 01F0      		breq .L160
 1776 000e 8881      		ld r24,Y
 1777 0010 9981      		ldd r25,Y+1
 1778 0012 8923      		and r24,r25
 1779 0014 8F3F      		cpi r24,lo8(-1)
 1780 0016 01F4      		brne .L176
 1781               	.L160:
 1782               	/* epilogue start */
 1783               	.LBE43:
 1784               	.LBE42:
 206:tmk_core/common/action.c **** 
 1785               		.loc 1 206 1 view .LVU456
 1786 0018 DF91      		pop r29
 1787 001a CF91      		pop r28
 1788               	.LVL173:
 206:tmk_core/common/action.c **** 
 1789               		.loc 1 206 1 view .LVU457
 1790 001c 0895      		ret
 1791               	.LVL174:
 1792               	.L165:
 204:tmk_core/common/action.c ****     post_process_record_quantum(record);
 1793               		.loc 1 204 5 is_stmt 1 view .LVU458
 1794 001e CE01      		movw r24,r28
 1795 0020 0E94 0000 		call process_record_handler
 1796               	.LVL175:
 205:tmk_core/common/action.c **** }
 1797               		.loc 1 205 5 view .LVU459
 1798 0024 CE01      		movw r24,r28
 1799               	/* epilogue start */
 206:tmk_core/common/action.c **** 
 1800               		.loc 1 206 1 is_stmt 0 view .LVU460
 1801 0026 DF91      		pop r29
 1802 0028 CF91      		pop r28
 1803               	.LVL176:
 205:tmk_core/common/action.c **** }
 1804               		.loc 1 205 5 view .LVU461
 1805 002a 0C94 0000 		jmp post_process_record_quantum
 1806               	.LVL177:
 1807               	.L176:
 195:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1808               		.loc 1 195 5 is_stmt 1 view .LVU462
 195:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1809               		.loc 1 195 10 is_stmt 0 view .LVU463
 1810 002e CE01      		movw r24,r28
 1811 0030 0E94 0000 		call process_record_quantum
 1812               	.LVL178:
 195:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 1813               		.loc 1 195 8 view .LVU464
 1814 0034 8111      		cpse r24,__zero_reg__
 1815 0036 00C0      		rjmp .L165
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1816               		.loc 1 197 9 is_stmt 1 view .LVU465
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1817               		.loc 1 197 13 is_stmt 0 view .LVU466
 1818 0038 0E94 0000 		call is_oneshot_layer_active
 1819               	.LVL179:
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1820               		.loc 1 197 12 view .LVU467
 1821 003c 8823      		tst r24
 1822 003e 01F0      		breq .L160
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1823               		.loc 1 197 39 discriminator 1 view .LVU468
 1824 0040 8A81      		ldd r24,Y+2
 1825 0042 8823      		tst r24
 1826 0044 01F0      		breq .L160
 198:tmk_core/common/action.c ****         }
 1827               		.loc 1 198 13 is_stmt 1 view .LVU469
 1828 0046 82E0      		ldi r24,lo8(2)
 1829               	/* epilogue start */
 206:tmk_core/common/action.c **** 
 1830               		.loc 1 206 1 is_stmt 0 view .LVU470
 1831 0048 DF91      		pop r29
 1832 004a CF91      		pop r28
 1833               	.LVL180:
 198:tmk_core/common/action.c ****         }
 1834               		.loc 1 198 13 view .LVU471
 1835 004c 0C94 0000 		jmp clear_oneshot_layer_state
 1836               	.LVL181:
 1837               		.cfi_endproc
 1838               	.LFE20:
 1840               		.section	.text.process_record_nocache,"ax",@progbits
 1841               	.global	process_record_nocache
 1843               	process_record_nocache:
 1844               	.LVL182:
 1845               	.LFB16:
 148:tmk_core/common/action.c ****     disable_action_cache = true;
 1846               		.loc 1 148 50 is_stmt 1 view -0
 1847               		.cfi_startproc
 1848               	/* prologue: function */
 1849               	/* frame size = 0 */
 1850               	/* stack size = 0 */
 1851               	.L__stack_usage = 0
 149:tmk_core/common/action.c ****     process_record(record);
 1852               		.loc 1 149 5 view .LVU473
 149:tmk_core/common/action.c ****     process_record(record);
 1853               		.loc 1 149 26 is_stmt 0 view .LVU474
 1854 0000 21E0      		ldi r18,lo8(1)
 1855 0002 2093 0000 		sts disable_action_cache,r18
 150:tmk_core/common/action.c ****     disable_action_cache = false;
 1856               		.loc 1 150 5 is_stmt 1 view .LVU475
 1857 0006 0E94 0000 		call process_record
 1858               	.LVL183:
 151:tmk_core/common/action.c **** }
 1859               		.loc 1 151 5 view .LVU476
 151:tmk_core/common/action.c **** }
 1860               		.loc 1 151 26 is_stmt 0 view .LVU477
 1861 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 1862               	/* epilogue start */
 152:tmk_core/common/action.c **** #else
 1863               		.loc 1 152 1 view .LVU478
 1864 000e 0895      		ret
 1865               		.cfi_endproc
 1866               	.LFE16:
 1868               		.section	.text.register_weak_mods,"ax",@progbits
 1869               	.global	register_weak_mods
 1871               	register_weak_mods:
 1872               	.LVL184:
 1873               	.LFB29:
 925:tmk_core/common/action.c **** 
 926:tmk_core/common/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 927:tmk_core/common/action.c ****  *
 928:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 929:tmk_core/common/action.c ****  */
 930:tmk_core/common/action.c **** void register_weak_mods(uint8_t mods) {
 1874               		.loc 1 930 39 is_stmt 1 view -0
 1875               		.cfi_startproc
 1876               	/* prologue: function */
 1877               	/* frame size = 0 */
 1878               	/* stack size = 0 */
 1879               	.L__stack_usage = 0
 931:tmk_core/common/action.c ****     if (mods) {
 1880               		.loc 1 931 5 view .LVU480
 1881               		.loc 1 931 8 is_stmt 0 view .LVU481
 1882 0000 8823      		tst r24
 1883 0002 01F0      		breq .L179
 932:tmk_core/common/action.c ****         add_weak_mods(mods);
 1884               		.loc 1 932 9 is_stmt 1 view .LVU482
 1885 0004 0E94 0000 		call add_weak_mods
 1886               	.LVL185:
 933:tmk_core/common/action.c ****         send_keyboard_report();
 1887               		.loc 1 933 9 view .LVU483
 1888 0008 0C94 0000 		jmp send_keyboard_report
 1889               	.LVL186:
 1890               	.L179:
 1891               	/* epilogue start */
 934:tmk_core/common/action.c ****     }
 935:tmk_core/common/action.c **** }
 1892               		.loc 1 935 1 is_stmt 0 view .LVU484
 1893 000c 0895      		ret
 1894               		.cfi_endproc
 1895               	.LFE29:
 1897               		.section	.text.unregister_weak_mods,"ax",@progbits
 1898               	.global	unregister_weak_mods
 1900               	unregister_weak_mods:
 1901               	.LVL187:
 1902               	.LFB30:
 936:tmk_core/common/action.c **** 
 937:tmk_core/common/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 938:tmk_core/common/action.c ****  *
 939:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 940:tmk_core/common/action.c ****  */
 941:tmk_core/common/action.c **** void unregister_weak_mods(uint8_t mods) {
 1903               		.loc 1 941 41 is_stmt 1 view -0
 1904               		.cfi_startproc
 1905               	/* prologue: function */
 1906               	/* frame size = 0 */
 1907               	/* stack size = 0 */
 1908               	.L__stack_usage = 0
 942:tmk_core/common/action.c ****     if (mods) {
 1909               		.loc 1 942 5 view .LVU486
 1910               		.loc 1 942 8 is_stmt 0 view .LVU487
 1911 0000 8823      		tst r24
 1912 0002 01F0      		breq .L181
 943:tmk_core/common/action.c ****         del_weak_mods(mods);
 1913               		.loc 1 943 9 is_stmt 1 view .LVU488
 1914 0004 0E94 0000 		call del_weak_mods
 1915               	.LVL188:
 944:tmk_core/common/action.c ****         send_keyboard_report();
 1916               		.loc 1 944 9 view .LVU489
 1917 0008 0C94 0000 		jmp send_keyboard_report
 1918               	.LVL189:
 1919               	.L181:
 1920               	/* epilogue start */
 945:tmk_core/common/action.c ****     }
 946:tmk_core/common/action.c **** }
 1921               		.loc 1 946 1 is_stmt 0 view .LVU490
 1922 000c 0895      		ret
 1923               		.cfi_endproc
 1924               	.LFE30:
 1926               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 1927               	.global	clear_keyboard_but_mods_and_keys
 1929               	clear_keyboard_but_mods_and_keys:
 1930               	.LFB33:
 947:tmk_core/common/action.c **** 
 948:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 949:tmk_core/common/action.c ****  *
 950:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 951:tmk_core/common/action.c ****  */
 952:tmk_core/common/action.c **** void clear_keyboard(void) {
 953:tmk_core/common/action.c ****     clear_mods();
 954:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 955:tmk_core/common/action.c **** }
 956:tmk_core/common/action.c **** 
 957:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 958:tmk_core/common/action.c ****  *
 959:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 960:tmk_core/common/action.c ****  */
 961:tmk_core/common/action.c **** void clear_keyboard_but_mods(void) {
 962:tmk_core/common/action.c ****     clear_keys();
 963:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 964:tmk_core/common/action.c **** }
 965:tmk_core/common/action.c **** 
 966:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 967:tmk_core/common/action.c ****  *
 968:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 969:tmk_core/common/action.c ****  */
 970:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys() {
 1931               		.loc 1 970 41 is_stmt 1 view -0
 1932               		.cfi_startproc
 1933               	/* prologue: function */
 1934               	/* frame size = 0 */
 1935               	/* stack size = 0 */
 1936               	.L__stack_usage = 0
 971:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 972:tmk_core/common/action.c ****     host_system_send(0);
 1937               		.loc 1 972 5 view .LVU492
 1938 0000 90E0      		ldi r25,0
 1939 0002 80E0      		ldi r24,0
 1940 0004 0E94 0000 		call host_system_send
 1941               	.LVL190:
 973:tmk_core/common/action.c ****     host_consumer_send(0);
 1942               		.loc 1 973 5 view .LVU493
 1943 0008 90E0      		ldi r25,0
 1944 000a 80E0      		ldi r24,0
 1945 000c 0E94 0000 		call host_consumer_send
 1946               	.LVL191:
 974:tmk_core/common/action.c **** #endif
 975:tmk_core/common/action.c ****     clear_weak_mods();
 1947               		.loc 1 975 5 view .LVU494
 1948 0010 0E94 0000 		call clear_weak_mods
 1949               	.LVL192:
 976:tmk_core/common/action.c ****     clear_macro_mods();
 1950               		.loc 1 976 5 view .LVU495
 1951 0014 0E94 0000 		call clear_macro_mods
 1952               	.LVL193:
 977:tmk_core/common/action.c ****     send_keyboard_report();
 1953               		.loc 1 977 5 view .LVU496
 1954 0018 0E94 0000 		call send_keyboard_report
 1955               	.LVL194:
 978:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 979:tmk_core/common/action.c ****     mousekey_clear();
 1956               		.loc 1 979 5 view .LVU497
 1957 001c 0E94 0000 		call mousekey_clear
 1958               	.LVL195:
 980:tmk_core/common/action.c ****     mousekey_send();
 1959               		.loc 1 980 5 view .LVU498
 1960 0020 0C94 0000 		jmp mousekey_send
 1961               	.LVL196:
 1962               		.cfi_endproc
 1963               	.LFE33:
 1965               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 1966               	.global	clear_keyboard_but_mods
 1968               	clear_keyboard_but_mods:
 1969               	.LFB32:
 961:tmk_core/common/action.c ****     clear_keys();
 1970               		.loc 1 961 36 view -0
 1971               		.cfi_startproc
 1972               	/* prologue: function */
 1973               	/* frame size = 0 */
 1974               	/* stack size = 0 */
 1975               	.L__stack_usage = 0
 962:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 1976               		.loc 1 962 5 view .LVU500
 1977 0000 0E94 0000 		call clear_keys
 1978               	.LVL197:
 963:tmk_core/common/action.c **** }
 1979               		.loc 1 963 5 view .LVU501
 1980 0004 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 1981               	.LVL198:
 1982               		.cfi_endproc
 1983               	.LFE32:
 1985               		.section	.text.clear_keyboard,"ax",@progbits
 1986               	.global	clear_keyboard
 1988               	clear_keyboard:
 1989               	.LFB31:
 952:tmk_core/common/action.c ****     clear_mods();
 1990               		.loc 1 952 27 view -0
 1991               		.cfi_startproc
 1992               	/* prologue: function */
 1993               	/* frame size = 0 */
 1994               	/* stack size = 0 */
 1995               	.L__stack_usage = 0
 953:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 1996               		.loc 1 953 5 view .LVU503
 1997 0000 0E94 0000 		call clear_mods
 1998               	.LVL199:
 954:tmk_core/common/action.c **** }
 1999               		.loc 1 954 5 view .LVU504
 2000 0004 0C94 0000 		jmp clear_keyboard_but_mods
 2001               	.LVL200:
 2002               		.cfi_endproc
 2003               	.LFE31:
 2005               		.section	.text.is_tap_action,"ax",@progbits
 2006               	.global	is_tap_action
 2008               	is_tap_action:
 2009               	.LVL201:
 2010               	.LFB35:
 981:tmk_core/common/action.c **** #endif
 982:tmk_core/common/action.c **** }
 983:tmk_core/common/action.c **** 
 984:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 985:tmk_core/common/action.c ****  *
 986:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 987:tmk_core/common/action.c ****  */
 988:tmk_core/common/action.c **** bool is_tap_key(keypos_t key) {
 989:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 990:tmk_core/common/action.c ****     return is_tap_action(action);
 991:tmk_core/common/action.c **** }
 992:tmk_core/common/action.c **** 
 993:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 994:tmk_core/common/action.c ****  *
 995:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 996:tmk_core/common/action.c ****  */
 997:tmk_core/common/action.c **** bool is_tap_action(action_t action) {
 2011               		.loc 1 997 37 view -0
 2012               		.cfi_startproc
 2013               	/* prologue: function */
 2014               	/* frame size = 0 */
 2015               	/* stack size = 0 */
 2016               	.L__stack_usage = 0
 998:tmk_core/common/action.c ****     switch (action.kind.id) {
 2017               		.loc 1 998 5 view .LVU506
 2018               		.loc 1 998 24 is_stmt 0 view .LVU507
 2019 0000 E92F      		mov r30,r25
 2020 0002 E295      		swap r30
 2021 0004 EF70      		andi r30,lo8(15)
 2022               		.loc 1 998 5 view .LVU508
 2023 0006 E250      		subi r30,lo8(-(-2))
 2024 0008 EE30      		cpi r30,lo8(14)
 2025 000a 00F4      		brsh .L195
 2026 000c F0E0      		ldi r31,0
 2027 000e E050      		subi r30,lo8(-(gs(.L189)))
 2028 0010 F040      		sbci r31,hi8(-(gs(.L189)))
 2029 0012 0C94 0000 		jmp __tablejump2__
 2030               		.section	.jumptables.gcc.is_tap_action,"a",@progbits
 2031               		.p2align	1
 2032               	.L189:
 2033 0000 0000      		.word gs(.L190)
 2034 0002 0000      		.word gs(.L190)
 2035 0004 0000      		.word gs(.L195)
 2036 0006 0000      		.word gs(.L195)
 2037 0008 0000      		.word gs(.L191)
 2038 000a 0000      		.word gs(.L195)
 2039 000c 0000      		.word gs(.L195)
 2040 000e 0000      		.word gs(.L195)
 2041 0010 0000      		.word gs(.L190)
 2042 0012 0000      		.word gs(.L190)
 2043 0014 0000      		.word gs(.L188)
 2044 0016 0000      		.word gs(.L195)
 2045 0018 0000      		.word gs(.L195)
 2046 001a 0000      		.word gs(.L188)
 2047               		.section	.text.is_tap_action
 2048               	.L190:
 999:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1000:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1001:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1002:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1003:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 2049               		.loc 1 1003 13 is_stmt 1 view .LVU509
 2050 0016 803F      		cpi r24,lo8(-16)
 2051 0018 01F0      		breq .L198
 2052 001a 00F4      		brsh .L192
 2053 001c 883E      		cpi r24,lo8(-24)
 2054 001e 00F4      		brsh .L195
 2055               	.L198:
1004:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
1005:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
1006:tmk_core/common/action.c ****                 case OP_ONESHOT:
1007:tmk_core/common/action.c ****                     return true;
 2056               		.loc 1 1007 28 is_stmt 0 view .LVU510
 2057 0020 81E0      		ldi r24,lo8(1)
 2058               	.LVL202:
 2059               	/* epilogue start */
1008:tmk_core/common/action.c ****             }
1009:tmk_core/common/action.c ****             return false;
1010:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1011:tmk_core/common/action.c ****             switch (action.swap.code) {
1012:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
1013:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
1014:tmk_core/common/action.c ****                     return true;
1015:tmk_core/common/action.c ****             }
1016:tmk_core/common/action.c ****             return false;
1017:tmk_core/common/action.c ****         case ACT_MACRO:
1018:tmk_core/common/action.c ****         case ACT_FUNCTION:
1019:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) {
1020:tmk_core/common/action.c ****                 return true;
1021:tmk_core/common/action.c ****             }
1022:tmk_core/common/action.c ****             return false;
1023:tmk_core/common/action.c ****     }
1024:tmk_core/common/action.c ****     return false;
1025:tmk_core/common/action.c **** }
 2060               		.loc 1 1025 1 view .LVU511
 2061 0022 0895      		ret
 2062               	.LVL203:
 2063               	.L192:
 2064               		.loc 1 1025 1 view .LVU512
 2065 0024 843F      		cpi r24,lo8(-12)
 2066 0026 01F0      		breq .L198
 2067               	.L195:
1009:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2068               		.loc 1 1009 20 view .LVU513
 2069 0028 80E0      		ldi r24,0
 2070               	.LVL204:
1009:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2071               		.loc 1 1009 20 view .LVU514
 2072 002a 0895      		ret
 2073               	.LVL205:
 2074               	.L191:
1011:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 2075               		.loc 1 1011 13 is_stmt 1 view .LVU515
 2076 002c 883E      		cpi r24,lo8(-24)
 2077 002e 00F0      		brlo .L198
 2078 0030 813F      		cpi r24,lo8(-15)
 2079 0032 01F4      		brne .L195
 2080 0034 00C0      		rjmp .L198
 2081               	.L188:
1019:tmk_core/common/action.c ****                 return true;
 2082               		.loc 1 1019 13 view .LVU516
1019:tmk_core/common/action.c ****                 return true;
 2083               		.loc 1 1019 16 is_stmt 0 view .LVU517
 2084 0036 93FB      		bst r25,3
 2085 0038 8827      		clr r24
 2086 003a 80F9      		bld r24,0
 2087               	.LVL206:
1019:tmk_core/common/action.c ****                 return true;
 2088               		.loc 1 1019 16 view .LVU518
 2089 003c 0895      		ret
 2090               		.cfi_endproc
 2091               	.LFE35:
 2093               		.section	.text.is_tap_key,"ax",@progbits
 2094               	.global	is_tap_key
 2096               	is_tap_key:
 2097               	.LVL207:
 2098               	.LFB34:
 988:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 2099               		.loc 1 988 31 is_stmt 1 view -0
 2100               		.cfi_startproc
 2101               	/* prologue: function */
 2102               	/* frame size = 0 */
 2103               	/* stack size = 0 */
 2104               	.L__stack_usage = 0
 989:tmk_core/common/action.c ****     return is_tap_action(action);
 2105               		.loc 1 989 5 view .LVU520
 989:tmk_core/common/action.c ****     return is_tap_action(action);
 2106               		.loc 1 989 23 is_stmt 0 view .LVU521
 2107 0000 0E94 0000 		call layer_switch_get_action
 2108               	.LVL208:
 990:tmk_core/common/action.c **** }
 2109               		.loc 1 990 5 is_stmt 1 view .LVU522
 990:tmk_core/common/action.c **** }
 2110               		.loc 1 990 12 is_stmt 0 view .LVU523
 2111 0004 0C94 0000 		jmp is_tap_action
 2112               	.LVL209:
 2113               		.cfi_endproc
 2114               	.LFE34:
 2116               		.section	.text.debug_event,"ax",@progbits
 2117               	.global	debug_event
 2119               	debug_event:
 2120               	.LFB36:
1026:tmk_core/common/action.c **** 
1027:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1028:tmk_core/common/action.c ****  *
1029:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1030:tmk_core/common/action.c ****  */
1031:tmk_core/common/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 2121               		.loc 1 1031 36 is_stmt 1 view -0
 2122               		.cfi_startproc
 2123 0000 CF93      		push r28
 2124               	.LCFI28:
 2125               		.cfi_def_cfa_offset 3
 2126               		.cfi_offset 28, -2
 2127 0002 DF93      		push r29
 2128               	.LCFI29:
 2129               		.cfi_def_cfa_offset 4
 2130               		.cfi_offset 29, -3
 2131 0004 00D0      		rcall .
 2132 0006 00D0      		rcall .
 2133 0008 0F92      		push __tmp_reg__
 2134               	.LCFI30:
 2135               		.cfi_def_cfa_offset 9
 2136 000a CDB7      		in r28,__SP_L__
 2137 000c DEB7      		in r29,__SP_H__
 2138               	.LCFI31:
 2139               		.cfi_def_cfa_register 28
 2140               	/* prologue: function */
 2141               	/* frame size = 5 */
 2142               	/* stack size = 7 */
 2143               	.L__stack_usage = 7
 2144               		.loc 1 1031 138 view .LVU525
 2145               	/* epilogue start */
 2146               		.loc 1 1031 1 is_stmt 0 view .LVU526
 2147 000e 0F90      		pop __tmp_reg__
 2148 0010 0F90      		pop __tmp_reg__
 2149 0012 0F90      		pop __tmp_reg__
 2150 0014 0F90      		pop __tmp_reg__
 2151 0016 0F90      		pop __tmp_reg__
 2152 0018 DF91      		pop r29
 2153 001a CF91      		pop r28
 2154 001c 0895      		ret
 2155               		.cfi_endproc
 2156               	.LFE36:
 2158               		.section	.text.debug_record,"ax",@progbits
 2159               	.global	debug_record
 2161               	debug_record:
 2162               	.LFB37:
1032:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1033:tmk_core/common/action.c ****  *
1034:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1035:tmk_core/common/action.c ****  */
1036:tmk_core/common/action.c **** void debug_record(keyrecord_t record) {
 2163               		.loc 1 1036 39 is_stmt 1 view -0
 2164               		.cfi_startproc
 2165 0000 CF93      		push r28
 2166               	.LCFI32:
 2167               		.cfi_def_cfa_offset 3
 2168               		.cfi_offset 28, -2
 2169 0002 DF93      		push r29
 2170               	.LCFI33:
 2171               		.cfi_def_cfa_offset 4
 2172               		.cfi_offset 29, -3
 2173 0004 00D0      		rcall .
 2174 0006 00D0      		rcall .
 2175 0008 00D0      		rcall .
 2176               	.LCFI34:
 2177               		.cfi_def_cfa_offset 10
 2178 000a CDB7      		in r28,__SP_L__
 2179 000c DEB7      		in r29,__SP_H__
 2180               	.LCFI35:
 2181               		.cfi_def_cfa_register 28
 2182               	/* prologue: function */
 2183               	/* frame size = 6 */
 2184               	/* stack size = 8 */
 2185               	.L__stack_usage = 8
1037:tmk_core/common/action.c ****     debug_event(record.event);
 2186               		.loc 1 1037 5 view .LVU528
1038:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
1039:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 2187               		.loc 1 1039 77 view .LVU529
 2188               	/* epilogue start */
1040:tmk_core/common/action.c **** #endif
1041:tmk_core/common/action.c **** }
 2189               		.loc 1 1041 1 is_stmt 0 view .LVU530
 2190 000e 2696      		adiw r28,6
 2191 0010 0FB6      		in __tmp_reg__,__SREG__
 2192 0012 F894      		cli
 2193 0014 DEBF      		out __SP_H__,r29
 2194 0016 0FBE      		out __SREG__,__tmp_reg__
 2195 0018 CDBF      		out __SP_L__,r28
 2196 001a DF91      		pop r29
 2197 001c CF91      		pop r28
 2198 001e 0895      		ret
 2199               		.cfi_endproc
 2200               	.LFE37:
 2202               		.section	.text.debug_action,"ax",@progbits
 2203               	.global	debug_action
 2205               	debug_action:
 2206               	.LVL210:
 2207               	.LFB38:
1042:tmk_core/common/action.c **** 
1043:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1044:tmk_core/common/action.c ****  *
1045:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1046:tmk_core/common/action.c ****  */
1047:tmk_core/common/action.c **** void debug_action(action_t action) {
 2208               		.loc 1 1047 36 is_stmt 1 view -0
 2209               		.cfi_startproc
 2210               	/* prologue: function */
 2211               	/* frame size = 0 */
 2212               	/* stack size = 0 */
 2213               	.L__stack_usage = 0
1048:tmk_core/common/action.c ****     switch (action.kind.id) {
 2214               		.loc 1 1048 5 view .LVU532
1049:tmk_core/common/action.c ****         case ACT_LMODS:
1050:tmk_core/common/action.c ****             dprint("ACT_LMODS");
1051:tmk_core/common/action.c ****             break;
1052:tmk_core/common/action.c ****         case ACT_RMODS:
1053:tmk_core/common/action.c ****             dprint("ACT_RMODS");
1054:tmk_core/common/action.c ****             break;
1055:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1056:tmk_core/common/action.c ****             dprint("ACT_LMODS_TAP");
1057:tmk_core/common/action.c ****             break;
1058:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1059:tmk_core/common/action.c ****             dprint("ACT_RMODS_TAP");
1060:tmk_core/common/action.c ****             break;
1061:tmk_core/common/action.c ****         case ACT_USAGE:
1062:tmk_core/common/action.c ****             dprint("ACT_USAGE");
1063:tmk_core/common/action.c ****             break;
1064:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
1065:tmk_core/common/action.c ****             dprint("ACT_MOUSEKEY");
1066:tmk_core/common/action.c ****             break;
1067:tmk_core/common/action.c ****         case ACT_LAYER:
1068:tmk_core/common/action.c ****             dprint("ACT_LAYER");
1069:tmk_core/common/action.c ****             break;
1070:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
1071:tmk_core/common/action.c ****             dprint("ACT_LAYER_MODS");
1072:tmk_core/common/action.c ****             break;
1073:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1074:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP");
1075:tmk_core/common/action.c ****             break;
1076:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1077:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1078:tmk_core/common/action.c ****             break;
1079:tmk_core/common/action.c ****         case ACT_MACRO:
1080:tmk_core/common/action.c ****             dprint("ACT_MACRO");
1081:tmk_core/common/action.c ****             break;
1082:tmk_core/common/action.c ****         case ACT_FUNCTION:
1083:tmk_core/common/action.c ****             dprint("ACT_FUNCTION");
1084:tmk_core/common/action.c ****             break;
1085:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1086:tmk_core/common/action.c ****             dprint("ACT_SWAP_HANDS");
1087:tmk_core/common/action.c ****             break;
1088:tmk_core/common/action.c ****         default:
1089:tmk_core/common/action.c ****             dprint("UNKNOWN");
1090:tmk_core/common/action.c ****             break;
1091:tmk_core/common/action.c ****     }
1092:tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
 2215               		.loc 1 1092 75 view .LVU533
 2216               	/* epilogue start */
1093:tmk_core/common/action.c **** }
 2217               		.loc 1 1093 1 is_stmt 0 view .LVU534
 2218 0000 0895      		ret
 2219               		.cfi_endproc
 2220               	.LFE38:
 2222               		.section	.rodata.CSWTCH.12,"a"
 2225               	CSWTCH.12:
 2226 0000 E200      		.word	226
 2227 0002 E900      		.word	233
 2228 0004 EA00      		.word	234
 2229 0006 B500      		.word	181
 2230 0008 B600      		.word	182
 2231 000a B700      		.word	183
 2232 000c CD00      		.word	205
 2233 000e 8301      		.word	387
 2234 0010 CC00      		.word	204
 2235 0012 8A01      		.word	394
 2236 0014 9201      		.word	402
 2237 0016 9401      		.word	404
 2238 0018 2102      		.word	545
 2239 001a 2302      		.word	547
 2240 001c 2402      		.word	548
 2241 001e 2502      		.word	549
 2242 0020 2602      		.word	550
 2243 0022 2702      		.word	551
 2244 0024 2A02      		.word	554
 2245 0026 B300      		.word	179
 2246 0028 B400      		.word	180
 2247 002a 6F00      		.word	111
 2248 002c 7000      		.word	112
 2249               		.section	.rodata.CSWTCH.11,"a"
 2252               	CSWTCH.11:
 2253 0000 81        		.byte	-127
 2254 0001 82        		.byte	-126
 2255 0002 83        		.byte	-125
 2256               	.global	disable_action_cache
 2257               		.section	.bss.disable_action_cache,"aw",@nobits
 2260               	disable_action_cache:
 2261 0000 00        		.zero	1
 2262               		.comm	tp_buttons,2,1
 2263               		.text
 2264               	.Letext0:
 2265               		.file 5 "e:\\game\\msys2\\mingw64\\avr\\include\\stdint.h"
 2266               		.file 6 "tmk_core/common/keycode.h"
 2267               		.file 7 "tmk_core/common/host.h"
 2268               		.file 8 "quantum/mousekey.h"
 2269               		.file 9 "quantum/command.h"
 2270               		.file 10 "tmk_core/common/action_code.h"
 2271               		.file 11 "tmk_core/common/action.h"
 2272               		.file 12 "tmk_core/common/action_layer.h"
 2273               		.file 13 "tmk_core/common/action_util.h"
 2274               		.file 14 "tmk_core/common/debug.h"
 2275               		.file 15 "quantum/led.h"
 2276               		.file 16 "tmk_core/common/action_macro.h"
 2277               		.file 17 "tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:2      *ABS*:000000000000003e __SP_H__
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:3      *ABS*:000000000000003d __SP_L__
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:4      *ABS*:000000000000003f __SREG__
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:5      *ABS*:0000000000000000 __tmp_reg__
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:6      *ABS*:0000000000000001 __zero_reg__
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:13     .text.action_exec:0000000000000000 action_exec
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:132    .text.process_record_quantum:0000000000000000 process_record_quantum
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:154    .text.post_process_record_quantum:0000000000000000 post_process_record_quantum
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:173    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:198    .text.register_code:0000000000000000 register_code
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:2252   .rodata.CSWTCH.11:0000000000000000 CSWTCH.11
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:2225   .rodata.CSWTCH.12:0000000000000000 CSWTCH.12
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:368    .text.unregister_code:0000000000000000 unregister_code
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:468    .text.tap_code_delay:0000000000000000 tap_code_delay
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:555    .text.tap_code:0000000000000000 tap_code
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:582    .text.register_mods:0000000000000000 register_mods
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:611    .text.unregister_mods:0000000000000000 unregister_mods
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:640    .text.process_action:0000000000000000 process_action
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:1743   .text.process_record:0000000000000000 process_record
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:1671   .text.process_record_handler:0000000000000000 process_record_handler
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:1843   .text.process_record_nocache:0000000000000000 process_record_nocache
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:2260   .bss.disable_action_cache:0000000000000000 disable_action_cache
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:1871   .text.register_weak_mods:0000000000000000 register_weak_mods
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:1900   .text.unregister_weak_mods:0000000000000000 unregister_weak_mods
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:1929   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:1968   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:1988   .text.clear_keyboard:0000000000000000 clear_keyboard
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:2008   .text.is_tap_action:0000000000000000 is_tap_action
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:2096   .text.is_tap_key:0000000000000000 is_tap_key
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:2119   .text.debug_event:0000000000000000 debug_event
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:2161   .text.debug_record:0000000000000000 debug_record
C:\Users\Roningo\AppData\Local\Temp\cc6L5uXs.s:2205   .text.debug_action:0000000000000000 debug_action
                            *COM*:0000000000000002 tp_buttons

UNDEFINED SYMBOLS
clear_weak_mods
action_tapping_process
layer_switch_get_action
keyboard_report
is_key_pressed
del_key
send_keyboard_report
add_key
add_mods
host_system_send
host_consumer_send
mousekey_on
mousekey_send
del_mods
mousekey_off
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
host_keyboard_leds
led_set
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
set_oneshot_layer
layer_invert
layer_move
layer_clear
action_get_macro
action_macro_play
action_function
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
mousekey_clear
clear_keys
clear_mods
__do_copy_data
__do_clear_bss
