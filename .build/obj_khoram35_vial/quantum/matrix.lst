   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.setPinInputHigh_atomic,"ax",@progbits
  12               	setPinInputHigh_atomic:
  13               	.LVL0:
  14               	.LFB118:
  15               		.file 1 "quantum/matrix.c"
   1:quantum/matrix.c **** /*
   2:quantum/matrix.c **** Copyright 2012-2018 Jun Wako, Jack Humbert, Yiancar
   3:quantum/matrix.c **** 
   4:quantum/matrix.c **** This program is free software: you can redistribute it and/or modify
   5:quantum/matrix.c **** it under the terms of the GNU General Public License as published by
   6:quantum/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   7:quantum/matrix.c **** (at your option) any later version.
   8:quantum/matrix.c **** 
   9:quantum/matrix.c **** This program is distributed in the hope that it will be useful,
  10:quantum/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:quantum/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:quantum/matrix.c **** GNU General Public License for more details.
  13:quantum/matrix.c **** 
  14:quantum/matrix.c **** You should have received a copy of the GNU General Public License
  15:quantum/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:quantum/matrix.c **** */
  17:quantum/matrix.c **** #include <stdint.h>
  18:quantum/matrix.c **** #include <stdbool.h>
  19:quantum/matrix.c **** #include "util.h"
  20:quantum/matrix.c **** #include "matrix.h"
  21:quantum/matrix.c **** #include "debounce.h"
  22:quantum/matrix.c **** #include "quantum.h"
  23:quantum/matrix.c **** 
  24:quantum/matrix.c **** #ifdef DIRECT_PINS
  25:quantum/matrix.c **** static pin_t direct_pins[MATRIX_ROWS][MATRIX_COLS] = DIRECT_PINS;
  26:quantum/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL) || (DIODE_DIRECTION == COL2ROW)
  27:quantum/matrix.c **** static const pin_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  28:quantum/matrix.c **** static const pin_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  29:quantum/matrix.c **** #endif
  30:quantum/matrix.c **** 
  31:quantum/matrix.c **** /* matrix state(1:on, 0:off) */
  32:quantum/matrix.c **** extern matrix_row_t raw_matrix[MATRIX_ROWS];  // raw values
  33:quantum/matrix.c **** extern matrix_row_t matrix[MATRIX_ROWS];      // debounced values
  34:quantum/matrix.c **** 
  35:quantum/matrix.c **** static inline void setPinOutput_writeLow(pin_t pin) {
  36:quantum/matrix.c ****     ATOMIC_BLOCK_FORCEON {
  37:quantum/matrix.c ****         setPinOutput(pin);
  38:quantum/matrix.c ****         writePinLow(pin);
  39:quantum/matrix.c ****     }
  40:quantum/matrix.c **** }
  41:quantum/matrix.c **** 
  42:quantum/matrix.c **** static inline void setPinInputHigh_atomic(pin_t pin) {
  16               		.loc 1 42 54 view -0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  43:quantum/matrix.c ****     ATOMIC_BLOCK_FORCEON { setPinInputHigh(pin); }
  22               		.loc 1 43 5 view .LVU1
  23               	.LBB15:
  24               		.loc 1 43 5 view .LVU2
  25               	.LBB16:
  26               	.LBI16:
  27               		.file 2 "e:\\game\\msys2\\mingw64\\avr\\include\\util\\atomic.h"
   1:e:\game\msys2\mingw64\avr\include\util\atomic.h **** /* Copyright (c) 2007 Dean Camera
   2:e:\game\msys2\mingw64\avr\include\util\atomic.h ****    All rights reserved.
   3:e:\game\msys2\mingw64\avr\include\util\atomic.h **** 
   4:e:\game\msys2\mingw64\avr\include\util\atomic.h ****    Redistribution and use in source and binary forms, with or without
   5:e:\game\msys2\mingw64\avr\include\util\atomic.h ****    modification, are permitted provided that the following conditions are met:
   6:e:\game\msys2\mingw64\avr\include\util\atomic.h **** 
   7:e:\game\msys2\mingw64\avr\include\util\atomic.h ****    * Redistributions of source code must retain the above copyright
   8:e:\game\msys2\mingw64\avr\include\util\atomic.h ****      notice, this list of conditions and the following disclaimer.
   9:e:\game\msys2\mingw64\avr\include\util\atomic.h **** 
  10:e:\game\msys2\mingw64\avr\include\util\atomic.h ****    * Redistributions in binary form must reproduce the above copyright
  11:e:\game\msys2\mingw64\avr\include\util\atomic.h ****      notice, this list of conditions and the following disclaimer in
  12:e:\game\msys2\mingw64\avr\include\util\atomic.h ****      the documentation and/or other materials provided with the
  13:e:\game\msys2\mingw64\avr\include\util\atomic.h ****      distribution.
  14:e:\game\msys2\mingw64\avr\include\util\atomic.h **** 
  15:e:\game\msys2\mingw64\avr\include\util\atomic.h ****    * Neither the name of the copyright holders nor the names of
  16:e:\game\msys2\mingw64\avr\include\util\atomic.h ****      contributors may be used to endorse or promote products derived
  17:e:\game\msys2\mingw64\avr\include\util\atomic.h ****      from this software without specific prior written permission.
  18:e:\game\msys2\mingw64\avr\include\util\atomic.h **** 
  19:e:\game\msys2\mingw64\avr\include\util\atomic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20:e:\game\msys2\mingw64\avr\include\util\atomic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21:e:\game\msys2\mingw64\avr\include\util\atomic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22:e:\game\msys2\mingw64\avr\include\util\atomic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23:e:\game\msys2\mingw64\avr\include\util\atomic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24:e:\game\msys2\mingw64\avr\include\util\atomic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25:e:\game\msys2\mingw64\avr\include\util\atomic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26:e:\game\msys2\mingw64\avr\include\util\atomic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27:e:\game\msys2\mingw64\avr\include\util\atomic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28:e:\game\msys2\mingw64\avr\include\util\atomic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29:e:\game\msys2\mingw64\avr\include\util\atomic.h ****   POSSIBILITY OF SUCH DAMAGE.
  30:e:\game\msys2\mingw64\avr\include\util\atomic.h **** */
  31:e:\game\msys2\mingw64\avr\include\util\atomic.h **** 
  32:e:\game\msys2\mingw64\avr\include\util\atomic.h **** /* $Id: atomic.h 2158 2010-06-10 15:48:28Z joerg_wunsch $ */
  33:e:\game\msys2\mingw64\avr\include\util\atomic.h **** 
  34:e:\game\msys2\mingw64\avr\include\util\atomic.h **** #ifndef _UTIL_ATOMIC_H_
  35:e:\game\msys2\mingw64\avr\include\util\atomic.h **** #define _UTIL_ATOMIC_H_ 1
  36:e:\game\msys2\mingw64\avr\include\util\atomic.h **** 
  37:e:\game\msys2\mingw64\avr\include\util\atomic.h **** #include <avr/io.h>
  38:e:\game\msys2\mingw64\avr\include\util\atomic.h **** #include <avr/interrupt.h>
  39:e:\game\msys2\mingw64\avr\include\util\atomic.h **** 
  40:e:\game\msys2\mingw64\avr\include\util\atomic.h **** #if !defined(__DOXYGEN__)
  41:e:\game\msys2\mingw64\avr\include\util\atomic.h **** /* Internal helper functions. */
  42:e:\game\msys2\mingw64\avr\include\util\atomic.h **** static __inline__ uint8_t __iSeiRetVal(void)
  43:e:\game\msys2\mingw64\avr\include\util\atomic.h **** {
  44:e:\game\msys2\mingw64\avr\include\util\atomic.h ****     sei();
  45:e:\game\msys2\mingw64\avr\include\util\atomic.h ****     return 1;
  46:e:\game\msys2\mingw64\avr\include\util\atomic.h **** }
  47:e:\game\msys2\mingw64\avr\include\util\atomic.h **** 
  48:e:\game\msys2\mingw64\avr\include\util\atomic.h **** static __inline__ uint8_t __iCliRetVal(void)
  28               		.loc 2 48 27 view .LVU3
  29               	.LBB17:
  49:e:\game\msys2\mingw64\avr\include\util\atomic.h **** {
  50:e:\game\msys2\mingw64\avr\include\util\atomic.h ****     cli();
  30               		.loc 2 50 5 view .LVU4
  31               	/* #APP */
  32               	 ;  50 "e:\game\msys2\mingw64\avr\include\util\atomic.h" 1
  33 0000 F894      		cli
  34               	 ;  0 "" 2
  51:e:\game\msys2\mingw64\avr\include\util\atomic.h ****     return 1;
  35               		.loc 2 51 5 view .LVU5
  36               	.LVL1:
  37               		.loc 2 51 5 is_stmt 0 view .LVU6
  38               	/* #NOAPP */
  39               	.LBE17:
  40               	.LBE16:
  41               		.loc 1 43 5 is_stmt 1 view .LVU7
  42               		.loc 1 43 28 view .LVU8
  43 0002 E82F      		mov r30,r24
  44 0004 E295      		swap r30
  45 0006 EF70      		andi r30,lo8(15)
  46 0008 F0E0      		ldi r31,0
  47 000a 31A1      		ldd r19,Z+33
  48 000c 282F      		mov r18,r24
  49 000e 2F70      		andi r18,lo8(15)
  50 0010 81E0      		ldi r24,lo8(1)
  51 0012 90E0      		ldi r25,0
  52               	.LVL2:
  53               		.loc 1 43 28 is_stmt 0 view .LVU9
  54 0014 00C0      		rjmp 2f
  55               		1:
  56 0016 880F      		lsl r24
  57               		2:
  58 0018 2A95      		dec r18
  59 001a 02F4      		brpl 1b
  60 001c 982F      		mov r25,r24
  61 001e 9095      		com r25
  62 0020 9323      		and r25,r19
  63 0022 91A3      		std Z+33,r25
  64 0024 92A1      		ldd r25,Z+34
  65 0026 892B      		or r24,r25
  66 0028 82A3      		std Z+34,r24
  67               		.loc 1 43 5 is_stmt 1 view .LVU10
  68               	.LVL3:
  69               		.loc 1 43 5 view .LVU11
  70               	.LBB18:
  71               	.LBI18:
  52:e:\game\msys2\mingw64\avr\include\util\atomic.h **** }
  53:e:\game\msys2\mingw64\avr\include\util\atomic.h **** 
  54:e:\game\msys2\mingw64\avr\include\util\atomic.h **** static __inline__ void __iSeiParam(const uint8_t *__s)
  72               		.loc 2 54 24 view .LVU12
  73               	.LBB19:
  55:e:\game\msys2\mingw64\avr\include\util\atomic.h **** {
  56:e:\game\msys2\mingw64\avr\include\util\atomic.h ****     sei();
  74               		.loc 2 56 5 view .LVU13
  75               	/* #APP */
  76               	 ;  56 "e:\game\msys2\mingw64\avr\include\util\atomic.h" 1
  77 002a 7894      		sei
  78               	 ;  0 "" 2
  57:e:\game\msys2\mingw64\avr\include\util\atomic.h ****     __asm__ volatile ("" ::: "memory");
  79               		.loc 2 57 5 view .LVU14
  58:e:\game\msys2\mingw64\avr\include\util\atomic.h ****     (void)__s;
  80               		.loc 2 58 5 view .LVU15
  81               	.LVL4:
  82               	/* #NOAPP */
  83               	/* epilogue start */
  84               		.loc 2 58 5 is_stmt 0 view .LVU16
  85               	.LBE19:
  86               	.LBE18:
  87               	.LBE15:
  44:quantum/matrix.c **** }
  88               		.loc 1 44 1 view .LVU17
  89 002c 0895      		ret
  90               		.cfi_endproc
  91               	.LFE118:
  93               		.section	.text.matrix_init,"ax",@progbits
  94               	.global	matrix_init
  96               	matrix_init:
  97               	.LFB124:
  45:quantum/matrix.c **** 
  46:quantum/matrix.c **** // matrix code
  47:quantum/matrix.c **** 
  48:quantum/matrix.c **** #ifdef DIRECT_PINS
  49:quantum/matrix.c **** 
  50:quantum/matrix.c **** static void init_pins(void) {
  51:quantum/matrix.c ****     for (int row = 0; row < MATRIX_ROWS; row++) {
  52:quantum/matrix.c ****         for (int col = 0; col < MATRIX_COLS; col++) {
  53:quantum/matrix.c ****             pin_t pin = direct_pins[row][col];
  54:quantum/matrix.c ****             if (pin != NO_PIN) {
  55:quantum/matrix.c ****                 setPinInputHigh(pin);
  56:quantum/matrix.c ****             }
  57:quantum/matrix.c ****         }
  58:quantum/matrix.c ****     }
  59:quantum/matrix.c **** }
  60:quantum/matrix.c **** 
  61:quantum/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row) {
  62:quantum/matrix.c ****     // Start with a clear matrix row
  63:quantum/matrix.c ****     matrix_row_t current_row_value = 0;
  64:quantum/matrix.c **** 
  65:quantum/matrix.c ****     for (uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
  66:quantum/matrix.c ****         pin_t pin = direct_pins[current_row][col_index];
  67:quantum/matrix.c ****         if (pin != NO_PIN) {
  68:quantum/matrix.c ****             current_row_value |= readPin(pin) ? 0 : (MATRIX_ROW_SHIFTER << col_index);
  69:quantum/matrix.c ****         }
  70:quantum/matrix.c ****     }
  71:quantum/matrix.c **** 
  72:quantum/matrix.c ****     // If the row has changed, store the row and return the changed flag.
  73:quantum/matrix.c ****     if (current_matrix[current_row] != current_row_value) {
  74:quantum/matrix.c ****         current_matrix[current_row] = current_row_value;
  75:quantum/matrix.c ****         return true;
  76:quantum/matrix.c ****     }
  77:quantum/matrix.c ****     return false;
  78:quantum/matrix.c **** }
  79:quantum/matrix.c **** 
  80:quantum/matrix.c **** #elif defined(DIODE_DIRECTION)
  81:quantum/matrix.c **** #    if (DIODE_DIRECTION == COL2ROW)
  82:quantum/matrix.c **** 
  83:quantum/matrix.c **** static void select_row(uint8_t row) { setPinOutput_writeLow(row_pins[row]); }
  84:quantum/matrix.c **** 
  85:quantum/matrix.c **** static void unselect_row(uint8_t row) { setPinInputHigh_atomic(row_pins[row]); }
  86:quantum/matrix.c **** 
  87:quantum/matrix.c **** static void unselect_rows(void) {
  88:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_ROWS; x++) {
  89:quantum/matrix.c ****         setPinInputHigh_atomic(row_pins[x]);
  90:quantum/matrix.c ****     }
  91:quantum/matrix.c **** }
  92:quantum/matrix.c **** 
  93:quantum/matrix.c **** static void init_pins(void) {
  94:quantum/matrix.c ****     unselect_rows();
  95:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_COLS; x++) {
  96:quantum/matrix.c ****         setPinInputHigh_atomic(col_pins[x]);
  97:quantum/matrix.c ****     }
  98:quantum/matrix.c **** }
  99:quantum/matrix.c **** 
 100:quantum/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row) {
 101:quantum/matrix.c ****     // Start with a clear matrix row
 102:quantum/matrix.c ****     matrix_row_t current_row_value = 0;
 103:quantum/matrix.c **** 
 104:quantum/matrix.c ****     // Select row
 105:quantum/matrix.c ****     select_row(current_row);
 106:quantum/matrix.c ****     matrix_output_select_delay();
 107:quantum/matrix.c **** 
 108:quantum/matrix.c ****     // For each col...
 109:quantum/matrix.c ****     for (uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 110:quantum/matrix.c ****         // Select the col pin to read (active low)
 111:quantum/matrix.c ****         uint8_t pin_state = readPin(col_pins[col_index]);
 112:quantum/matrix.c **** 
 113:quantum/matrix.c ****         // Populate the matrix row with the state of the col pin
 114:quantum/matrix.c ****         current_row_value |= pin_state ? 0 : (MATRIX_ROW_SHIFTER << col_index);
 115:quantum/matrix.c ****     }
 116:quantum/matrix.c **** 
 117:quantum/matrix.c ****     // Unselect row
 118:quantum/matrix.c ****     unselect_row(current_row);
 119:quantum/matrix.c ****     matrix_output_unselect_delay();  // wait for all Col signals to go HIGH
 120:quantum/matrix.c **** 
 121:quantum/matrix.c ****     // If the row has changed, store the row and return the changed flag.
 122:quantum/matrix.c ****     if (current_matrix[current_row] != current_row_value) {
 123:quantum/matrix.c ****         current_matrix[current_row] = current_row_value;
 124:quantum/matrix.c ****         return true;
 125:quantum/matrix.c ****     }
 126:quantum/matrix.c ****     return false;
 127:quantum/matrix.c **** }
 128:quantum/matrix.c **** 
 129:quantum/matrix.c **** #    elif (DIODE_DIRECTION == ROW2COL)
 130:quantum/matrix.c **** 
 131:quantum/matrix.c **** static void select_col(uint8_t col) { setPinOutput_writeLow(col_pins[col]); }
 132:quantum/matrix.c **** 
 133:quantum/matrix.c **** static void unselect_col(uint8_t col) { setPinInputHigh_atomic(col_pins[col]); }
 134:quantum/matrix.c **** 
 135:quantum/matrix.c **** static void unselect_cols(void) {
 136:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_COLS; x++) {
 137:quantum/matrix.c ****         setPinInputHigh_atomic(col_pins[x]);
 138:quantum/matrix.c ****     }
 139:quantum/matrix.c **** }
 140:quantum/matrix.c **** 
 141:quantum/matrix.c **** static void init_pins(void) {
 142:quantum/matrix.c ****     unselect_cols();
 143:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_ROWS; x++) {
 144:quantum/matrix.c ****         setPinInputHigh_atomic(row_pins[x]);
 145:quantum/matrix.c ****     }
 146:quantum/matrix.c **** }
 147:quantum/matrix.c **** 
 148:quantum/matrix.c **** static bool read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col) {
 149:quantum/matrix.c ****     bool matrix_changed = false;
 150:quantum/matrix.c **** 
 151:quantum/matrix.c ****     // Select col
 152:quantum/matrix.c ****     select_col(current_col);
 153:quantum/matrix.c ****     matrix_output_select_delay();
 154:quantum/matrix.c **** 
 155:quantum/matrix.c ****     // For each row...
 156:quantum/matrix.c ****     for (uint8_t row_index = 0; row_index < MATRIX_ROWS; row_index++) {
 157:quantum/matrix.c ****         // Store last value of row prior to reading
 158:quantum/matrix.c ****         matrix_row_t last_row_value    = current_matrix[row_index];
 159:quantum/matrix.c ****         matrix_row_t current_row_value = last_row_value;
 160:quantum/matrix.c **** 
 161:quantum/matrix.c ****         // Check row pin state
 162:quantum/matrix.c ****         if (readPin(row_pins[row_index]) == 0) {
 163:quantum/matrix.c ****             // Pin LO, set col bit
 164:quantum/matrix.c ****             current_row_value |= (MATRIX_ROW_SHIFTER << current_col);
 165:quantum/matrix.c ****         } else {
 166:quantum/matrix.c ****             // Pin HI, clear col bit
 167:quantum/matrix.c ****             current_row_value &= ~(MATRIX_ROW_SHIFTER << current_col);
 168:quantum/matrix.c ****         }
 169:quantum/matrix.c **** 
 170:quantum/matrix.c ****         // Determine if the matrix changed state
 171:quantum/matrix.c ****         if ((last_row_value != current_row_value)) {
 172:quantum/matrix.c ****             matrix_changed |= true;
 173:quantum/matrix.c ****             current_matrix[row_index] = current_row_value;
 174:quantum/matrix.c ****         }
 175:quantum/matrix.c ****     }
 176:quantum/matrix.c **** 
 177:quantum/matrix.c ****     // Unselect col
 178:quantum/matrix.c ****     unselect_col(current_col);
 179:quantum/matrix.c ****     matrix_output_unselect_delay();  // wait for all Row signals to go HIGH
 180:quantum/matrix.c **** 
 181:quantum/matrix.c ****     return matrix_changed;
 182:quantum/matrix.c **** }
 183:quantum/matrix.c **** 
 184:quantum/matrix.c **** #    else
 185:quantum/matrix.c **** #        error DIODE_DIRECTION must be one of COL2ROW or ROW2COL!
 186:quantum/matrix.c **** #    endif
 187:quantum/matrix.c **** #else
 188:quantum/matrix.c **** #    error DIODE_DIRECTION is not defined!
 189:quantum/matrix.c **** #endif
 190:quantum/matrix.c **** 
 191:quantum/matrix.c **** void matrix_init(void) {
  98               		.loc 1 191 24 is_stmt 1 view -0
  99               		.cfi_startproc
 100 0000 CF93      		push r28
 101               	.LCFI0:
 102               		.cfi_def_cfa_offset 3
 103               		.cfi_offset 28, -2
 104 0002 DF93      		push r29
 105               	.LCFI1:
 106               		.cfi_def_cfa_offset 4
 107               		.cfi_offset 29, -3
 108               	/* prologue: function */
 109               	/* frame size = 0 */
 110               	/* stack size = 2 */
 111               	.L__stack_usage = 2
 192:quantum/matrix.c ****     // initialize key pins
 193:quantum/matrix.c ****     init_pins();
 112               		.loc 1 193 5 view .LVU19
 113               	.LBB27:
 114               	.LBI27:
  93:quantum/matrix.c ****     unselect_rows();
 115               		.loc 1 93 13 view .LVU20
 116               	.LBE27:
  94:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_COLS; x++) {
 117               		.loc 1 94 5 view .LVU21
 118               	.LBB31:
 119               	.LBB28:
 120               	.LBI28:
  87:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_ROWS; x++) {
 121               		.loc 1 87 13 view .LVU22
 122               	.LVL5:
 123               	.LBB29:
  88:quantum/matrix.c ****         setPinInputHigh_atomic(row_pins[x]);
 124               		.loc 1 88 25 view .LVU23
 125 0004 C0E0      		ldi r28,lo8(row_pins)
 126 0006 D0E0      		ldi r29,hi8(row_pins)
 127               	.LVL6:
 128               	.L3:
  89:quantum/matrix.c ****     }
 129               		.loc 1 89 9 view .LVU24
 130 0008 8991      		ld r24,Y+
 131               	.LVL7:
  89:quantum/matrix.c ****     }
 132               		.loc 1 89 9 is_stmt 0 view .LVU25
 133 000a 0E94 0000 		call setPinInputHigh_atomic
 134               	.LVL8:
  88:quantum/matrix.c ****         setPinInputHigh_atomic(row_pins[x]);
 135               		.loc 1 88 42 is_stmt 1 view .LVU26
  88:quantum/matrix.c ****         setPinInputHigh_atomic(row_pins[x]);
 136               		.loc 1 88 25 view .LVU27
  88:quantum/matrix.c ****         setPinInputHigh_atomic(row_pins[x]);
 137               		.loc 1 88 5 is_stmt 0 view .LVU28
 138 000e 80E0      		ldi r24,hi8(row_pins+7)
 139 0010 C030      		cpi r28,lo8(row_pins+7)
 140 0012 D807      		cpc r29,r24
 141 0014 01F4      		brne .L3
 142 0016 C0E0      		ldi r28,lo8(col_pins)
 143 0018 D0E0      		ldi r29,hi8(col_pins)
 144               	.LVL9:
 145               	.L4:
  88:quantum/matrix.c ****         setPinInputHigh_atomic(row_pins[x]);
 146               		.loc 1 88 5 view .LVU29
 147               	.LBE29:
 148               	.LBE28:
 149               	.LBB30:
  96:quantum/matrix.c ****     }
 150               		.loc 1 96 9 is_stmt 1 view .LVU30
 151 001a 8991      		ld r24,Y+
 152               	.LVL10:
  96:quantum/matrix.c ****     }
 153               		.loc 1 96 9 is_stmt 0 view .LVU31
 154 001c 0E94 0000 		call setPinInputHigh_atomic
 155               	.LVL11:
  95:quantum/matrix.c ****         setPinInputHigh_atomic(col_pins[x]);
 156               		.loc 1 95 42 is_stmt 1 view .LVU32
  95:quantum/matrix.c ****         setPinInputHigh_atomic(col_pins[x]);
 157               		.loc 1 95 25 view .LVU33
  95:quantum/matrix.c ****         setPinInputHigh_atomic(col_pins[x]);
 158               		.loc 1 95 5 is_stmt 0 view .LVU34
 159 0020 80E0      		ldi r24,hi8(col_pins+11)
 160 0022 C030      		cpi r28,lo8(col_pins+11)
 161 0024 D807      		cpc r29,r24
 162 0026 01F4      		brne .L4
 163 0028 E0E0      		ldi r30,lo8(raw_matrix)
 164 002a F0E0      		ldi r31,hi8(raw_matrix)
 165 002c A0E0      		ldi r26,lo8(matrix)
 166 002e B0E0      		ldi r27,hi8(matrix)
 167               	.L5:
 168               	.LBE30:
 169               	.LBE31:
 170               	.LBB32:
 194:quantum/matrix.c **** 
 195:quantum/matrix.c ****     // initialize matrix state: all keys off
 196:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 197:quantum/matrix.c ****         raw_matrix[i] = 0;
 171               		.loc 1 197 9 is_stmt 1 discriminator 3 view .LVU35
 172               		.loc 1 197 23 is_stmt 0 discriminator 3 view .LVU36
 173 0030 1192      		st Z+,__zero_reg__
 174 0032 1192      		st Z+,__zero_reg__
 198:quantum/matrix.c ****         matrix[i]     = 0;
 175               		.loc 1 198 9 is_stmt 1 discriminator 3 view .LVU37
 176               		.loc 1 198 23 is_stmt 0 discriminator 3 view .LVU38
 177 0034 1D92      		st X+,__zero_reg__
 178 0036 1D92      		st X+,__zero_reg__
 196:quantum/matrix.c ****         raw_matrix[i] = 0;
 179               		.loc 1 196 42 is_stmt 1 discriminator 3 view .LVU39
 180               	.LVL12:
 196:quantum/matrix.c ****         raw_matrix[i] = 0;
 181               		.loc 1 196 25 discriminator 3 view .LVU40
 196:quantum/matrix.c ****         raw_matrix[i] = 0;
 182               		.loc 1 196 5 is_stmt 0 discriminator 3 view .LVU41
 183 0038 80E0      		ldi r24,hi8(raw_matrix+14)
 184 003a E030      		cpi r30,lo8(raw_matrix+14)
 185 003c F807      		cpc r31,r24
 186 003e 01F4      		brne .L5
 187               	.LBE32:
 199:quantum/matrix.c ****     }
 200:quantum/matrix.c **** 
 201:quantum/matrix.c ****     debounce_init(MATRIX_ROWS);
 188               		.loc 1 201 5 is_stmt 1 view .LVU42
 189 0040 87E0      		ldi r24,lo8(7)
 190 0042 0E94 0000 		call debounce_init
 191               	.LVL13:
 202:quantum/matrix.c **** 
 203:quantum/matrix.c ****     matrix_init_quantum();
 192               		.loc 1 203 5 view .LVU43
 193               	/* epilogue start */
 204:quantum/matrix.c **** }
 194               		.loc 1 204 1 is_stmt 0 view .LVU44
 195 0046 DF91      		pop r29
 196 0048 CF91      		pop r28
 197               	.LVL14:
 203:quantum/matrix.c **** }
 198               		.loc 1 203 5 view .LVU45
 199 004a 0C94 0000 		jmp matrix_init_quantum
 200               	.LVL15:
 201               		.cfi_endproc
 202               	.LFE124:
 204               		.section	.text.matrix_scan,"ax",@progbits
 205               	.global	matrix_scan
 207               	matrix_scan:
 208               	.LFB125:
 205:quantum/matrix.c **** 
 206:quantum/matrix.c **** uint8_t matrix_scan(void) {
 209               		.loc 1 206 27 is_stmt 1 view -0
 210               		.cfi_startproc
 211 0000 AF92      		push r10
 212               	.LCFI2:
 213               		.cfi_def_cfa_offset 3
 214               		.cfi_offset 10, -2
 215 0002 BF92      		push r11
 216               	.LCFI3:
 217               		.cfi_def_cfa_offset 4
 218               		.cfi_offset 11, -3
 219 0004 DF92      		push r13
 220               	.LCFI4:
 221               		.cfi_def_cfa_offset 5
 222               		.cfi_offset 13, -4
 223 0006 EF92      		push r14
 224               	.LCFI5:
 225               		.cfi_def_cfa_offset 6
 226               		.cfi_offset 14, -5
 227 0008 FF92      		push r15
 228               	.LCFI6:
 229               		.cfi_def_cfa_offset 7
 230               		.cfi_offset 15, -6
 231 000a 0F93      		push r16
 232               	.LCFI7:
 233               		.cfi_def_cfa_offset 8
 234               		.cfi_offset 16, -7
 235 000c 1F93      		push r17
 236               	.LCFI8:
 237               		.cfi_def_cfa_offset 9
 238               		.cfi_offset 17, -8
 239 000e CF93      		push r28
 240               	.LCFI9:
 241               		.cfi_def_cfa_offset 10
 242               		.cfi_offset 28, -9
 243 0010 DF93      		push r29
 244               	.LCFI10:
 245               		.cfi_def_cfa_offset 11
 246               		.cfi_offset 29, -10
 247               	/* prologue: function */
 248               	/* frame size = 0 */
 249               	/* stack size = 9 */
 250               	.L__stack_usage = 9
 207:quantum/matrix.c ****     bool changed = false;
 251               		.loc 1 207 5 view .LVU47
 252               	.LVL16:
 208:quantum/matrix.c **** 
 209:quantum/matrix.c **** #if defined(DIRECT_PINS) || (DIODE_DIRECTION == COL2ROW)
 210:quantum/matrix.c ****     // Set row, read cols
 211:quantum/matrix.c ****     for (uint8_t current_row = 0; current_row < MATRIX_ROWS; current_row++) {
 253               		.loc 1 211 5 view .LVU48
 254               	.LBB49:
 255               		.loc 1 211 10 view .LVU49
 256               		.loc 1 211 35 view .LVU50
 257 0012 C0E0      		ldi r28,lo8(row_pins)
 258 0014 D0E0      		ldi r29,hi8(row_pins)
 259 0016 00E0      		ldi r16,lo8(raw_matrix)
 260 0018 10E0      		ldi r17,hi8(raw_matrix)
 261               	.LBE49:
 207:quantum/matrix.c ****     bool changed = false;
 262               		.loc 1 207 10 is_stmt 0 view .LVU51
 263 001a D12C      		mov r13,__zero_reg__
 264               	.LBB80:
 265               	.LBB50:
 266               	.LBB51:
 267               	.LBB52:
 268               	.LBB53:
 269               	.LBB54:
 270               	.LBB55:
  37:quantum/matrix.c ****         writePinLow(pin);
 271               		.loc 1 37 9 view .LVU52
 272 001c EE24      		clr r14
 273 001e E394      		inc r14
 274 0020 F12C      		mov r15,__zero_reg__
 275               	.LVL17:
 276               	.L13:
  37:quantum/matrix.c ****         writePinLow(pin);
 277               		.loc 1 37 9 view .LVU53
 278               	.LBE55:
 279               	.LBE54:
 280               	.LBE53:
 281               	.LBE52:
 282               	.LBE51:
 283               	.LBE50:
 212:quantum/matrix.c ****         changed |= read_cols_on_row(raw_matrix, current_row);
 284               		.loc 1 212 9 is_stmt 1 view .LVU54
 285               	.LBB77:
 286               	.LBI50:
 100:quantum/matrix.c ****     // Start with a clear matrix row
 287               		.loc 1 100 13 view .LVU55
 288               	.LBB74:
 102:quantum/matrix.c **** 
 289               		.loc 1 102 5 view .LVU56
 105:quantum/matrix.c ****     matrix_output_select_delay();
 290               		.loc 1 105 5 view .LVU57
 291               	.LBB65:
 292               	.LBI52:
  83:quantum/matrix.c **** 
 293               		.loc 1 83 13 view .LVU58
 294               	.LBB63:
  83:quantum/matrix.c **** 
 295               		.loc 1 83 39 view .LVU59
 296 0022 8991      		ld r24,Y+
 297               	.LVL18:
 298               	.LBB61:
 299               	.LBI54:
  35:quantum/matrix.c ****     ATOMIC_BLOCK_FORCEON {
 300               		.loc 1 35 20 view .LVU60
 301               	.LBE61:
 302               	.LBE63:
 303               	.LBE65:
 304               	.LBE74:
 305               	.LBE77:
 306               	.LBE80:
  36:quantum/matrix.c ****         setPinOutput(pin);
 307               		.loc 1 36 5 view .LVU61
 308               	.LBB81:
 309               	.LBB78:
 310               	.LBB75:
 311               	.LBB66:
 312               	.LBB64:
 313               	.LBB62:
 314               	.LBB60:
  36:quantum/matrix.c ****         setPinOutput(pin);
 315               		.loc 1 36 5 view .LVU62
 316               	.LBB56:
 317               	.LBI56:
  48:e:\game\msys2\mingw64\avr\include\util\atomic.h **** {
 318               		.loc 2 48 27 view .LVU63
 319               	.LBB57:
  50:e:\game\msys2\mingw64\avr\include\util\atomic.h ****     return 1;
 320               		.loc 2 50 5 view .LVU64
 321               	/* #APP */
 322               	 ;  50 "e:\game\msys2\mingw64\avr\include\util\atomic.h" 1
 323 0024 F894      		cli
 324               	 ;  0 "" 2
  51:e:\game\msys2\mingw64\avr\include\util\atomic.h **** }
 325               		.loc 2 51 5 view .LVU65
 326               	.LVL19:
  51:e:\game\msys2\mingw64\avr\include\util\atomic.h **** }
 327               		.loc 2 51 5 is_stmt 0 view .LVU66
 328               	/* #NOAPP */
 329               	.LBE57:
 330               	.LBE56:
  36:quantum/matrix.c ****         setPinOutput(pin);
 331               		.loc 1 36 5 is_stmt 1 view .LVU67
  37:quantum/matrix.c ****         writePinLow(pin);
 332               		.loc 1 37 9 view .LVU68
 333 0026 E82F      		mov r30,r24
 334 0028 E295      		swap r30
 335 002a EF70      		andi r30,lo8(15)
 336 002c F0E0      		ldi r31,0
 337 002e 21A1      		ldd r18,Z+33
 338 0030 8F70      		andi r24,lo8(15)
 339               	.LVL20:
  37:quantum/matrix.c ****         writePinLow(pin);
 340               		.loc 1 37 9 is_stmt 0 view .LVU69
 341 0032 A701      		movw r20,r14
 342 0034 00C0      		rjmp 2f
 343               		1:
 344 0036 440F      		lsl r20
 345 0038 551F      		rol r21
 346               		2:
 347 003a 8A95      		dec r24
 348 003c 02F4      		brpl 1b
 349 003e CA01      		movw r24,r20
 350 0040 922F      		mov r25,r18
 351 0042 982B      		or r25,r24
 352 0044 91A3      		std Z+33,r25
 353               	.LVL21:
  38:quantum/matrix.c ****     }
 354               		.loc 1 38 9 is_stmt 1 view .LVU70
 355 0046 92A1      		ldd r25,Z+34
 356 0048 8095      		com r24
 357 004a 8923      		and r24,r25
 358 004c 82A3      		std Z+34,r24
  36:quantum/matrix.c ****         setPinOutput(pin);
 359               		.loc 1 36 5 view .LVU71
 360               	.LVL22:
  36:quantum/matrix.c ****         setPinOutput(pin);
 361               		.loc 1 36 5 view .LVU72
 362               	.LBB58:
 363               	.LBI58:
  54:e:\game\msys2\mingw64\avr\include\util\atomic.h **** {
 364               		.loc 2 54 24 view .LVU73
 365               	.LBB59:
  56:e:\game\msys2\mingw64\avr\include\util\atomic.h ****     __asm__ volatile ("" ::: "memory");
 366               		.loc 2 56 5 view .LVU74
 367               	/* #APP */
 368               	 ;  56 "e:\game\msys2\mingw64\avr\include\util\atomic.h" 1
 369 004e 7894      		sei
 370               	 ;  0 "" 2
  57:e:\game\msys2\mingw64\avr\include\util\atomic.h ****     (void)__s;
 371               		.loc 2 57 5 view .LVU75
 372               		.loc 2 58 5 view .LVU76
 373               	.LVL23:
 374               		.loc 2 58 5 is_stmt 0 view .LVU77
 375               	/* #NOAPP */
 376               	.LBE59:
 377               	.LBE58:
 378               	.LBE60:
 379               	.LBE62:
 380               	.LBE64:
 381               	.LBE66:
 106:quantum/matrix.c **** 
 382               		.loc 1 106 5 is_stmt 1 view .LVU78
 383 0050 0E94 0000 		call matrix_output_select_delay
 384               	.LVL24:
 109:quantum/matrix.c ****         // Select the col pin to read (active low)
 385               		.loc 1 109 5 view .LVU79
 386               	.LBB67:
 109:quantum/matrix.c ****         // Select the col pin to read (active low)
 387               		.loc 1 109 10 view .LVU80
 109:quantum/matrix.c ****         // Select the col pin to read (active low)
 388               		.loc 1 109 33 view .LVU81
 389 0054 E0E0      		ldi r30,lo8(col_pins)
 390 0056 F0E0      		ldi r31,hi8(col_pins)
 391               	.LBE67:
 106:quantum/matrix.c **** 
 392               		.loc 1 106 5 is_stmt 0 view .LVU82
 393 0058 30E0      		ldi r19,0
 394 005a 20E0      		ldi r18,0
 102:quantum/matrix.c **** 
 395               		.loc 1 102 18 view .LVU83
 396 005c B12C      		mov r11,__zero_reg__
 397 005e A12C      		mov r10,__zero_reg__
 398               	.LVL25:
 399               	.L11:
 400               	.LBB70:
 401               	.LBB68:
 111:quantum/matrix.c **** 
 402               		.loc 1 111 9 is_stmt 1 view .LVU84
 111:quantum/matrix.c **** 
 403               		.loc 1 111 29 is_stmt 0 view .LVU85
 404 0060 4191      		ld r20,Z+
 405 0062 A42F      		mov r26,r20
 406 0064 A295      		swap r26
 407 0066 AF70      		andi r26,lo8(15)
 408 0068 B0E0      		ldi r27,0
 409 006a 9096      		adiw r26,32
 410 006c 8C91      		ld r24,X
 411               	.LVL26:
 114:quantum/matrix.c ****     }
 412               		.loc 1 114 9 is_stmt 1 view .LVU86
 111:quantum/matrix.c **** 
 413               		.loc 1 111 29 is_stmt 0 view .LVU87
 414 006e 90E0      		ldi r25,0
 415 0070 4F70      		andi r20,lo8(15)
 416               	.LVL27:
 111:quantum/matrix.c **** 
 417               		.loc 1 111 29 view .LVU88
 418 0072 00C0      		rjmp 2f
 419               		1:
 420 0074 9595      		asr r25
 421 0076 8795      		ror r24
 422               		2:
 423 0078 4A95      		dec r20
 424 007a 02F4      		brpl 1b
 425               	.LVL28:
 114:quantum/matrix.c ****     }
 426               		.loc 1 114 44 view .LVU89
 427 007c 80FD      		sbrc r24,0
 428 007e 00C0      		rjmp .L14
 429 0080 C701      		movw r24,r14
 430 0082 022E      		mov r0,r18
 431 0084 00C0      		rjmp 2f
 432               		1:
 433 0086 880F      		lsl r24
 434 0088 991F      		rol r25
 435               		2:
 436 008a 0A94      		dec r0
 437 008c 02F4      		brpl 1b
 438               	.L10:
 114:quantum/matrix.c ****     }
 439               		.loc 1 114 27 view .LVU90
 440 008e A82A      		or r10,r24
 441               	.LVL29:
 114:quantum/matrix.c ****     }
 442               		.loc 1 114 27 view .LVU91
 443 0090 B92A      		or r11,r25
 444               	.LVL30:
 114:quantum/matrix.c ****     }
 445               		.loc 1 114 27 view .LVU92
 446               	.LBE68:
 109:quantum/matrix.c ****         // Select the col pin to read (active low)
 447               		.loc 1 109 58 is_stmt 1 view .LVU93
 109:quantum/matrix.c ****         // Select the col pin to read (active low)
 448               		.loc 1 109 33 view .LVU94
 449 0092 2F5F      		subi r18,-1
 450 0094 3F4F      		sbci r19,-1
 451               	.LVL31:
 109:quantum/matrix.c ****         // Select the col pin to read (active low)
 452               		.loc 1 109 5 is_stmt 0 view .LVU95
 453 0096 2B30      		cpi r18,11
 454 0098 3105      		cpc r19,__zero_reg__
 455 009a 01F4      		brne .L11
 456               	.LBE70:
 118:quantum/matrix.c ****     matrix_output_unselect_delay();  // wait for all Col signals to go HIGH
 457               		.loc 1 118 5 is_stmt 1 view .LVU96
 458               	.LVL32:
 459               	.LBB71:
 460               	.LBI71:
  85:quantum/matrix.c **** 
 461               		.loc 1 85 13 view .LVU97
 462               	.LBB72:
  85:quantum/matrix.c **** 
 463               		.loc 1 85 41 view .LVU98
 464 009c FE01      		movw r30,r28
 465 009e 3197      		sbiw r30,1
 466 00a0 8081      		ld r24,Z
 467 00a2 0E94 0000 		call setPinInputHigh_atomic
 468               	.LVL33:
  85:quantum/matrix.c **** 
 469               		.loc 1 85 41 is_stmt 0 view .LVU99
 470               	.LBE72:
 471               	.LBE71:
 119:quantum/matrix.c **** 
 472               		.loc 1 119 5 is_stmt 1 view .LVU100
 473 00a6 0E94 0000 		call matrix_output_unselect_delay
 474               	.LVL34:
 122:quantum/matrix.c ****         current_matrix[current_row] = current_row_value;
 475               		.loc 1 122 5 view .LVU101
 122:quantum/matrix.c ****         current_matrix[current_row] = current_row_value;
 476               		.loc 1 122 8 is_stmt 0 view .LVU102
 477 00aa F801      		movw r30,r16
 478 00ac 8081      		ld r24,Z
 479 00ae 9181      		ldd r25,Z+1
 480 00b0 A816      		cp r10,r24
 481 00b2 B906      		cpc r11,r25
 482 00b4 01F0      		breq .L15
 123:quantum/matrix.c ****         return true;
 483               		.loc 1 123 9 is_stmt 1 view .LVU103
 123:quantum/matrix.c ****         return true;
 484               		.loc 1 123 37 is_stmt 0 view .LVU104
 485 00b6 B182      		std Z+1,r11
 486 00b8 A082      		st Z,r10
 124:quantum/matrix.c ****     }
 487               		.loc 1 124 9 is_stmt 1 view .LVU105
 124:quantum/matrix.c ****     }
 488               		.loc 1 124 16 is_stmt 0 view .LVU106
 489 00ba 81E0      		ldi r24,lo8(1)
 490               	.L12:
 491               	.LVL35:
 124:quantum/matrix.c ****     }
 492               		.loc 1 124 16 view .LVU107
 493               	.LBE75:
 494               	.LBE78:
 495               		.loc 1 212 17 view .LVU108
 496 00bc D82A      		or r13,r24
 497               	.LVL36:
 211:quantum/matrix.c ****         changed |= read_cols_on_row(raw_matrix, current_row);
 498               		.loc 1 211 62 is_stmt 1 view .LVU109
 211:quantum/matrix.c ****         changed |= read_cols_on_row(raw_matrix, current_row);
 499               		.loc 1 211 35 view .LVU110
 500 00be 0E5F      		subi r16,-2
 501 00c0 1F4F      		sbci r17,-1
 211:quantum/matrix.c ****         changed |= read_cols_on_row(raw_matrix, current_row);
 502               		.loc 1 211 5 is_stmt 0 view .LVU111
 503 00c2 F0E0      		ldi r31,hi8(row_pins+7)
 504 00c4 C030      		cpi r28,lo8(row_pins+7)
 505 00c6 DF07      		cpc r29,r31
 506 00c8 01F0      		breq .+2
 507 00ca 00C0      		rjmp .L13
 508               	.LBE81:
 213:quantum/matrix.c ****     }
 214:quantum/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL)
 215:quantum/matrix.c ****     // Set col, read rows
 216:quantum/matrix.c ****     for (uint8_t current_col = 0; current_col < MATRIX_COLS; current_col++) {
 217:quantum/matrix.c ****         changed |= read_rows_on_col(raw_matrix, current_col);
 218:quantum/matrix.c ****     }
 219:quantum/matrix.c **** #endif
 220:quantum/matrix.c **** 
 221:quantum/matrix.c ****     debounce(raw_matrix, matrix, MATRIX_ROWS, changed);
 509               		.loc 1 221 5 is_stmt 1 view .LVU112
 510 00cc 2D2D      		mov r18,r13
 511 00ce 47E0      		ldi r20,lo8(7)
 512 00d0 60E0      		ldi r22,lo8(matrix)
 513 00d2 70E0      		ldi r23,hi8(matrix)
 514 00d4 80E0      		ldi r24,lo8(raw_matrix)
 515 00d6 90E0      		ldi r25,hi8(raw_matrix)
 516 00d8 0E94 0000 		call debounce
 517               	.LVL37:
 222:quantum/matrix.c **** 
 223:quantum/matrix.c ****     matrix_scan_quantum();
 518               		.loc 1 223 5 view .LVU113
 519 00dc 0E94 0000 		call matrix_scan_quantum
 520               	.LVL38:
 224:quantum/matrix.c ****     return (uint8_t)changed;
 521               		.loc 1 224 5 view .LVU114
 225:quantum/matrix.c **** }
 522               		.loc 1 225 1 is_stmt 0 view .LVU115
 523 00e0 8D2D      		mov r24,r13
 524               	/* epilogue start */
 525 00e2 DF91      		pop r29
 526 00e4 CF91      		pop r28
 527               	.LVL39:
 528               		.loc 1 225 1 view .LVU116
 529 00e6 1F91      		pop r17
 530 00e8 0F91      		pop r16
 531 00ea FF90      		pop r15
 532 00ec EF90      		pop r14
 533 00ee DF90      		pop r13
 534               	.LVL40:
 535               		.loc 1 225 1 view .LVU117
 536 00f0 BF90      		pop r11
 537 00f2 AF90      		pop r10
 538 00f4 0895      		ret
 539               	.LVL41:
 540               	.L14:
 541               	.LBB82:
 542               	.LBB79:
 543               	.LBB76:
 544               	.LBB73:
 545               	.LBB69:
 114:quantum/matrix.c ****     }
 546               		.loc 1 114 44 view .LVU118
 547 00f6 90E0      		ldi r25,0
 548 00f8 80E0      		ldi r24,0
 549 00fa 00C0      		rjmp .L10
 550               	.LVL42:
 551               	.L15:
 114:quantum/matrix.c ****     }
 552               		.loc 1 114 44 view .LVU119
 553               	.LBE69:
 554               	.LBE73:
 126:quantum/matrix.c **** }
 555               		.loc 1 126 12 view .LVU120
 556 00fc 80E0      		ldi r24,0
 557 00fe 00C0      		rjmp .L12
 558               	.LBE76:
 559               	.LBE79:
 560               	.LBE82:
 561               		.cfi_endproc
 562               	.LFE125:
 564               		.section	.rodata.col_pins,"a"
 567               	col_pins:
 568 0000 33        		.byte	51
 569 0001 31        		.byte	49
 570 0002 F7        		.byte	-9
 571 0003 F6        		.byte	-10
 572 0004 F5        		.byte	-11
 573 0005 30        		.byte	48
 574 0006 90        		.byte	-112
 575 0007 94        		.byte	-108
 576 0008 66        		.byte	102
 577 0009 97        		.byte	-105
 578 000a C6        		.byte	-58
 579               		.section	.rodata.row_pins,"a"
 582               	row_pins:
 583 0000 F4        		.byte	-12
 584 0001 32        		.byte	50
 585 0002 36        		.byte	54
 586 0003 95        		.byte	-107
 587 0004 91        		.byte	-111
 588 0005 34        		.byte	52
 589 0006 35        		.byte	53
 590               		.text
 591               	.Letext0:
 592               		.file 3 "e:\\game\\msys2\\mingw64\\avr\\include\\stdint.h"
 593               		.file 4 "quantum/matrix.h"
 594               		.file 5 "e:\\game\\msys2\\mingw64\\lib\\gcc\\avr\\8.4.0\\include\\stddef.h"
 595               		.file 6 "lib/lufa/LUFA/Drivers/USB/Core/AVR8/../StdRequestType.h"
 596               		.file 7 "tmk_core/common/action.h"
 597               		.file 8 "lib/lufa/LUFA/Drivers/USB/Core/AVR8/../DeviceStandardReq.h"
 598               		.file 9 "lib/lufa/LUFA/Drivers/USB/Core/USBTask.h"
 599               		.file 10 "lib/lufa/LUFA/Drivers/USB/Core/HostStandardReq.h"
 600               		.file 11 "e:\\game\\msys2\\mingw64\\avr\\include\\stdio.h"
 601               		.file 12 "tmk_core/common/report.h"
 602               		.file 13 "tmk_core/common/host.h"
 603               		.file 14 "tmk_core/common/debug.h"
 604               		.file 15 "quantum/keycode_config.h"
 605               		.file 16 "tmk_core/common/timer.h"
 606               		.file 17 "quantum/sequencer/sequencer.h"
 607               		.file 18 "quantum/keymap.h"
 608               		.file 19 "./quantum/color.h"
 609               		.file 20 "quantum/rgblight.h"
 610               		.file 21 "tmk_core/common/action_layer.h"
 611               		.file 22 "tmk_core/common/avr/gpio.h"
 612               		.file 23 "tmk_core/common/action_util.h"
 613               		.file 24 "quantum/send_string.h"
 614               		.file 25 "e:\\game\\msys2\\mingw64\\avr\\include\\stdlib.h"
 615               		.file 26 "quantum/debounce.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
C:\Users\Roningo\AppData\Local\Temp\cc13sgXl.s:2      *ABS*:000000000000003e __SP_H__
C:\Users\Roningo\AppData\Local\Temp\cc13sgXl.s:3      *ABS*:000000000000003d __SP_L__
C:\Users\Roningo\AppData\Local\Temp\cc13sgXl.s:4      *ABS*:000000000000003f __SREG__
C:\Users\Roningo\AppData\Local\Temp\cc13sgXl.s:5      *ABS*:0000000000000000 __tmp_reg__
C:\Users\Roningo\AppData\Local\Temp\cc13sgXl.s:6      *ABS*:0000000000000001 __zero_reg__
C:\Users\Roningo\AppData\Local\Temp\cc13sgXl.s:12     .text.setPinInputHigh_atomic:0000000000000000 setPinInputHigh_atomic
C:\Users\Roningo\AppData\Local\Temp\cc13sgXl.s:96     .text.matrix_init:0000000000000000 matrix_init
C:\Users\Roningo\AppData\Local\Temp\cc13sgXl.s:582    .rodata.row_pins:0000000000000000 row_pins
C:\Users\Roningo\AppData\Local\Temp\cc13sgXl.s:567    .rodata.col_pins:0000000000000000 col_pins
C:\Users\Roningo\AppData\Local\Temp\cc13sgXl.s:207    .text.matrix_scan:0000000000000000 matrix_scan

UNDEFINED SYMBOLS
raw_matrix
matrix
debounce_init
matrix_init_quantum
matrix_output_select_delay
matrix_output_unselect_delay
debounce
matrix_scan_quantum
__do_copy_data
