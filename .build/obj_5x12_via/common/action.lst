   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB15:
  15               		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "action_layer.h"
  24:tmk_core/common/action.c **** #include "action_tapping.h"
  25:tmk_core/common/action.c **** #include "action_macro.h"
  26:tmk_core/common/action.c **** #include "action_util.h"
  27:tmk_core/common/action.c **** #include "action.h"
  28:tmk_core/common/action.c **** #include "wait.h"
  29:tmk_core/common/action.c **** 
  30:tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
  31:tmk_core/common/action.c **** #    include "backlight.h"
  32:tmk_core/common/action.c **** #endif
  33:tmk_core/common/action.c **** 
  34:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  35:tmk_core/common/action.c **** #    include "debug.h"
  36:tmk_core/common/action.c **** #else
  37:tmk_core/common/action.c **** #    include "nodebug.h"
  38:tmk_core/common/action.c **** #endif
  39:tmk_core/common/action.c **** 
  40:tmk_core/common/action.c **** #ifdef POINTING_DEVICE_ENABLE
  41:tmk_core/common/action.c **** #    include "pointing_device.h"
  42:tmk_core/common/action.c **** #endif
  43:tmk_core/common/action.c **** 
  44:tmk_core/common/action.c **** int tp_buttons;
  45:tmk_core/common/action.c **** 
  46:tmk_core/common/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  47:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  48:tmk_core/common/action.c **** #endif
  49:tmk_core/common/action.c **** 
  50:tmk_core/common/action.c **** #ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
  51:tmk_core/common/action.c **** __attribute__((weak)) bool get_ignore_mod_tap_interrupt(uint16_t keycode, keyrecord_t *record) { re
  52:tmk_core/common/action.c **** #endif
  53:tmk_core/common/action.c **** 
  54:tmk_core/common/action.c **** #ifdef RETRO_TAPPING_PER_KEY
  55:tmk_core/common/action.c **** __attribute__((weak)) bool get_retro_tapping(uint16_t keycode, keyrecord_t *record) { return false;
  56:tmk_core/common/action.c **** #endif
  57:tmk_core/common/action.c **** 
  58:tmk_core/common/action.c **** #ifndef TAP_CODE_DELAY
  59:tmk_core/common/action.c **** #    define TAP_CODE_DELAY 0
  60:tmk_core/common/action.c **** #endif
  61:tmk_core/common/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  62:tmk_core/common/action.c **** #    define TAP_HOLD_CAPS_DELAY 80
  63:tmk_core/common/action.c **** #endif
  64:tmk_core/common/action.c **** /** \brief Called to execute an action.
  65:tmk_core/common/action.c ****  *
  66:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  67:tmk_core/common/action.c ****  */
  68:tmk_core/common/action.c **** void action_exec(keyevent_t event) {
  16               		.loc 1 68 36 view -0
  17               		.cfi_startproc
  18 0000 DF92      		push r13
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 13, -2
  22 0002 EF92      		push r14
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 14, -3
  26 0004 FF92      		push r15
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 15, -4
  30 0006 0F93      		push r16
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 16, -5
  34 0008 1F93      		push r17
  35               	.LCFI4:
  36               		.cfi_def_cfa_offset 7
  37               		.cfi_offset 17, -6
  38 000a CF93      		push r28
  39               	.LCFI5:
  40               		.cfi_def_cfa_offset 8
  41               		.cfi_offset 28, -7
  42 000c DF93      		push r29
  43               	.LCFI6:
  44               		.cfi_def_cfa_offset 9
  45               		.cfi_offset 29, -8
  46 000e CDB7      		in r28,__SP_L__
  47 0010 DEB7      		in r29,__SP_H__
  48               	.LCFI7:
  49               		.cfi_def_cfa_register 28
  50 0012 2B97      		sbiw r28,11
  51               	.LCFI8:
  52               		.cfi_def_cfa_offset 20
  53 0014 0FB6      		in __tmp_reg__,__SREG__
  54 0016 F894      		cli
  55 0018 DEBF      		out __SP_H__,r29
  56 001a 0FBE      		out __SREG__,__tmp_reg__
  57 001c CDBF      		out __SP_L__,r28
  58               	/* prologue: function */
  59               	/* frame size = 11 */
  60               	/* stack size = 18 */
  61               	.L__stack_usage = 18
  62 001e 7A87      		std Y+10,r23
  63 0020 8B87      		std Y+11,r24
  64 0022 F42E      		mov r15,r20
  65               	.LVL0:
  66               		.loc 1 68 36 is_stmt 0 view .LVU1
  67 0024 052F      		mov r16,r21
  68               	.LVL1:
  69               		.loc 1 68 36 view .LVU2
  70 0026 162F      		mov r17,r22
  71               	.LVL2:
  72               		.loc 1 68 36 view .LVU3
  73 0028 E72E      		mov r14,r23
  74 002a D82E      		mov r13,r24
  75               	.LVL3:
  69:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  76               		.loc 1 69 5 is_stmt 1 view .LVU4
  70:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  71:tmk_core/common/action.c ****         dprint("EVENT: ");
  72:tmk_core/common/action.c ****         debug_event(event);
  73:tmk_core/common/action.c ****         dprintln();
  77               		.loc 1 73 19 view .LVU5
  74:tmk_core/common/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  75:tmk_core/common/action.c ****         retro_tapping_counter++;
  76:tmk_core/common/action.c **** #endif
  77:tmk_core/common/action.c ****     }
  78:tmk_core/common/action.c **** 
  79:tmk_core/common/action.c ****     if (event.pressed) {
  78               		.loc 1 79 5 view .LVU6
  79               		.loc 1 79 8 is_stmt 0 view .LVU7
  80 002c 6111      		cpse r22,__zero_reg__
  80:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
  81:tmk_core/common/action.c ****         clear_weak_mods();
  81               		.loc 1 81 9 is_stmt 1 view .LVU8
  82 002e 0E94 0000 		call clear_weak_mods
  83               	.LVL4:
  84               	.L2:
  82:tmk_core/common/action.c ****     }
  83:tmk_core/common/action.c **** 
  84:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  85:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  86:tmk_core/common/action.c ****         process_hand_swap(&event);
  87:tmk_core/common/action.c ****     }
  88:tmk_core/common/action.c **** #endif
  89:tmk_core/common/action.c **** 
  90:tmk_core/common/action.c ****     keyrecord_t record = {.event = event};
  85               		.loc 1 90 5 view .LVU9
  86               		.loc 1 90 17 is_stmt 0 view .LVU10
  87 0032 1E82      		std Y+6,__zero_reg__
  88 0034 1D82      		std Y+5,__zero_reg__
  89 0036 7E2D      		mov r23,r14
  90 0038 EC82      		std Y+4,r14
  91 003a DD82      		std Y+5,r13
  91:tmk_core/common/action.c **** 
  92:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
  93:tmk_core/common/action.c **** #    if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  94:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  95:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  96:tmk_core/common/action.c ****     }
  97:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  98:tmk_core/common/action.c ****         clear_oneshot_mods();
  99:tmk_core/common/action.c ****     }
 100:tmk_core/common/action.c **** #        ifdef SWAP_HANDS_ENABLE
 101:tmk_core/common/action.c ****     if (has_oneshot_swaphands_timed_out()) {
 102:tmk_core/common/action.c ****         clear_oneshot_swaphands();
 103:tmk_core/common/action.c ****     }
 104:tmk_core/common/action.c **** #        endif
 105:tmk_core/common/action.c **** #    endif
 106:tmk_core/common/action.c **** #endif
 107:tmk_core/common/action.c **** 
 108:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 109:tmk_core/common/action.c ****     action_tapping_process(record);
  92               		.loc 1 109 5 is_stmt 1 view .LVU11
  93 003c 4F2D      		mov r20,r15
  94 003e 502F      		mov r21,r16
  95 0040 612F      		mov r22,r17
  96 0042 8D2D      		mov r24,r13
  97 0044 9E81      		ldd r25,Y+6
  98               	/* epilogue start */
 110:tmk_core/common/action.c **** #else
 111:tmk_core/common/action.c ****     process_record(&record);
 112:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
 113:tmk_core/common/action.c ****         dprint("processed: ");
 114:tmk_core/common/action.c ****         debug_record(record);
 115:tmk_core/common/action.c ****         dprintln();
 116:tmk_core/common/action.c ****     }
 117:tmk_core/common/action.c **** #endif
 118:tmk_core/common/action.c **** }
  99               		.loc 1 118 1 is_stmt 0 view .LVU12
 100 0046 2B96      		adiw r28,11
 101 0048 0FB6      		in __tmp_reg__,__SREG__
 102 004a F894      		cli
 103 004c DEBF      		out __SP_H__,r29
 104 004e 0FBE      		out __SREG__,__tmp_reg__
 105 0050 CDBF      		out __SP_L__,r28
 106 0052 DF91      		pop r29
 107 0054 CF91      		pop r28
 108 0056 1F91      		pop r17
 109               	.LVL5:
 110               		.loc 1 118 1 view .LVU13
 111 0058 0F91      		pop r16
 112               	.LVL6:
 113               		.loc 1 118 1 view .LVU14
 114 005a FF90      		pop r15
 115               	.LVL7:
 116               		.loc 1 118 1 view .LVU15
 117 005c EF90      		pop r14
 118               	.LVL8:
 119               		.loc 1 118 1 view .LVU16
 120 005e DF90      		pop r13
 121               	.LVL9:
 109:tmk_core/common/action.c **** #else
 122               		.loc 1 109 5 view .LVU17
 123 0060 0C94 0000 		jmp action_tapping_process
 124               	.LVL10:
 109:tmk_core/common/action.c **** #else
 125               		.loc 1 109 5 view .LVU18
 126               		.cfi_endproc
 127               	.LFE15:
 129               		.section	.text.process_record_quantum,"ax",@progbits
 130               		.weak	process_record_quantum
 132               	process_record_quantum:
 133               	.LVL11:
 134               	.LFB17:
 119:tmk_core/common/action.c **** 
 120:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 121:tmk_core/common/action.c **** bool swap_hands = false;
 122:tmk_core/common/action.c **** bool swap_held  = false;
 123:tmk_core/common/action.c **** 
 124:tmk_core/common/action.c **** /** \brief Process Hand Swap
 125:tmk_core/common/action.c ****  *
 126:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 127:tmk_core/common/action.c ****  */
 128:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 129:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 130:tmk_core/common/action.c **** 
 131:tmk_core/common/action.c ****     keypos_t         pos     = event->key;
 132:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
 133:tmk_core/common/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
 134:tmk_core/common/action.c **** 
 135:tmk_core/common/action.c ****     if (do_swap) {
 136:tmk_core/common/action.c ****         event->key.row = pgm_read_byte(&hand_swap_config[pos.row][pos.col].row);
 137:tmk_core/common/action.c ****         event->key.col = pgm_read_byte(&hand_swap_config[pos.row][pos.col].col);
 138:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 139:tmk_core/common/action.c ****     } else {
 140:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 141:tmk_core/common/action.c ****     }
 142:tmk_core/common/action.c **** }
 143:tmk_core/common/action.c **** #endif
 144:tmk_core/common/action.c **** 
 145:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 146:tmk_core/common/action.c **** bool disable_action_cache = false;
 147:tmk_core/common/action.c **** 
 148:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) {
 149:tmk_core/common/action.c ****     disable_action_cache = true;
 150:tmk_core/common/action.c ****     process_record(record);
 151:tmk_core/common/action.c ****     disable_action_cache = false;
 152:tmk_core/common/action.c **** }
 153:tmk_core/common/action.c **** #else
 154:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 155:tmk_core/common/action.c **** #endif
 156:tmk_core/common/action.c **** 
 157:tmk_core/common/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
 135               		.loc 1 157 72 is_stmt 1 view -0
 136               		.cfi_startproc
 137               	/* prologue: function */
 138               	/* frame size = 0 */
 139               	/* stack size = 0 */
 140               	.L__stack_usage = 0
 141               		.loc 1 157 74 view .LVU20
 142               		.loc 1 157 1 is_stmt 0 view .LVU21
 143 0000 81E0      		ldi r24,lo8(1)
 144               	.LVL12:
 145               	/* epilogue start */
 146               		.loc 1 157 1 view .LVU22
 147 0002 0895      		ret
 148               		.cfi_endproc
 149               	.LFE17:
 151               		.section	.text.post_process_record_quantum,"ax",@progbits
 152               		.weak	post_process_record_quantum
 154               	post_process_record_quantum:
 155               	.LVL13:
 156               	.LFB18:
 158:tmk_core/common/action.c **** 
 159:tmk_core/common/action.c **** __attribute__((weak)) void post_process_record_quantum(keyrecord_t *record) {}
 157               		.loc 1 159 77 is_stmt 1 view -0
 158               		.cfi_startproc
 159               	/* prologue: function */
 160               	/* frame size = 0 */
 161               	/* stack size = 0 */
 162               	.L__stack_usage = 0
 163               		.loc 1 159 78 view .LVU24
 164               	/* epilogue start */
 165               		.loc 1 159 1 is_stmt 0 view .LVU25
 166 0000 0895      		ret
 167               		.cfi_endproc
 168               	.LFE18:
 170               		.section	.text.process_record_tap_hint,"ax",@progbits
 171               	.global	process_record_tap_hint
 173               	process_record_tap_hint:
 174               	.LVL14:
 175               	.LFB19:
 160:tmk_core/common/action.c **** 
 161:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 162:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 163:tmk_core/common/action.c ****  *
 164:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 165:tmk_core/common/action.c ****  */
 166:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 176               		.loc 1 166 51 is_stmt 1 view -0
 177               		.cfi_startproc
 178               	/* prologue: function */
 179               	/* frame size = 0 */
 180               	/* stack size = 0 */
 181               	.L__stack_usage = 0
 167:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 182               		.loc 1 167 5 view .LVU27
 183               		.loc 1 167 23 is_stmt 0 view .LVU28
 184 0000 FC01      		movw r30,r24
 185 0002 8081      		ld r24,Z
 186 0004 9181      		ldd r25,Z+1
 187               	.LVL15:
 188               		.loc 1 167 23 view .LVU29
 189 0006 0C94 0000 		jmp layer_switch_get_action
 190               	.LVL16:
 191               		.loc 1 167 23 view .LVU30
 192               		.cfi_endproc
 193               	.LFE19:
 195               		.section	.text.register_code,"ax",@progbits
 196               	.global	register_code
 198               	register_code:
 199               	.LVL17:
 200               	.LFB23:
 168:tmk_core/common/action.c **** 
 169:tmk_core/common/action.c ****     switch (action.kind.id) {
 170:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 171:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 172:tmk_core/common/action.c ****             switch (action.swap.code) {
 173:tmk_core/common/action.c ****                 case OP_SH_ONESHOT:
 174:tmk_core/common/action.c ****                     break;
 175:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 176:tmk_core/common/action.c ****                 default:
 177:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 178:tmk_core/common/action.c ****                     swap_held  = true;
 179:tmk_core/common/action.c ****             }
 180:tmk_core/common/action.c ****             break;
 181:tmk_core/common/action.c **** #    endif
 182:tmk_core/common/action.c ****     }
 183:tmk_core/common/action.c **** }
 184:tmk_core/common/action.c **** #endif
 185:tmk_core/common/action.c **** 
 186:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 187:tmk_core/common/action.c ****  *
 188:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 189:tmk_core/common/action.c ****  */
 190:tmk_core/common/action.c **** void process_record(keyrecord_t *record) {
 191:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 192:tmk_core/common/action.c ****         return;
 193:tmk_core/common/action.c ****     }
 194:tmk_core/common/action.c **** 
 195:tmk_core/common/action.c ****     if (!process_record_quantum(record)) {
 196:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 197:tmk_core/common/action.c ****         if (is_oneshot_layer_active() && record->event.pressed) {
 198:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 199:tmk_core/common/action.c ****         }
 200:tmk_core/common/action.c **** #endif
 201:tmk_core/common/action.c ****         return;
 202:tmk_core/common/action.c ****     }
 203:tmk_core/common/action.c **** 
 204:tmk_core/common/action.c ****     process_record_handler(record);
 205:tmk_core/common/action.c ****     post_process_record_quantum(record);
 206:tmk_core/common/action.c **** }
 207:tmk_core/common/action.c **** 
 208:tmk_core/common/action.c **** void process_record_handler(keyrecord_t *record) {
 209:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 210:tmk_core/common/action.c ****     dprint("ACTION: ");
 211:tmk_core/common/action.c ****     debug_action(action);
 212:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 213:tmk_core/common/action.c ****     dprint(" layer_state: ");
 214:tmk_core/common/action.c ****     layer_debug();
 215:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 216:tmk_core/common/action.c ****     default_layer_debug();
 217:tmk_core/common/action.c **** #endif
 218:tmk_core/common/action.c ****     dprintln();
 219:tmk_core/common/action.c **** 
 220:tmk_core/common/action.c ****     process_action(record, action);
 221:tmk_core/common/action.c **** }
 222:tmk_core/common/action.c **** 
 223:tmk_core/common/action.c **** #if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 224:tmk_core/common/action.c **** void register_button(bool pressed, enum mouse_buttons button) {
 225:tmk_core/common/action.c **** #    ifdef PS2_MOUSE_ENABLE
 226:tmk_core/common/action.c ****     tp_buttons = pressed ? tp_buttons | button : tp_buttons & ~button;
 227:tmk_core/common/action.c **** #    endif
 228:tmk_core/common/action.c **** #    ifdef POINTING_DEVICE_ENABLE
 229:tmk_core/common/action.c ****     report_mouse_t currentReport = pointing_device_get_report();
 230:tmk_core/common/action.c ****     currentReport.buttons        = pressed ? currentReport.buttons | button : currentReport.buttons
 231:tmk_core/common/action.c ****     pointing_device_set_report(currentReport);
 232:tmk_core/common/action.c **** #    endif
 233:tmk_core/common/action.c **** }
 234:tmk_core/common/action.c **** #endif
 235:tmk_core/common/action.c **** 
 236:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 237:tmk_core/common/action.c ****  *
 238:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 239:tmk_core/common/action.c ****  */
 240:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action) {
 241:tmk_core/common/action.c ****     keyevent_t event = record->event;
 242:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 243:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 244:tmk_core/common/action.c **** #endif
 245:tmk_core/common/action.c **** 
 246:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 247:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 248:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 249:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && (action.kind.id == ACT_USAGE || !IS_MOD(actio
 250:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 251:tmk_core/common/action.c ****         && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)
 252:tmk_core/common/action.c **** #    endif
 253:tmk_core/common/action.c ****     ) {
 254:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 255:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 256:tmk_core/common/action.c ****     }
 257:tmk_core/common/action.c **** #endif
 258:tmk_core/common/action.c **** 
 259:tmk_core/common/action.c ****     switch (action.kind.id) {
 260:tmk_core/common/action.c ****         /* Key and Mods */
 261:tmk_core/common/action.c ****         case ACT_LMODS:
 262:tmk_core/common/action.c ****         case ACT_RMODS: {
 263:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 264:tmk_core/common/action.c ****             if (event.pressed) {
 265:tmk_core/common/action.c ****                 if (mods) {
 266:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 267:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 268:tmk_core/common/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 269:tmk_core/common/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 270:tmk_core/common/action.c ****                         add_mods(mods);
 271:tmk_core/common/action.c ****                     } else {
 272:tmk_core/common/action.c ****                         add_weak_mods(mods);
 273:tmk_core/common/action.c ****                     }
 274:tmk_core/common/action.c ****                     send_keyboard_report();
 275:tmk_core/common/action.c ****                 }
 276:tmk_core/common/action.c ****                 register_code(action.key.code);
 277:tmk_core/common/action.c ****             } else {
 278:tmk_core/common/action.c ****                 unregister_code(action.key.code);
 279:tmk_core/common/action.c ****                 if (mods) {
 280:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 281:tmk_core/common/action.c ****                         del_mods(mods);
 282:tmk_core/common/action.c ****                     } else {
 283:tmk_core/common/action.c ****                         del_weak_mods(mods);
 284:tmk_core/common/action.c ****                     }
 285:tmk_core/common/action.c ****                     send_keyboard_report();
 286:tmk_core/common/action.c ****                 }
 287:tmk_core/common/action.c ****             }
 288:tmk_core/common/action.c ****         } break;
 289:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 290:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 291:tmk_core/common/action.c ****         case ACT_RMODS_TAP: {
 292:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 293:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 294:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 295:tmk_core/common/action.c ****                 case MODS_ONESHOT:
 296:tmk_core/common/action.c ****                     // Oneshot modifier
 297:tmk_core/common/action.c ****                     if (event.pressed) {
 298:tmk_core/common/action.c ****                         if (tap_count == 0) {
 299:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 300:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 301:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 302:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 303:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 304:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 305:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 306:tmk_core/common/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 307:tmk_core/common/action.c ****                             clear_oneshot_mods();
 308:tmk_core/common/action.c ****                             set_oneshot_locked_mods(mods);
 309:tmk_core/common/action.c ****                             register_mods(mods);
 310:tmk_core/common/action.c **** #        endif
 311:tmk_core/common/action.c ****                         } else {
 312:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 313:tmk_core/common/action.c ****                         }
 314:tmk_core/common/action.c ****                     } else {
 315:tmk_core/common/action.c ****                         if (tap_count == 0) {
 316:tmk_core/common/action.c ****                             clear_oneshot_mods();
 317:tmk_core/common/action.c ****                             unregister_mods(mods);
 318:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 319:tmk_core/common/action.c ****                             // Retain Oneshot mods
 320:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 321:tmk_core/common/action.c ****                             if (mods & get_mods()) {
 322:tmk_core/common/action.c ****                                 clear_oneshot_locked_mods();
 323:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 324:tmk_core/common/action.c ****                                 unregister_mods(mods);
 325:tmk_core/common/action.c ****                             }
 326:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 327:tmk_core/common/action.c ****                             // Toggle Oneshot Layer
 328:tmk_core/common/action.c **** #        endif
 329:tmk_core/common/action.c ****                         } else {
 330:tmk_core/common/action.c ****                             clear_oneshot_mods();
 331:tmk_core/common/action.c ****                             unregister_mods(mods);
 332:tmk_core/common/action.c ****                         }
 333:tmk_core/common/action.c ****                     }
 334:tmk_core/common/action.c ****                     break;
 335:tmk_core/common/action.c **** #    endif
 336:tmk_core/common/action.c ****                 case MODS_TAP_TOGGLE:
 337:tmk_core/common/action.c ****                     if (event.pressed) {
 338:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 339:tmk_core/common/action.c ****                             register_mods(mods);
 340:tmk_core/common/action.c ****                         }
 341:tmk_core/common/action.c ****                     } else {
 342:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 343:tmk_core/common/action.c ****                             unregister_mods(mods);
 344:tmk_core/common/action.c ****                         }
 345:tmk_core/common/action.c ****                     }
 346:tmk_core/common/action.c ****                     break;
 347:tmk_core/common/action.c ****                 default:
 348:tmk_core/common/action.c ****                     if (event.pressed) {
 349:tmk_core/common/action.c ****                         if (tap_count > 0) {
 350:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 351:tmk_core/common/action.c ****                             if (
 352:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 353:tmk_core/common/action.c ****                                 !get_ignore_mod_tap_interrupt(get_event_keycode(record->event, fals
 354:tmk_core/common/action.c **** #        endif
 355:tmk_core/common/action.c ****                                 record->tap.interrupted) {
 356:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 357:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 358:tmk_core/common/action.c ****                                 record->tap.count = 0;
 359:tmk_core/common/action.c ****                                 register_mods(mods);
 360:tmk_core/common/action.c ****                             } else
 361:tmk_core/common/action.c **** #    endif
 362:tmk_core/common/action.c ****                             {
 363:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 364:tmk_core/common/action.c ****                                 register_code(action.key.code);
 365:tmk_core/common/action.c ****                             }
 366:tmk_core/common/action.c ****                         } else {
 367:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 368:tmk_core/common/action.c ****                             register_mods(mods);
 369:tmk_core/common/action.c ****                         }
 370:tmk_core/common/action.c ****                     } else {
 371:tmk_core/common/action.c ****                         if (tap_count > 0) {
 372:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 373:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 374:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 375:tmk_core/common/action.c ****                             } else {
 376:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 377:tmk_core/common/action.c ****                             }
 378:tmk_core/common/action.c ****                             unregister_code(action.key.code);
 379:tmk_core/common/action.c ****                         } else {
 380:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 381:tmk_core/common/action.c ****                             unregister_mods(mods);
 382:tmk_core/common/action.c ****                         }
 383:tmk_core/common/action.c ****                     }
 384:tmk_core/common/action.c ****                     break;
 385:tmk_core/common/action.c ****             }
 386:tmk_core/common/action.c ****         } break;
 387:tmk_core/common/action.c **** #endif
 388:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 389:tmk_core/common/action.c ****         /* other HID usage */
 390:tmk_core/common/action.c ****         case ACT_USAGE:
 391:tmk_core/common/action.c ****             switch (action.usage.page) {
 392:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 393:tmk_core/common/action.c ****                     if (event.pressed) {
 394:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 395:tmk_core/common/action.c ****                     } else {
 396:tmk_core/common/action.c ****                         host_system_send(0);
 397:tmk_core/common/action.c ****                     }
 398:tmk_core/common/action.c ****                     break;
 399:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 400:tmk_core/common/action.c ****                     if (event.pressed) {
 401:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 402:tmk_core/common/action.c ****                     } else {
 403:tmk_core/common/action.c ****                         host_consumer_send(0);
 404:tmk_core/common/action.c ****                     }
 405:tmk_core/common/action.c ****                     break;
 406:tmk_core/common/action.c ****             }
 407:tmk_core/common/action.c ****             break;
 408:tmk_core/common/action.c **** #endif
 409:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 410:tmk_core/common/action.c ****         /* Mouse key */
 411:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 412:tmk_core/common/action.c ****             if (event.pressed) {
 413:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 414:tmk_core/common/action.c ****             } else {
 415:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 416:tmk_core/common/action.c ****             }
 417:tmk_core/common/action.c ****             switch (action.key.code) {
 418:tmk_core/common/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 419:tmk_core/common/action.c **** #        ifdef POINTING_DEVICE_ENABLE
 420:tmk_core/common/action.c ****                 case KC_MS_BTN1 ... KC_MS_BTN8:
 421:tmk_core/common/action.c **** #        else
 422:tmk_core/common/action.c ****                 case KC_MS_BTN1 ... KC_MS_BTN3:
 423:tmk_core/common/action.c **** #        endif
 424:tmk_core/common/action.c ****                     register_button(event.pressed, MOUSE_BTN_MASK(action.key.code - KC_MS_BTN1));
 425:tmk_core/common/action.c ****                     break;
 426:tmk_core/common/action.c **** #    endif
 427:tmk_core/common/action.c ****                 default:
 428:tmk_core/common/action.c ****                     mousekey_send();
 429:tmk_core/common/action.c ****                     break;
 430:tmk_core/common/action.c ****             }
 431:tmk_core/common/action.c ****             break;
 432:tmk_core/common/action.c **** #endif
 433:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 434:tmk_core/common/action.c ****         case ACT_LAYER:
 435:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 436:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 437:tmk_core/common/action.c ****                 if (!event.pressed) {
 438:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 439:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 440:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 441:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 442:tmk_core/common/action.c ****                         case OP_BIT_AND:
 443:tmk_core/common/action.c ****                             default_layer_and(bits | mask);
 444:tmk_core/common/action.c ****                             break;
 445:tmk_core/common/action.c ****                         case OP_BIT_OR:
 446:tmk_core/common/action.c ****                             default_layer_or(bits | mask);
 447:tmk_core/common/action.c ****                             break;
 448:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 449:tmk_core/common/action.c ****                             default_layer_xor(bits | mask);
 450:tmk_core/common/action.c ****                             break;
 451:tmk_core/common/action.c ****                         case OP_BIT_SET:
 452:tmk_core/common/action.c ****                             default_layer_set(bits | mask);
 453:tmk_core/common/action.c ****                             break;
 454:tmk_core/common/action.c ****                     }
 455:tmk_core/common/action.c ****                 }
 456:tmk_core/common/action.c ****             } else {
 457:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 458:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 459:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 460:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 461:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 462:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 463:tmk_core/common/action.c ****                         case OP_BIT_AND:
 464:tmk_core/common/action.c ****                             layer_and(bits | mask);
 465:tmk_core/common/action.c ****                             break;
 466:tmk_core/common/action.c ****                         case OP_BIT_OR:
 467:tmk_core/common/action.c ****                             layer_or(bits | mask);
 468:tmk_core/common/action.c ****                             break;
 469:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 470:tmk_core/common/action.c ****                             layer_xor(bits | mask);
 471:tmk_core/common/action.c ****                             break;
 472:tmk_core/common/action.c ****                         case OP_BIT_SET:
 473:tmk_core/common/action.c ****                             layer_state_set(bits | mask);
 474:tmk_core/common/action.c ****                             break;
 475:tmk_core/common/action.c ****                     }
 476:tmk_core/common/action.c ****                 }
 477:tmk_core/common/action.c ****             }
 478:tmk_core/common/action.c ****             break;
 479:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 480:tmk_core/common/action.c ****             if (event.pressed) {
 481:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 482:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 483:tmk_core/common/action.c ****             } else {
 484:tmk_core/common/action.c ****                 unregister_mods(action.layer_mods.mods);
 485:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 486:tmk_core/common/action.c ****             }
 487:tmk_core/common/action.c ****             break;
 488:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 489:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 490:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 491:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 492:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 493:tmk_core/common/action.c ****                     /* tap toggle */
 494:tmk_core/common/action.c ****                     if (event.pressed) {
 495:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 496:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 497:tmk_core/common/action.c ****                         }
 498:tmk_core/common/action.c ****                     } else {
 499:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 500:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 501:tmk_core/common/action.c ****                         }
 502:tmk_core/common/action.c ****                     }
 503:tmk_core/common/action.c ****                     break;
 504:tmk_core/common/action.c ****                 case OP_ON_OFF:
 505:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 506:tmk_core/common/action.c ****                     break;
 507:tmk_core/common/action.c ****                 case OP_OFF_ON:
 508:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 509:tmk_core/common/action.c ****                     break;
 510:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 511:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 512:tmk_core/common/action.c ****                     break;
 513:tmk_core/common/action.c **** #        ifndef NO_ACTION_ONESHOT
 514:tmk_core/common/action.c ****                 case OP_ONESHOT:
 515:tmk_core/common/action.c ****                     // Oneshot modifier
 516:tmk_core/common/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 517:tmk_core/common/action.c ****                     do_release_oneshot = false;
 518:tmk_core/common/action.c ****                     if (event.pressed) {
 519:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 520:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 521:tmk_core/common/action.c ****                             reset_oneshot_layer();
 522:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 523:tmk_core/common/action.c ****                             break;
 524:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 525:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 526:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 527:tmk_core/common/action.c ****                         }
 528:tmk_core/common/action.c ****                     } else {
 529:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 530:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 531:tmk_core/common/action.c ****                             reset_oneshot_layer();
 532:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 533:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 534:tmk_core/common/action.c ****                         } else {
 535:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 536:tmk_core/common/action.c ****                         }
 537:tmk_core/common/action.c ****                     }
 538:tmk_core/common/action.c **** #            else
 539:tmk_core/common/action.c ****                     if (event.pressed) {
 540:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 541:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 542:tmk_core/common/action.c ****                     } else {
 543:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 544:tmk_core/common/action.c ****                         if (tap_count > 1) {
 545:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 546:tmk_core/common/action.c ****                         }
 547:tmk_core/common/action.c ****                     }
 548:tmk_core/common/action.c **** #            endif
 549:tmk_core/common/action.c ****                     break;
 550:tmk_core/common/action.c **** #        endif
 551:tmk_core/common/action.c ****                 default:
 552:tmk_core/common/action.c ****                     /* tap key */
 553:tmk_core/common/action.c ****                     if (event.pressed) {
 554:tmk_core/common/action.c ****                         if (tap_count > 0) {
 555:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 556:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 557:tmk_core/common/action.c ****                         } else {
 558:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 559:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 560:tmk_core/common/action.c ****                         }
 561:tmk_core/common/action.c ****                     } else {
 562:tmk_core/common/action.c ****                         if (tap_count > 0) {
 563:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 564:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 565:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 566:tmk_core/common/action.c ****                             } else {
 567:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 568:tmk_core/common/action.c ****                             }
 569:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 570:tmk_core/common/action.c ****                         } else {
 571:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 572:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 573:tmk_core/common/action.c ****                         }
 574:tmk_core/common/action.c ****                     }
 575:tmk_core/common/action.c ****                     break;
 576:tmk_core/common/action.c ****             }
 577:tmk_core/common/action.c ****             break;
 578:tmk_core/common/action.c **** #    endif
 579:tmk_core/common/action.c **** #endif
 580:tmk_core/common/action.c ****             /* Extentions */
 581:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 582:tmk_core/common/action.c ****         case ACT_MACRO:
 583:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 584:tmk_core/common/action.c ****             break;
 585:tmk_core/common/action.c **** #endif
 586:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 587:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 588:tmk_core/common/action.c ****             switch (action.swap.code) {
 589:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 590:tmk_core/common/action.c ****                     if (event.pressed) {
 591:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 592:tmk_core/common/action.c ****                     }
 593:tmk_core/common/action.c ****                     break;
 594:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 595:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 596:tmk_core/common/action.c ****                     break;
 597:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 598:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 599:tmk_core/common/action.c ****                     break;
 600:tmk_core/common/action.c ****                 case OP_SH_ON:
 601:tmk_core/common/action.c ****                     if (!event.pressed) {
 602:tmk_core/common/action.c ****                         swap_hands = true;
 603:tmk_core/common/action.c ****                     }
 604:tmk_core/common/action.c ****                     break;
 605:tmk_core/common/action.c ****                 case OP_SH_OFF:
 606:tmk_core/common/action.c ****                     if (!event.pressed) {
 607:tmk_core/common/action.c ****                         swap_hands = false;
 608:tmk_core/common/action.c ****                     }
 609:tmk_core/common/action.c ****                     break;
 610:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 611:tmk_core/common/action.c ****                 case OP_SH_ONESHOT:
 612:tmk_core/common/action.c ****                     if (event.pressed) {
 613:tmk_core/common/action.c ****                         set_oneshot_swaphands();
 614:tmk_core/common/action.c ****                     } else {
 615:tmk_core/common/action.c ****                         release_oneshot_swaphands();
 616:tmk_core/common/action.c ****                     }
 617:tmk_core/common/action.c ****                     break;
 618:tmk_core/common/action.c **** #    endif
 619:tmk_core/common/action.c **** 
 620:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 621:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 622:tmk_core/common/action.c ****                     /* tap toggle */
 623:tmk_core/common/action.c **** 
 624:tmk_core/common/action.c ****                     if (event.pressed) {
 625:tmk_core/common/action.c ****                         if (swap_held) {
 626:tmk_core/common/action.c ****                             swap_held = false;
 627:tmk_core/common/action.c ****                         } else {
 628:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 629:tmk_core/common/action.c ****                         }
 630:tmk_core/common/action.c ****                     } else {
 631:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 632:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 633:tmk_core/common/action.c ****                         }
 634:tmk_core/common/action.c ****                     }
 635:tmk_core/common/action.c ****                     break;
 636:tmk_core/common/action.c ****                 default:
 637:tmk_core/common/action.c ****                     /* tap key */
 638:tmk_core/common/action.c ****                     if (tap_count > 0) {
 639:tmk_core/common/action.c ****                         if (swap_held) {
 640:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 641:tmk_core/common/action.c ****                             swap_held  = false;
 642:tmk_core/common/action.c ****                         }
 643:tmk_core/common/action.c ****                         if (event.pressed) {
 644:tmk_core/common/action.c ****                             register_code(action.swap.code);
 645:tmk_core/common/action.c ****                         } else {
 646:tmk_core/common/action.c ****                             wait_ms(TAP_CODE_DELAY);
 647:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 648:tmk_core/common/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 649:tmk_core/common/action.c ****                         }
 650:tmk_core/common/action.c ****                     } else {
 651:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 652:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 653:tmk_core/common/action.c ****                             swap_held  = false;
 654:tmk_core/common/action.c ****                         }
 655:tmk_core/common/action.c ****                     }
 656:tmk_core/common/action.c **** #    endif
 657:tmk_core/common/action.c ****             }
 658:tmk_core/common/action.c **** #endif
 659:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 660:tmk_core/common/action.c ****         case ACT_FUNCTION:
 661:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 662:tmk_core/common/action.c ****             break;
 663:tmk_core/common/action.c **** #endif
 664:tmk_core/common/action.c ****         default:
 665:tmk_core/common/action.c ****             break;
 666:tmk_core/common/action.c ****     }
 667:tmk_core/common/action.c **** 
 668:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 669:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 670:tmk_core/common/action.c ****     switch (action.kind.id) {
 671:tmk_core/common/action.c ****         case ACT_LAYER:
 672:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 673:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 674:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 675:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 676:tmk_core/common/action.c **** #    endif
 677:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 678:tmk_core/common/action.c ****             break;
 679:tmk_core/common/action.c ****         default:
 680:tmk_core/common/action.c ****             break;
 681:tmk_core/common/action.c ****     }
 682:tmk_core/common/action.c **** #endif
 683:tmk_core/common/action.c **** 
 684:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 685:tmk_core/common/action.c **** #    if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
 686:tmk_core/common/action.c ****     if (!is_tap_action(action)) {
 687:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 688:tmk_core/common/action.c ****     } else {
 689:tmk_core/common/action.c ****         if (event.pressed) {
 690:tmk_core/common/action.c ****             if (tap_count > 0) {
 691:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 692:tmk_core/common/action.c ****             }
 693:tmk_core/common/action.c ****         } else {
 694:tmk_core/common/action.c ****             if (tap_count > 0) {
 695:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 696:tmk_core/common/action.c ****             } else {
 697:tmk_core/common/action.c ****                 if (
 698:tmk_core/common/action.c **** #        ifdef RETRO_TAPPING_PER_KEY
 699:tmk_core/common/action.c ****                     get_retro_tapping(get_event_keycode(record->event, false), record) &&
 700:tmk_core/common/action.c **** #        endif
 701:tmk_core/common/action.c ****                     retro_tapping_counter == 2) {
 702:tmk_core/common/action.c ****                     tap_code(action.layer_tap.code);
 703:tmk_core/common/action.c ****                 }
 704:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 705:tmk_core/common/action.c ****             }
 706:tmk_core/common/action.c ****         }
 707:tmk_core/common/action.c ****     }
 708:tmk_core/common/action.c **** #    endif
 709:tmk_core/common/action.c **** #endif
 710:tmk_core/common/action.c **** 
 711:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 712:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 713:tmk_core/common/action.c ****     if (event.pressed && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)) 
 714:tmk_core/common/action.c ****         use_oneshot_swaphands();
 715:tmk_core/common/action.c ****     }
 716:tmk_core/common/action.c **** #    endif
 717:tmk_core/common/action.c **** #endif
 718:tmk_core/common/action.c **** 
 719:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 720:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 721:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 722:tmk_core/common/action.c ****      */
 723:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 724:tmk_core/common/action.c ****         record->event.pressed = false;
 725:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 726:tmk_core/common/action.c ****         process_record(record);
 727:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 728:tmk_core/common/action.c ****     }
 729:tmk_core/common/action.c **** #endif
 730:tmk_core/common/action.c **** }
 731:tmk_core/common/action.c **** 
 732:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 733:tmk_core/common/action.c ****  *
 734:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 735:tmk_core/common/action.c ****  */
 736:tmk_core/common/action.c **** void register_code(uint8_t code) {
 201               		.loc 1 736 34 is_stmt 1 view -0
 202               		.cfi_startproc
 203               		.loc 1 736 34 is_stmt 0 view .LVU32
 204 0000 CF93      		push r28
 205               	.LCFI9:
 206               		.cfi_def_cfa_offset 3
 207               		.cfi_offset 28, -2
 208               	/* prologue: function */
 209               	/* frame size = 0 */
 210               	/* stack size = 1 */
 211               	.L__stack_usage = 1
 212 0002 C82F      		mov r28,r24
 737:tmk_core/common/action.c ****     if (code == KC_NO) {
 213               		.loc 1 737 5 is_stmt 1 view .LVU33
 214               		.loc 1 737 8 is_stmt 0 view .LVU34
 215 0004 8823      		tst r24
 216 0006 01F4      		brne .+2
 217 0008 00C0      		rjmp .L9
 738:tmk_core/common/action.c ****         return;
 739:tmk_core/common/action.c ****     }
 740:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 741:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 218               		.loc 1 741 10 is_stmt 1 view .LVU35
 219               		.loc 1 741 13 is_stmt 0 view .LVU36
 220 000a 8238      		cpi r24,lo8(-126)
 221 000c 01F4      		brne .L12
 742:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 743:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 744:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 222               		.loc 1 744 9 is_stmt 1 view .LVU37
 223               		.loc 1 744 13 is_stmt 0 view .LVU38
 224 000e 0E94 0000 		call host_keyboard_leds
 225               	.LVL18:
 226               		.loc 1 744 12 view .LVU39
 227 0012 81FD      		sbrc r24,1
 228 0014 00C0      		rjmp .L9
 745:tmk_core/common/action.c **** #    endif
 746:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 229               		.loc 1 746 9 is_stmt 1 view .LVU40
 230 0016 89E3      		ldi r24,lo8(57)
 231 0018 0E94 0000 		call add_key
 232               	.LVL19:
 747:tmk_core/common/action.c ****         send_keyboard_report();
 233               		.loc 1 747 9 view .LVU41
 234 001c 0E94 0000 		call send_keyboard_report
 235               	.LVL20:
 748:tmk_core/common/action.c ****         wait_ms(100);
 236               		.loc 1 748 9 view .LVU42
 237               	.LBB33:
 238               	.LBI33:
 239               		.file 2 "e:\\game\\msys2\\mingw64\\avr\\include\\util\\delay.h"
   1:e:\game\msys2\mingw64\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:e:\game\msys2\mingw64\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:e:\game\msys2\mingw64\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:e:\game\msys2\mingw64\avr\include\util\delay.h ****    All rights reserved.
   5:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
   6:e:\game\msys2\mingw64\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:e:\game\msys2\mingw64\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
   9:e:\game\msys2\mingw64\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:e:\game\msys2\mingw64\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  12:e:\game\msys2\mingw64\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:e:\game\msys2\mingw64\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:e:\game\msys2\mingw64\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:e:\game\msys2\mingw64\avr\include\util\delay.h ****      distribution.
  16:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  17:e:\game\msys2\mingw64\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:e:\game\msys2\mingw64\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:e:\game\msys2\mingw64\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  21:e:\game\msys2\mingw64\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:e:\game\msys2\mingw64\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:e:\game\msys2\mingw64\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:e:\game\msys2\mingw64\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:e:\game\msys2\mingw64\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:e:\game\msys2\mingw64\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:e:\game\msys2\mingw64\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:e:\game\msys2\mingw64\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:e:\game\msys2\mingw64\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:e:\game\msys2\mingw64\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:e:\game\msys2\mingw64\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  33:e:\game\msys2\mingw64\avr\include\util\delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  35:e:\game\msys2\mingw64\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:e:\game\msys2\mingw64\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  38:e:\game\msys2\mingw64\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:e:\game\msys2\mingw64\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:e:\game\msys2\mingw64\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:e:\game\msys2\mingw64\avr\include\util\delay.h **** #  endif
  42:e:\game\msys2\mingw64\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  44:e:\game\msys2\mingw64\avr\include\util\delay.h **** #include <inttypes.h>
  45:e:\game\msys2\mingw64\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:e:\game\msys2\mingw64\avr\include\util\delay.h **** #include <math.h>
  47:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  48:e:\game\msys2\mingw64\avr\include\util\delay.h **** /** \file */
  49:e:\game\msys2\mingw64\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:e:\game\msys2\mingw64\avr\include\util\delay.h ****     \code
  51:e:\game\msys2\mingw64\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:e:\game\msys2\mingw64\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:e:\game\msys2\mingw64\avr\include\util\delay.h ****     #include <util/delay.h>
  54:e:\game\msys2\mingw64\avr\include\util\delay.h ****     \endcode
  55:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  56:e:\game\msys2\mingw64\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:e:\game\msys2\mingw64\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:e:\game\msys2\mingw64\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:e:\game\msys2\mingw64\avr\include\util\delay.h ****     used.
  60:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  61:e:\game\msys2\mingw64\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:e:\game\msys2\mingw64\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:e:\game\msys2\mingw64\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:e:\game\msys2\mingw64\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:e:\game\msys2\mingw64\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:e:\game\msys2\mingw64\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:e:\game\msys2\mingw64\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:e:\game\msys2\mingw64\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  70:e:\game\msys2\mingw64\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:e:\game\msys2\mingw64\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:e:\game\msys2\mingw64\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:e:\game\msys2\mingw64\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:e:\game\msys2\mingw64\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:e:\game\msys2\mingw64\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:e:\game\msys2\mingw64\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:e:\game\msys2\mingw64\avr\include\util\delay.h ****     routines linked into the application.
  78:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  79:e:\game\msys2\mingw64\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:e:\game\msys2\mingw64\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:e:\game\msys2\mingw64\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  83:e:\game\msys2\mingw64\avr\include\util\delay.h **** */
  84:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  85:e:\game\msys2\mingw64\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:e:\game\msys2\mingw64\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:e:\game\msys2\mingw64\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:e:\game\msys2\mingw64\avr\include\util\delay.h **** #endif
  89:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  90:e:\game\msys2\mingw64\avr\include\util\delay.h **** #ifndef F_CPU
  91:e:\game\msys2\mingw64\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:e:\game\msys2\mingw64\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:e:\game\msys2\mingw64\avr\include\util\delay.h **** /** \ingroup util_delay
  94:e:\game\msys2\mingw64\avr\include\util\delay.h ****     \def F_CPU
  95:e:\game\msys2\mingw64\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
  97:e:\game\msys2\mingw64\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:e:\game\msys2\mingw64\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:e:\game\msys2\mingw64\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:e:\game\msys2\mingw64\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:e:\game\msys2\mingw64\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 103:e:\game\msys2\mingw64\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:e:\game\msys2\mingw64\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:e:\game\msys2\mingw64\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:e:\game\msys2\mingw64\avr\include\util\delay.h ****     integer value.
 107:e:\game\msys2\mingw64\avr\include\util\delay.h ****  */
 108:e:\game\msys2\mingw64\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:e:\game\msys2\mingw64\avr\include\util\delay.h **** #endif
 110:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 111:e:\game\msys2\mingw64\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:e:\game\msys2\mingw64\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:e:\game\msys2\mingw64\avr\include\util\delay.h **** #endif
 114:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 115:e:\game\msys2\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:e:\game\msys2\mingw64\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:e:\game\msys2\mingw64\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:e:\game\msys2\mingw64\avr\include\util\delay.h **** #  include <math.h>
 119:e:\game\msys2\mingw64\avr\include\util\delay.h **** #endif
 120:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 121:e:\game\msys2\mingw64\avr\include\util\delay.h **** /**
 122:e:\game\msys2\mingw64\avr\include\util\delay.h ****    \ingroup util_delay
 123:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 124:e:\game\msys2\mingw64\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 126:e:\game\msys2\mingw64\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:e:\game\msys2\mingw64\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 129:e:\game\msys2\mingw64\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 131:e:\game\msys2\mingw64\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:e:\game\msys2\mingw64\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:e:\game\msys2\mingw64\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:e:\game\msys2\mingw64\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:e:\game\msys2\mingw64\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 137:e:\game\msys2\mingw64\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:e:\game\msys2\mingw64\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:e:\game\msys2\mingw64\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:e:\game\msys2\mingw64\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 142:e:\game\msys2\mingw64\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:e:\game\msys2\mingw64\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:e:\game\msys2\mingw64\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:e:\game\msys2\mingw64\avr\include\util\delay.h ****    microseconds of delay.
 146:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 147:e:\game\msys2\mingw64\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:e:\game\msys2\mingw64\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:e:\game\msys2\mingw64\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:e:\game\msys2\mingw64\avr\include\util\delay.h ****    respectively.
 151:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 152:e:\game\msys2\mingw64\avr\include\util\delay.h ****    \note
 153:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 154:e:\game\msys2\mingw64\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:e:\game\msys2\mingw64\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:e:\game\msys2\mingw64\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:e:\game\msys2\mingw64\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:e:\game\msys2\mingw64\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:e:\game\msys2\mingw64\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:e:\game\msys2\mingw64\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:e:\game\msys2\mingw64\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:e:\game\msys2\mingw64\avr\include\util\delay.h ****    not available to the compiler then.
 163:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 164:e:\game\msys2\mingw64\avr\include\util\delay.h ****  */
 165:e:\game\msys2\mingw64\avr\include\util\delay.h **** void
 166:e:\game\msys2\mingw64\avr\include\util\delay.h **** _delay_ms(double __ms)
 240               		.loc 2 166 1 view .LVU43
 241               	.LBB34:
 167:e:\game\msys2\mingw64\avr\include\util\delay.h **** {
 168:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	double __tmp ;
 242               		.loc 2 168 2 view .LVU44
 169:e:\game\msys2\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:e:\game\msys2\mingw64\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:e:\game\msys2\mingw64\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 243               		.loc 2 172 2 view .LVU45
 173:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 244               		.loc 2 173 2 view .LVU46
 174:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 245               		.loc 2 174 2 view .LVU47
 175:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 176:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:e:\game\msys2\mingw64\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 179:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:e:\game\msys2\mingw64\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 182:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	#else
 183:e:\game\msys2\mingw64\avr\include\util\delay.h **** 		//round up by default
 184:e:\game\msys2\mingw64\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 246               		.loc 2 184 3 view .LVU48
 185:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	#endif
 186:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 187:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 247               		.loc 2 187 2 view .LVU49
 248 0020 2FEF      		ldi r18,lo8(319999)
 249 0022 81EE      		ldi r24,hi8(319999)
 250 0024 94E0      		ldi r25,hlo8(319999)
 251 0026 2150      	1:	subi r18,1
 252 0028 8040      		sbci r24,0
 253 002a 9040      		sbci r25,0
 254 002c 01F4      		brne 1b
 255 002e 00C0      		rjmp .
 256 0030 0000      		nop
 257               	.LVL21:
 258               		.loc 2 187 2 is_stmt 0 view .LVU50
 259               	.LBE34:
 260               	.LBE33:
 749:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 261               		.loc 1 749 9 is_stmt 1 view .LVU51
 262 0032 89E3      		ldi r24,lo8(57)
 263               	.L24:
 750:tmk_core/common/action.c ****         send_keyboard_report();
 751:tmk_core/common/action.c ****     }
 752:tmk_core/common/action.c **** 
 753:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 754:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 755:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 756:tmk_core/common/action.c **** #    endif
 757:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 758:tmk_core/common/action.c ****         send_keyboard_report();
 759:tmk_core/common/action.c ****         wait_ms(100);
 760:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 264               		.loc 1 760 9 is_stmt 0 view .LVU52
 265 0034 0E94 0000 		call del_key
 266               	.LVL22:
 267               	.L25:
 761:tmk_core/common/action.c ****         send_keyboard_report();
 268               		.loc 1 761 9 is_stmt 1 view .LVU53
 269               	/* epilogue start */
 762:tmk_core/common/action.c ****     }
 763:tmk_core/common/action.c **** 
 764:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 765:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 766:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 767:tmk_core/common/action.c **** #    endif
 768:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 769:tmk_core/common/action.c ****         send_keyboard_report();
 770:tmk_core/common/action.c ****         wait_ms(100);
 771:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 772:tmk_core/common/action.c ****         send_keyboard_report();
 773:tmk_core/common/action.c ****     }
 774:tmk_core/common/action.c **** #endif
 775:tmk_core/common/action.c **** 
 776:tmk_core/common/action.c ****     else if IS_KEY (code) {
 777:tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 778:tmk_core/common/action.c ****         if (command_proc(code)) return;
 779:tmk_core/common/action.c **** 
 780:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 781:tmk_core/common/action.c **** /* TODO: remove
 782:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 783:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 784:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 785:tmk_core/common/action.c **** 
 786:tmk_core/common/action.c ****             add_key(code);
 787:tmk_core/common/action.c ****             send_keyboard_report();
 788:tmk_core/common/action.c **** 
 789:tmk_core/common/action.c ****             set_mods(tmp_mods);
 790:tmk_core/common/action.c ****             send_keyboard_report();
 791:tmk_core/common/action.c ****             oneshot_cancel();
 792:tmk_core/common/action.c ****         } else
 793:tmk_core/common/action.c **** */
 794:tmk_core/common/action.c **** #endif
 795:tmk_core/common/action.c ****         {
 796:tmk_core/common/action.c ****             // Force a new key press if the key is already pressed
 797:tmk_core/common/action.c ****             // without this, keys with the same keycode, but different
 798:tmk_core/common/action.c ****             // modifiers will be reported incorrectly, see issue #1708
 799:tmk_core/common/action.c ****             if (is_key_pressed(keyboard_report, code)) {
 800:tmk_core/common/action.c ****                 del_key(code);
 801:tmk_core/common/action.c ****                 send_keyboard_report();
 802:tmk_core/common/action.c ****             }
 803:tmk_core/common/action.c ****             add_key(code);
 804:tmk_core/common/action.c ****             send_keyboard_report();
 805:tmk_core/common/action.c ****         }
 806:tmk_core/common/action.c ****     } else if IS_MOD (code) {
 807:tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 808:tmk_core/common/action.c ****         send_keyboard_report();
 809:tmk_core/common/action.c ****     }
 810:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 811:tmk_core/common/action.c ****     else if IS_SYSTEM (code) {
 812:tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 813:tmk_core/common/action.c ****     } else if IS_CONSUMER (code) {
 814:tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 815:tmk_core/common/action.c ****     }
 816:tmk_core/common/action.c **** #endif
 817:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 818:tmk_core/common/action.c ****     else if IS_MOUSEKEY (code) {
 819:tmk_core/common/action.c ****         mousekey_on(code);
 820:tmk_core/common/action.c ****         mousekey_send();
 821:tmk_core/common/action.c ****     }
 822:tmk_core/common/action.c **** #endif
 823:tmk_core/common/action.c **** }
 270               		.loc 1 823 1 is_stmt 0 view .LVU54
 271 0038 CF91      		pop r28
 761:tmk_core/common/action.c ****         send_keyboard_report();
 272               		.loc 1 761 9 view .LVU55
 273 003a 0C94 0000 		jmp send_keyboard_report
 274               	.LVL23:
 275               	.L12:
 753:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 276               		.loc 1 753 10 is_stmt 1 view .LVU56
 753:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 277               		.loc 1 753 13 is_stmt 0 view .LVU57
 278 003e 8338      		cpi r24,lo8(-125)
 279 0040 01F4      		brne .L14
 755:tmk_core/common/action.c **** #    endif
 280               		.loc 1 755 9 is_stmt 1 view .LVU58
 755:tmk_core/common/action.c **** #    endif
 281               		.loc 1 755 13 is_stmt 0 view .LVU59
 282 0042 0E94 0000 		call host_keyboard_leds
 283               	.LVL24:
 755:tmk_core/common/action.c **** #    endif
 284               		.loc 1 755 12 view .LVU60
 285 0046 80FD      		sbrc r24,0
 286 0048 00C0      		rjmp .L9
 757:tmk_core/common/action.c ****         send_keyboard_report();
 287               		.loc 1 757 9 is_stmt 1 view .LVU61
 288 004a 83E5      		ldi r24,lo8(83)
 289 004c 0E94 0000 		call add_key
 290               	.LVL25:
 758:tmk_core/common/action.c ****         wait_ms(100);
 291               		.loc 1 758 9 view .LVU62
 292 0050 0E94 0000 		call send_keyboard_report
 293               	.LVL26:
 759:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 294               		.loc 1 759 9 view .LVU63
 295               	.LBB35:
 296               	.LBI35:
 166:e:\game\msys2\mingw64\avr\include\util\delay.h **** {
 297               		.loc 2 166 1 view .LVU64
 298               	.LBB36:
 168:e:\game\msys2\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 299               		.loc 2 168 2 view .LVU65
 172:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 300               		.loc 2 172 2 view .LVU66
 173:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 301               		.loc 2 173 2 view .LVU67
 174:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 302               		.loc 2 174 2 view .LVU68
 184:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	#endif
 303               		.loc 2 184 3 view .LVU69
 304               		.loc 2 187 2 view .LVU70
 305 0054 2FEF      		ldi r18,lo8(319999)
 306 0056 81EE      		ldi r24,hi8(319999)
 307 0058 94E0      		ldi r25,hlo8(319999)
 308 005a 2150      	1:	subi r18,1
 309 005c 8040      		sbci r24,0
 310 005e 9040      		sbci r25,0
 311 0060 01F4      		brne 1b
 312 0062 00C0      		rjmp .
 313 0064 0000      		nop
 314               	.LVL27:
 315               		.loc 2 187 2 is_stmt 0 view .LVU71
 316               	.LBE36:
 317               	.LBE35:
 760:tmk_core/common/action.c ****         send_keyboard_report();
 318               		.loc 1 760 9 is_stmt 1 view .LVU72
 319 0066 83E5      		ldi r24,lo8(83)
 320 0068 00C0      		rjmp .L24
 321               	.LVL28:
 322               	.L14:
 764:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 323               		.loc 1 764 10 view .LVU73
 764:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 324               		.loc 1 764 13 is_stmt 0 view .LVU74
 325 006a 8438      		cpi r24,lo8(-124)
 326 006c 01F4      		brne .L15
 766:tmk_core/common/action.c **** #    endif
 327               		.loc 1 766 9 is_stmt 1 view .LVU75
 766:tmk_core/common/action.c **** #    endif
 328               		.loc 1 766 13 is_stmt 0 view .LVU76
 329 006e 0E94 0000 		call host_keyboard_leds
 330               	.LVL29:
 766:tmk_core/common/action.c **** #    endif
 331               		.loc 1 766 12 view .LVU77
 332 0072 82FD      		sbrc r24,2
 333 0074 00C0      		rjmp .L9
 768:tmk_core/common/action.c ****         send_keyboard_report();
 334               		.loc 1 768 9 is_stmt 1 view .LVU78
 335 0076 87E4      		ldi r24,lo8(71)
 336 0078 0E94 0000 		call add_key
 337               	.LVL30:
 769:tmk_core/common/action.c ****         wait_ms(100);
 338               		.loc 1 769 9 view .LVU79
 339 007c 0E94 0000 		call send_keyboard_report
 340               	.LVL31:
 770:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 341               		.loc 1 770 9 view .LVU80
 342               	.LBB37:
 343               	.LBI37:
 166:e:\game\msys2\mingw64\avr\include\util\delay.h **** {
 344               		.loc 2 166 1 view .LVU81
 345               	.LBB38:
 168:e:\game\msys2\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 346               		.loc 2 168 2 view .LVU82
 172:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 347               		.loc 2 172 2 view .LVU83
 173:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 348               		.loc 2 173 2 view .LVU84
 174:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 349               		.loc 2 174 2 view .LVU85
 184:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	#endif
 350               		.loc 2 184 3 view .LVU86
 351               		.loc 2 187 2 view .LVU87
 352 0080 2FEF      		ldi r18,lo8(319999)
 353 0082 81EE      		ldi r24,hi8(319999)
 354 0084 94E0      		ldi r25,hlo8(319999)
 355 0086 2150      	1:	subi r18,1
 356 0088 8040      		sbci r24,0
 357 008a 9040      		sbci r25,0
 358 008c 01F4      		brne 1b
 359 008e 00C0      		rjmp .
 360 0090 0000      		nop
 361               	.LVL32:
 362               		.loc 2 187 2 is_stmt 0 view .LVU88
 363               	.LBE38:
 364               	.LBE37:
 771:tmk_core/common/action.c ****         send_keyboard_report();
 365               		.loc 1 771 9 is_stmt 1 view .LVU89
 366 0092 87E4      		ldi r24,lo8(71)
 367 0094 00C0      		rjmp .L24
 368               	.LVL33:
 369               	.L15:
 776:tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 370               		.loc 1 776 10 view .LVU90
 776:tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 371               		.loc 1 776 13 is_stmt 0 view .LVU91
 372 0096 8CEF      		ldi r24,lo8(-4)
 373               	.LVL34:
 776:tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 374               		.loc 1 776 13 view .LVU92
 375 0098 8C0F      		add r24,r28
 376 009a 813A      		cpi r24,lo8(-95)
 377 009c 00F4      		brsh .L16
 778:tmk_core/common/action.c **** 
 378               		.loc 1 778 9 is_stmt 1 view .LVU93
 778:tmk_core/common/action.c **** 
 379               		.loc 1 778 13 is_stmt 0 view .LVU94
 380 009e 8C2F      		mov r24,r28
 381 00a0 0E94 0000 		call command_proc
 382               	.LVL35:
 778:tmk_core/common/action.c **** 
 383               		.loc 1 778 12 view .LVU95
 384 00a4 8111      		cpse r24,__zero_reg__
 385 00a6 00C0      		rjmp .L9
 799:tmk_core/common/action.c ****                 del_key(code);
 386               		.loc 1 799 13 is_stmt 1 view .LVU96
 799:tmk_core/common/action.c ****                 del_key(code);
 387               		.loc 1 799 17 is_stmt 0 view .LVU97
 388 00a8 6C2F      		mov r22,r28
 389 00aa 8091 0000 		lds r24,keyboard_report
 390 00ae 9091 0000 		lds r25,keyboard_report+1
 391 00b2 0E94 0000 		call is_key_pressed
 392               	.LVL36:
 799:tmk_core/common/action.c ****                 del_key(code);
 393               		.loc 1 799 16 view .LVU98
 394 00b6 8823      		tst r24
 395 00b8 01F0      		breq .L17
 800:tmk_core/common/action.c ****                 send_keyboard_report();
 396               		.loc 1 800 17 is_stmt 1 view .LVU99
 397 00ba 8C2F      		mov r24,r28
 398 00bc 0E94 0000 		call del_key
 399               	.LVL37:
 801:tmk_core/common/action.c ****             }
 400               		.loc 1 801 17 view .LVU100
 401 00c0 0E94 0000 		call send_keyboard_report
 402               	.LVL38:
 403               	.L17:
 803:tmk_core/common/action.c ****             send_keyboard_report();
 404               		.loc 1 803 13 view .LVU101
 405 00c4 8C2F      		mov r24,r28
 406 00c6 0E94 0000 		call add_key
 407               	.LVL39:
 804:tmk_core/common/action.c ****         }
 408               		.loc 1 804 13 view .LVU102
 409 00ca 00C0      		rjmp .L25
 410               	.L16:
 806:tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 411               		.loc 1 806 12 view .LVU103
 806:tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 412               		.loc 1 806 15 is_stmt 0 view .LVU104
 413 00cc 80E2      		ldi r24,lo8(32)
 414 00ce 8C0F      		add r24,r28
 415 00d0 8830      		cpi r24,lo8(8)
 416 00d2 00F4      		brsh .L18
 807:tmk_core/common/action.c ****         send_keyboard_report();
 417               		.loc 1 807 9 is_stmt 1 view .LVU105
 807:tmk_core/common/action.c ****         send_keyboard_report();
 418               		.loc 1 807 18 is_stmt 0 view .LVU106
 419 00d4 C770      		andi r28,lo8(7)
 420               	.LVL40:
 807:tmk_core/common/action.c ****         send_keyboard_report();
 421               		.loc 1 807 9 view .LVU107
 422 00d6 81E0      		ldi r24,lo8(1)
 423 00d8 00C0      		rjmp 2f
 424               		1:
 425 00da 880F      		lsl r24
 426               		2:
 427 00dc CA95      		dec r28
 428 00de 02F4      		brpl 1b
 429 00e0 0E94 0000 		call add_mods
 430               	.LVL41:
 808:tmk_core/common/action.c ****     }
 431               		.loc 1 808 9 is_stmt 1 view .LVU108
 432 00e4 00C0      		rjmp .L25
 433               	.LVL42:
 434               	.L18:
 811:tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 435               		.loc 1 811 10 view .LVU109
 811:tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 436               		.loc 1 811 13 is_stmt 0 view .LVU110
 437 00e6 EBE5      		ldi r30,lo8(91)
 438 00e8 EC0F      		add r30,r28
 439 00ea E330      		cpi r30,lo8(3)
 440 00ec 00F4      		brsh .L19
 812:tmk_core/common/action.c ****     } else if IS_CONSUMER (code) {
 441               		.loc 1 812 9 is_stmt 1 view .LVU111
 442               	.LVL43:
 443               	.LBB39:
 444               	.LBI39:
 445               		.file 3 "tmk_core/common/report.h"
   1:tmk_core/common/report.h **** /*
   2:tmk_core/common/report.h **** Copyright 2011,2012 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/report.h **** 
   4:tmk_core/common/report.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/report.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/report.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/report.h **** (at your option) any later version.
   8:tmk_core/common/report.h **** 
   9:tmk_core/common/report.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/report.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/report.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/report.h **** GNU General Public License for more details.
  13:tmk_core/common/report.h **** 
  14:tmk_core/common/report.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/report.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/report.h **** */
  17:tmk_core/common/report.h **** 
  18:tmk_core/common/report.h **** #pragma once
  19:tmk_core/common/report.h **** 
  20:tmk_core/common/report.h **** #include <stdint.h>
  21:tmk_core/common/report.h **** #include <stdbool.h>
  22:tmk_core/common/report.h **** #include "keycode.h"
  23:tmk_core/common/report.h **** 
  24:tmk_core/common/report.h **** // clang-format off
  25:tmk_core/common/report.h **** 
  26:tmk_core/common/report.h **** /* HID report IDs */
  27:tmk_core/common/report.h **** enum hid_report_ids {
  28:tmk_core/common/report.h ****     REPORT_ID_KEYBOARD = 1,
  29:tmk_core/common/report.h ****     REPORT_ID_MOUSE,
  30:tmk_core/common/report.h ****     REPORT_ID_SYSTEM,
  31:tmk_core/common/report.h ****     REPORT_ID_CONSUMER,
  32:tmk_core/common/report.h ****     REPORT_ID_NKRO,
  33:tmk_core/common/report.h ****     REPORT_ID_JOYSTICK
  34:tmk_core/common/report.h **** };
  35:tmk_core/common/report.h **** 
  36:tmk_core/common/report.h **** /* Mouse buttons */
  37:tmk_core/common/report.h **** #define MOUSE_BTN_MASK(n) (1 << (n))
  38:tmk_core/common/report.h **** enum mouse_buttons {
  39:tmk_core/common/report.h ****     MOUSE_BTN1 = MOUSE_BTN_MASK(0),
  40:tmk_core/common/report.h ****     MOUSE_BTN2 = MOUSE_BTN_MASK(1),
  41:tmk_core/common/report.h ****     MOUSE_BTN3 = MOUSE_BTN_MASK(2),
  42:tmk_core/common/report.h ****     MOUSE_BTN4 = MOUSE_BTN_MASK(3),
  43:tmk_core/common/report.h ****     MOUSE_BTN5 = MOUSE_BTN_MASK(4),
  44:tmk_core/common/report.h ****     MOUSE_BTN6 = MOUSE_BTN_MASK(5),
  45:tmk_core/common/report.h ****     MOUSE_BTN7 = MOUSE_BTN_MASK(6),
  46:tmk_core/common/report.h ****     MOUSE_BTN8 = MOUSE_BTN_MASK(7)
  47:tmk_core/common/report.h **** };
  48:tmk_core/common/report.h **** 
  49:tmk_core/common/report.h **** /* Consumer Page (0x0C)
  50:tmk_core/common/report.h ****  *
  51:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=75
  52:tmk_core/common/report.h ****  */
  53:tmk_core/common/report.h **** enum consumer_usages {
  54:tmk_core/common/report.h ****     // 15.5 Display Controls
  55:tmk_core/common/report.h ****     SNAPSHOT               = 0x065,
  56:tmk_core/common/report.h ****     BRIGHTNESS_UP          = 0x06F, // https://www.usb.org/sites/default/files/hutrr41_0.pdf
  57:tmk_core/common/report.h ****     BRIGHTNESS_DOWN        = 0x070,
  58:tmk_core/common/report.h ****     // 15.7 Transport Controls
  59:tmk_core/common/report.h ****     TRANSPORT_RECORD       = 0x0B2,
  60:tmk_core/common/report.h ****     TRANSPORT_FAST_FORWARD = 0x0B3,
  61:tmk_core/common/report.h ****     TRANSPORT_REWIND       = 0x0B4,
  62:tmk_core/common/report.h ****     TRANSPORT_NEXT_TRACK   = 0x0B5,
  63:tmk_core/common/report.h ****     TRANSPORT_PREV_TRACK   = 0x0B6,
  64:tmk_core/common/report.h ****     TRANSPORT_STOP         = 0x0B7,
  65:tmk_core/common/report.h ****     TRANSPORT_EJECT        = 0x0B8,
  66:tmk_core/common/report.h ****     TRANSPORT_RANDOM_PLAY  = 0x0B9,
  67:tmk_core/common/report.h ****     TRANSPORT_STOP_EJECT   = 0x0CC,
  68:tmk_core/common/report.h ****     TRANSPORT_PLAY_PAUSE   = 0x0CD,
  69:tmk_core/common/report.h ****     // 15.9.1 Audio Controls - Volume
  70:tmk_core/common/report.h ****     AUDIO_MUTE             = 0x0E2,
  71:tmk_core/common/report.h ****     AUDIO_VOL_UP           = 0x0E9,
  72:tmk_core/common/report.h ****     AUDIO_VOL_DOWN         = 0x0EA,
  73:tmk_core/common/report.h ****     // 15.15 Application Launch Buttons
  74:tmk_core/common/report.h ****     AL_CC_CONFIG           = 0x183,
  75:tmk_core/common/report.h ****     AL_EMAIL               = 0x18A,
  76:tmk_core/common/report.h ****     AL_CALCULATOR          = 0x192,
  77:tmk_core/common/report.h ****     AL_LOCAL_BROWSER       = 0x194,
  78:tmk_core/common/report.h ****     AL_LOCK                = 0x19E,
  79:tmk_core/common/report.h ****     AL_CONTROL_PANEL       = 0x19F,
  80:tmk_core/common/report.h ****     AL_ASSISTANT           = 0x1CB,
  81:tmk_core/common/report.h ****     AL_KEYBOARD_LAYOUT     = 0x1AE,
  82:tmk_core/common/report.h ****     // 15.16 Generic GUI Application Controls
  83:tmk_core/common/report.h ****     AC_NEW                 = 0x201,
  84:tmk_core/common/report.h ****     AC_OPEN                = 0x202,
  85:tmk_core/common/report.h ****     AC_CLOSE               = 0x203,
  86:tmk_core/common/report.h ****     AC_EXIT                = 0x204,
  87:tmk_core/common/report.h ****     AC_MAXIMIZE            = 0x205,
  88:tmk_core/common/report.h ****     AC_MINIMIZE            = 0x206,
  89:tmk_core/common/report.h ****     AC_SAVE                = 0x207,
  90:tmk_core/common/report.h ****     AC_PRINT               = 0x208,
  91:tmk_core/common/report.h ****     AC_PROPERTIES          = 0x209,
  92:tmk_core/common/report.h ****     AC_UNDO                = 0x21A,
  93:tmk_core/common/report.h ****     AC_COPY                = 0x21B,
  94:tmk_core/common/report.h ****     AC_CUT                 = 0x21C,
  95:tmk_core/common/report.h ****     AC_PASTE               = 0x21D,
  96:tmk_core/common/report.h ****     AC_SELECT_ALL          = 0x21E,
  97:tmk_core/common/report.h ****     AC_FIND                = 0x21F,
  98:tmk_core/common/report.h ****     AC_SEARCH              = 0x221,
  99:tmk_core/common/report.h ****     AC_HOME                = 0x223,
 100:tmk_core/common/report.h ****     AC_BACK                = 0x224,
 101:tmk_core/common/report.h ****     AC_FORWARD             = 0x225,
 102:tmk_core/common/report.h ****     AC_STOP                = 0x226,
 103:tmk_core/common/report.h ****     AC_REFRESH             = 0x227,
 104:tmk_core/common/report.h ****     AC_BOOKMARKS           = 0x22A
 105:tmk_core/common/report.h **** };
 106:tmk_core/common/report.h **** 
 107:tmk_core/common/report.h **** /* Generic Desktop Page (0x01)
 108:tmk_core/common/report.h ****  *
 109:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=26
 110:tmk_core/common/report.h ****  */
 111:tmk_core/common/report.h **** enum desktop_usages {
 112:tmk_core/common/report.h ****     // 4.5.1 System Controls - Power Controls
 113:tmk_core/common/report.h ****     SYSTEM_POWER_DOWN             = 0x81,
 114:tmk_core/common/report.h ****     SYSTEM_SLEEP                  = 0x82,
 115:tmk_core/common/report.h ****     SYSTEM_WAKE_UP                = 0x83,
 116:tmk_core/common/report.h ****     SYSTEM_RESTART                = 0x8F,
 117:tmk_core/common/report.h ****     // 4.10 System Display Controls
 118:tmk_core/common/report.h ****     SYSTEM_DISPLAY_TOGGLE_INT_EXT = 0xB5
 119:tmk_core/common/report.h **** };
 120:tmk_core/common/report.h **** 
 121:tmk_core/common/report.h **** // clang-format on
 122:tmk_core/common/report.h **** 
 123:tmk_core/common/report.h **** #define NKRO_SHARED_EP
 124:tmk_core/common/report.h **** /* key report size(NKRO or boot mode) */
 125:tmk_core/common/report.h **** #if defined(NKRO_ENABLE)
 126:tmk_core/common/report.h **** #    if defined(PROTOCOL_LUFA) || defined(PROTOCOL_CHIBIOS)
 127:tmk_core/common/report.h **** #        include "protocol/usb_descriptor.h"
 128:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (SHARED_EPSIZE - 2)
 129:tmk_core/common/report.h **** #    elif defined(PROTOCOL_ARM_ATSAM)
 130:tmk_core/common/report.h **** #        include "protocol/arm_atsam/usb/udi_device_epsize.h"
 131:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (NKRO_EPSIZE - 1)
 132:tmk_core/common/report.h **** #        undef NKRO_SHARED_EP
 133:tmk_core/common/report.h **** #        undef MOUSE_SHARED_EP
 134:tmk_core/common/report.h **** #    else
 135:tmk_core/common/report.h **** #        error "NKRO not supported with this protocol"
 136:tmk_core/common/report.h **** #    endif
 137:tmk_core/common/report.h **** #endif
 138:tmk_core/common/report.h **** 
 139:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 140:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 9
 141:tmk_core/common/report.h **** #else
 142:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 8
 143:tmk_core/common/report.h **** #endif
 144:tmk_core/common/report.h **** 
 145:tmk_core/common/report.h **** #define KEYBOARD_REPORT_KEYS 6
 146:tmk_core/common/report.h **** 
 147:tmk_core/common/report.h **** #ifdef __cplusplus
 148:tmk_core/common/report.h **** extern "C" {
 149:tmk_core/common/report.h **** #endif
 150:tmk_core/common/report.h **** 
 151:tmk_core/common/report.h **** /*
 152:tmk_core/common/report.h ****  * keyboard report is 8-byte array retains state of 8 modifiers and 6 keys.
 153:tmk_core/common/report.h ****  *
 154:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7
 155:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 156:tmk_core/common/report.h ****  * desc |mods    |reserved|keys[0] |keys[1] |keys[2] |keys[3] |keys[4] |keys[5]
 157:tmk_core/common/report.h ****  *
 158:tmk_core/common/report.h ****  * It is exended to 16 bytes to retain 120keys+8mods when NKRO mode.
 159:tmk_core/common/report.h ****  *
 160:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7        ... |15
 161:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------     +--------
 162:tmk_core/common/report.h ****  * desc |mods    |bits[0] |bits[1] |bits[2] |bits[3] |bits[4] |bits[5] |bits[6]  ... |bit[14]
 163:tmk_core/common/report.h ****  *
 164:tmk_core/common/report.h ****  * mods retains state of 8 modifiers.
 165:tmk_core/common/report.h ****  *
 166:tmk_core/common/report.h ****  *  bit |0       |1       |2       |3       |4       |5       |6       |7
 167:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 168:tmk_core/common/report.h ****  * desc |Lcontrol|Lshift  |Lalt    |Lgui    |Rcontrol|Rshift  |Ralt    |Rgui
 169:tmk_core/common/report.h ****  *
 170:tmk_core/common/report.h ****  */
 171:tmk_core/common/report.h **** typedef union {
 172:tmk_core/common/report.h ****     uint8_t raw[KEYBOARD_REPORT_SIZE];
 173:tmk_core/common/report.h ****     struct {
 174:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 175:tmk_core/common/report.h ****         uint8_t report_id;
 176:tmk_core/common/report.h **** #endif
 177:tmk_core/common/report.h ****         uint8_t mods;
 178:tmk_core/common/report.h ****         uint8_t reserved;
 179:tmk_core/common/report.h ****         uint8_t keys[KEYBOARD_REPORT_KEYS];
 180:tmk_core/common/report.h ****     };
 181:tmk_core/common/report.h **** #ifdef NKRO_ENABLE
 182:tmk_core/common/report.h ****     struct nkro_report {
 183:tmk_core/common/report.h **** #    ifdef NKRO_SHARED_EP
 184:tmk_core/common/report.h ****         uint8_t report_id;
 185:tmk_core/common/report.h **** #    endif
 186:tmk_core/common/report.h ****         uint8_t mods;
 187:tmk_core/common/report.h ****         uint8_t bits[KEYBOARD_REPORT_BITS];
 188:tmk_core/common/report.h ****     } nkro;
 189:tmk_core/common/report.h **** #endif
 190:tmk_core/common/report.h **** } __attribute__((packed)) report_keyboard_t;
 191:tmk_core/common/report.h **** 
 192:tmk_core/common/report.h **** typedef struct {
 193:tmk_core/common/report.h ****     uint8_t  report_id;
 194:tmk_core/common/report.h ****     uint16_t usage;
 195:tmk_core/common/report.h **** } __attribute__((packed)) report_extra_t;
 196:tmk_core/common/report.h **** 
 197:tmk_core/common/report.h **** typedef struct {
 198:tmk_core/common/report.h **** #ifdef MOUSE_SHARED_EP
 199:tmk_core/common/report.h ****     uint8_t report_id;
 200:tmk_core/common/report.h **** #endif
 201:tmk_core/common/report.h ****     uint8_t buttons;
 202:tmk_core/common/report.h ****     int8_t  x;
 203:tmk_core/common/report.h ****     int8_t  y;
 204:tmk_core/common/report.h ****     int8_t  v;
 205:tmk_core/common/report.h ****     int8_t  h;
 206:tmk_core/common/report.h **** } __attribute__((packed)) report_mouse_t;
 207:tmk_core/common/report.h **** 
 208:tmk_core/common/report.h **** typedef struct {
 209:tmk_core/common/report.h **** #if JOYSTICK_AXES_COUNT > 0
 210:tmk_core/common/report.h **** #    if JOYSTICK_AXES_RESOLUTION > 8
 211:tmk_core/common/report.h ****     int16_t axes[JOYSTICK_AXES_COUNT];
 212:tmk_core/common/report.h **** #    else
 213:tmk_core/common/report.h ****     int8_t axes[JOYSTICK_AXES_COUNT];
 214:tmk_core/common/report.h **** #    endif
 215:tmk_core/common/report.h **** #endif
 216:tmk_core/common/report.h **** 
 217:tmk_core/common/report.h **** #if JOYSTICK_BUTTON_COUNT > 0
 218:tmk_core/common/report.h ****     uint8_t buttons[(JOYSTICK_BUTTON_COUNT - 1) / 8 + 1];
 219:tmk_core/common/report.h **** #endif
 220:tmk_core/common/report.h **** } __attribute__((packed)) joystick_report_t;
 221:tmk_core/common/report.h **** 
 222:tmk_core/common/report.h **** /* keycode to system usage */
 223:tmk_core/common/report.h **** static inline uint16_t KEYCODE2SYSTEM(uint8_t key) {
 446               		.loc 3 223 24 view .LVU112
 447               	.LBE39:
 224:tmk_core/common/report.h ****     switch (key) {
 448               		.loc 3 224 5 view .LVU113
 812:tmk_core/common/action.c ****     } else if IS_CONSUMER (code) {
 449               		.loc 1 812 9 is_stmt 0 view .LVU114
 450 00ee F0E0      		ldi r31,0
 451 00f0 E050      		subi r30,lo8(-(CSWTCH.11))
 452 00f2 F040      		sbci r31,hi8(-(CSWTCH.11))
 453 00f4 8081      		ld r24,Z
 454 00f6 90E0      		ldi r25,0
 455               	/* epilogue start */
 456               		.loc 1 823 1 view .LVU115
 457 00f8 CF91      		pop r28
 458               	.LVL44:
 812:tmk_core/common/action.c ****     } else if IS_CONSUMER (code) {
 459               		.loc 1 812 9 view .LVU116
 460 00fa 0C94 0000 		jmp host_system_send
 461               	.LVL45:
 462               	.L19:
 813:tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 463               		.loc 1 813 12 is_stmt 1 view .LVU117
 813:tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 464               		.loc 1 813 15 is_stmt 0 view .LVU118
 465 00fe E8E5      		ldi r30,lo8(88)
 466 0100 EC0F      		add r30,r28
 467 0102 E731      		cpi r30,lo8(23)
 468 0104 00F4      		brsh .L20
 814:tmk_core/common/action.c ****     }
 469               		.loc 1 814 9 is_stmt 1 view .LVU119
 470               	.LVL46:
 471               	.LBB40:
 472               	.LBI40:
 225:tmk_core/common/report.h ****         case KC_SYSTEM_POWER:
 226:tmk_core/common/report.h ****             return SYSTEM_POWER_DOWN;
 227:tmk_core/common/report.h ****         case KC_SYSTEM_SLEEP:
 228:tmk_core/common/report.h ****             return SYSTEM_SLEEP;
 229:tmk_core/common/report.h ****         case KC_SYSTEM_WAKE:
 230:tmk_core/common/report.h ****             return SYSTEM_WAKE_UP;
 231:tmk_core/common/report.h ****         default:
 232:tmk_core/common/report.h ****             return 0;
 233:tmk_core/common/report.h ****     }
 234:tmk_core/common/report.h **** }
 235:tmk_core/common/report.h **** 
 236:tmk_core/common/report.h **** /* keycode to consumer usage */
 237:tmk_core/common/report.h **** static inline uint16_t KEYCODE2CONSUMER(uint8_t key) {
 473               		.loc 3 237 24 view .LVU120
 474               	.LBE40:
 238:tmk_core/common/report.h ****     switch (key) {
 475               		.loc 3 238 5 view .LVU121
 814:tmk_core/common/action.c ****     }
 476               		.loc 1 814 9 is_stmt 0 view .LVU122
 477 0106 F0E0      		ldi r31,0
 478 0108 EE0F      		lsl r30
 479 010a FF1F      		rol r31
 480 010c E050      		subi r30,lo8(-(CSWTCH.12))
 481 010e F040      		sbci r31,hi8(-(CSWTCH.12))
 482 0110 8081      		ld r24,Z
 483 0112 9181      		ldd r25,Z+1
 484               	/* epilogue start */
 485               		.loc 1 823 1 view .LVU123
 486 0114 CF91      		pop r28
 487               	.LVL47:
 814:tmk_core/common/action.c ****     }
 488               		.loc 1 814 9 view .LVU124
 489 0116 0C94 0000 		jmp host_consumer_send
 490               	.LVL48:
 491               	.L20:
 818:tmk_core/common/action.c ****         mousekey_on(code);
 492               		.loc 1 818 10 is_stmt 1 view .LVU125
 818:tmk_core/common/action.c ****         mousekey_on(code);
 493               		.loc 1 818 13 is_stmt 0 view .LVU126
 494 011a C03F      		cpi r28,lo8(-16)
 495 011c 00F0      		brlo .L9
 819:tmk_core/common/action.c ****         mousekey_send();
 496               		.loc 1 819 9 is_stmt 1 view .LVU127
 497 011e 8C2F      		mov r24,r28
 498 0120 0E94 0000 		call mousekey_on
 499               	.LVL49:
 820:tmk_core/common/action.c ****     }
 500               		.loc 1 820 9 view .LVU128
 501               	/* epilogue start */
 502               		.loc 1 823 1 is_stmt 0 view .LVU129
 503 0124 CF91      		pop r28
 504               	.LVL50:
 820:tmk_core/common/action.c ****     }
 505               		.loc 1 820 9 view .LVU130
 506 0126 0C94 0000 		jmp mousekey_send
 507               	.LVL51:
 508               	.L9:
 509               	/* epilogue start */
 510               		.loc 1 823 1 view .LVU131
 511 012a CF91      		pop r28
 512               	.LVL52:
 513               		.loc 1 823 1 view .LVU132
 514 012c 0895      		ret
 515               		.cfi_endproc
 516               	.LFE23:
 518               		.section	.text.unregister_code,"ax",@progbits
 519               	.global	unregister_code
 521               	unregister_code:
 522               	.LVL53:
 523               	.LFB24:
 824:tmk_core/common/action.c **** 
 825:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 826:tmk_core/common/action.c ****  *
 827:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 828:tmk_core/common/action.c ****  */
 829:tmk_core/common/action.c **** void unregister_code(uint8_t code) {
 524               		.loc 1 829 36 is_stmt 1 view -0
 525               		.cfi_startproc
 526               	/* prologue: function */
 527               	/* frame size = 0 */
 528               	/* stack size = 0 */
 529               	.L__stack_usage = 0
 830:tmk_core/common/action.c ****     if (code == KC_NO) {
 530               		.loc 1 830 5 view .LVU134
 531               		.loc 1 830 8 is_stmt 0 view .LVU135
 532 0000 8823      		tst r24
 533 0002 01F4      		brne .+2
 534 0004 00C0      		rjmp .L26
 831:tmk_core/common/action.c ****         return;
 832:tmk_core/common/action.c ****     }
 833:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 834:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 535               		.loc 1 834 10 is_stmt 1 view .LVU136
 536               		.loc 1 834 13 is_stmt 0 view .LVU137
 537 0006 8238      		cpi r24,lo8(-126)
 538 0008 01F4      		brne .L29
 835:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 836:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 837:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 539               		.loc 1 837 9 is_stmt 1 view .LVU138
 540               		.loc 1 837 15 is_stmt 0 view .LVU139
 541 000a 0E94 0000 		call host_keyboard_leds
 542               	.LVL54:
 543               		.loc 1 837 12 view .LVU140
 544 000e 81FF      		sbrs r24,1
 545 0010 00C0      		rjmp .L26
 838:tmk_core/common/action.c **** #    endif
 839:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 546               		.loc 1 839 9 is_stmt 1 view .LVU141
 547 0012 89E3      		ldi r24,lo8(57)
 548 0014 0E94 0000 		call add_key
 549               	.LVL55:
 840:tmk_core/common/action.c ****         send_keyboard_report();
 550               		.loc 1 840 9 view .LVU142
 551 0018 0E94 0000 		call send_keyboard_report
 552               	.LVL56:
 841:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 553               		.loc 1 841 9 view .LVU143
 554 001c 89E3      		ldi r24,lo8(57)
 555               	.L46:
 842:tmk_core/common/action.c ****         send_keyboard_report();
 843:tmk_core/common/action.c ****     }
 844:tmk_core/common/action.c **** 
 845:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 846:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 847:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 848:tmk_core/common/action.c **** #    endif
 849:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 850:tmk_core/common/action.c ****         send_keyboard_report();
 851:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 556               		.loc 1 851 9 is_stmt 0 view .LVU144
 557 001e 0E94 0000 		call del_key
 558               	.LVL57:
 559               	.L47:
 852:tmk_core/common/action.c ****         send_keyboard_report();
 560               		.loc 1 852 9 is_stmt 1 view .LVU145
 561 0022 0C94 0000 		jmp send_keyboard_report
 562               	.LVL58:
 563               	.L29:
 845:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 564               		.loc 1 845 10 view .LVU146
 845:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 565               		.loc 1 845 13 is_stmt 0 view .LVU147
 566 0026 8338      		cpi r24,lo8(-125)
 567 0028 01F4      		brne .L31
 847:tmk_core/common/action.c **** #    endif
 568               		.loc 1 847 9 is_stmt 1 view .LVU148
 847:tmk_core/common/action.c **** #    endif
 569               		.loc 1 847 15 is_stmt 0 view .LVU149
 570 002a 0E94 0000 		call host_keyboard_leds
 571               	.LVL59:
 847:tmk_core/common/action.c **** #    endif
 572               		.loc 1 847 12 view .LVU150
 573 002e 80FF      		sbrs r24,0
 574 0030 00C0      		rjmp .L26
 849:tmk_core/common/action.c ****         send_keyboard_report();
 575               		.loc 1 849 9 is_stmt 1 view .LVU151
 576 0032 83E5      		ldi r24,lo8(83)
 577 0034 0E94 0000 		call add_key
 578               	.LVL60:
 850:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 579               		.loc 1 850 9 view .LVU152
 580 0038 0E94 0000 		call send_keyboard_report
 581               	.LVL61:
 851:tmk_core/common/action.c ****         send_keyboard_report();
 582               		.loc 1 851 9 view .LVU153
 583 003c 83E5      		ldi r24,lo8(83)
 584 003e 00C0      		rjmp .L46
 585               	.LVL62:
 586               	.L31:
 853:tmk_core/common/action.c ****     }
 854:tmk_core/common/action.c **** 
 855:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 587               		.loc 1 855 10 view .LVU154
 588               		.loc 1 855 13 is_stmt 0 view .LVU155
 589 0040 8438      		cpi r24,lo8(-124)
 590 0042 01F4      		brne .L32
 856:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 857:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 591               		.loc 1 857 9 is_stmt 1 view .LVU156
 592               		.loc 1 857 15 is_stmt 0 view .LVU157
 593 0044 0E94 0000 		call host_keyboard_leds
 594               	.LVL63:
 595               		.loc 1 857 12 view .LVU158
 596 0048 82FF      		sbrs r24,2
 597 004a 00C0      		rjmp .L26
 858:tmk_core/common/action.c **** #    endif
 859:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 598               		.loc 1 859 9 is_stmt 1 view .LVU159
 599 004c 87E4      		ldi r24,lo8(71)
 600 004e 0E94 0000 		call add_key
 601               	.LVL64:
 860:tmk_core/common/action.c ****         send_keyboard_report();
 602               		.loc 1 860 9 view .LVU160
 603 0052 0E94 0000 		call send_keyboard_report
 604               	.LVL65:
 861:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 605               		.loc 1 861 9 view .LVU161
 606 0056 87E4      		ldi r24,lo8(71)
 607 0058 00C0      		rjmp .L46
 608               	.LVL66:
 609               	.L32:
 862:tmk_core/common/action.c ****         send_keyboard_report();
 863:tmk_core/common/action.c ****     }
 864:tmk_core/common/action.c **** #endif
 865:tmk_core/common/action.c **** 
 866:tmk_core/common/action.c ****     else if IS_KEY (code) {
 610               		.loc 1 866 10 view .LVU162
 611               		.loc 1 866 13 is_stmt 0 view .LVU163
 612 005a 9CEF      		ldi r25,lo8(-4)
 613 005c 980F      		add r25,r24
 614 005e 913A      		cpi r25,lo8(-95)
 615 0060 00F0      		brlo .L46
 867:tmk_core/common/action.c ****         del_key(code);
 868:tmk_core/common/action.c ****         send_keyboard_report();
 869:tmk_core/common/action.c ****     } else if IS_MOD (code) {
 616               		.loc 1 869 12 is_stmt 1 view .LVU164
 617               		.loc 1 869 15 is_stmt 0 view .LVU165
 618 0062 90E2      		ldi r25,lo8(32)
 619 0064 980F      		add r25,r24
 620 0066 9830      		cpi r25,lo8(8)
 621 0068 00F4      		brsh .L34
 870:tmk_core/common/action.c ****         del_mods(MOD_BIT(code));
 622               		.loc 1 870 9 is_stmt 1 view .LVU166
 623               		.loc 1 870 18 is_stmt 0 view .LVU167
 624 006a 8770      		andi r24,lo8(7)
 625               	.LVL67:
 626               		.loc 1 870 9 view .LVU168
 627 006c 91E0      		ldi r25,lo8(1)
 628 006e 00C0      		rjmp 2f
 629               		1:
 630 0070 990F      		lsl r25
 631               		2:
 632 0072 8A95      		dec r24
 633 0074 02F4      		brpl 1b
 634 0076 892F      		mov r24,r25
 635 0078 0E94 0000 		call del_mods
 636               	.LVL68:
 871:tmk_core/common/action.c ****         send_keyboard_report();
 637               		.loc 1 871 9 is_stmt 1 view .LVU169
 638 007c 00C0      		rjmp .L47
 639               	.LVL69:
 640               	.L34:
 872:tmk_core/common/action.c ****     } else if IS_SYSTEM (code) {
 641               		.loc 1 872 12 view .LVU170
 642               		.loc 1 872 15 is_stmt 0 view .LVU171
 643 007e 9BE5      		ldi r25,lo8(91)
 644 0080 980F      		add r25,r24
 645 0082 9330      		cpi r25,lo8(3)
 646 0084 00F4      		brsh .L35
 873:tmk_core/common/action.c ****         host_system_send(0);
 647               		.loc 1 873 9 is_stmt 1 view .LVU172
 648 0086 90E0      		ldi r25,0
 649 0088 80E0      		ldi r24,0
 650               	.LVL70:
 651               		.loc 1 873 9 is_stmt 0 view .LVU173
 652 008a 0C94 0000 		jmp host_system_send
 653               	.LVL71:
 654               	.L35:
 874:tmk_core/common/action.c ****     } else if IS_CONSUMER (code) {
 655               		.loc 1 874 12 is_stmt 1 view .LVU174
 656               		.loc 1 874 15 is_stmt 0 view .LVU175
 657 008e 98E5      		ldi r25,lo8(88)
 658 0090 980F      		add r25,r24
 659 0092 9731      		cpi r25,lo8(23)
 660 0094 00F4      		brsh .L36
 875:tmk_core/common/action.c ****         host_consumer_send(0);
 661               		.loc 1 875 9 is_stmt 1 view .LVU176
 662 0096 90E0      		ldi r25,0
 663 0098 80E0      		ldi r24,0
 664               	.LVL72:
 665               		.loc 1 875 9 is_stmt 0 view .LVU177
 666 009a 0C94 0000 		jmp host_consumer_send
 667               	.LVL73:
 668               	.L36:
 876:tmk_core/common/action.c ****     }
 877:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 878:tmk_core/common/action.c ****     else if IS_MOUSEKEY (code) {
 669               		.loc 1 878 10 is_stmt 1 view .LVU178
 670               		.loc 1 878 13 is_stmt 0 view .LVU179
 671 009e 803F      		cpi r24,lo8(-16)
 672 00a0 00F0      		brlo .L26
 879:tmk_core/common/action.c ****         mousekey_off(code);
 673               		.loc 1 879 9 is_stmt 1 view .LVU180
 674 00a2 0E94 0000 		call mousekey_off
 675               	.LVL74:
 880:tmk_core/common/action.c ****         mousekey_send();
 676               		.loc 1 880 9 view .LVU181
 677 00a6 0C94 0000 		jmp mousekey_send
 678               	.LVL75:
 679               	.L26:
 680               	/* epilogue start */
 881:tmk_core/common/action.c ****     }
 882:tmk_core/common/action.c **** #endif
 883:tmk_core/common/action.c **** }
 681               		.loc 1 883 1 is_stmt 0 view .LVU182
 682 00aa 0895      		ret
 683               		.cfi_endproc
 684               	.LFE24:
 686               		.section	.text.tap_code_delay,"ax",@progbits
 687               	.global	tap_code_delay
 689               	tap_code_delay:
 690               	.LVL76:
 691               	.LFB25:
 884:tmk_core/common/action.c **** 
 885:tmk_core/common/action.c **** /** \brief Tap a keycode with a delay.
 886:tmk_core/common/action.c ****  *
 887:tmk_core/common/action.c ****  * \param code The basic keycode to tap.
 888:tmk_core/common/action.c ****  * \param delay The amount of time in milliseconds to leave the keycode registered, before unregist
 889:tmk_core/common/action.c ****  */
 890:tmk_core/common/action.c **** void tap_code_delay(uint8_t code, uint16_t delay) {
 692               		.loc 1 890 51 is_stmt 1 view -0
 693               		.cfi_startproc
 694               		.loc 1 890 51 is_stmt 0 view .LVU184
 695 0000 1F93      		push r17
 696               	.LCFI10:
 697               		.cfi_def_cfa_offset 3
 698               		.cfi_offset 17, -2
 699 0002 CF93      		push r28
 700               	.LCFI11:
 701               		.cfi_def_cfa_offset 4
 702               		.cfi_offset 28, -3
 703 0004 DF93      		push r29
 704               	.LCFI12:
 705               		.cfi_def_cfa_offset 5
 706               		.cfi_offset 29, -4
 707               	/* prologue: function */
 708               	/* frame size = 0 */
 709               	/* stack size = 3 */
 710               	.L__stack_usage = 3
 711 0006 182F      		mov r17,r24
 712 0008 EB01      		movw r28,r22
 891:tmk_core/common/action.c ****     register_code(code);
 713               		.loc 1 891 5 is_stmt 1 view .LVU185
 714 000a 0E94 0000 		call register_code
 715               	.LVL77:
 892:tmk_core/common/action.c ****     for (uint16_t i = delay; i > 0; i--) {
 716               		.loc 1 892 5 view .LVU186
 717               	.LBB41:
 718               		.loc 1 892 10 view .LVU187
 719               	.L49:
 720               		.loc 1 892 30 discriminator 1 view .LVU188
 721               		.loc 1 892 5 is_stmt 0 discriminator 1 view .LVU189
 722 000e 2097      		sbiw r28,0
 723 0010 01F4      		brne .L50
 724               		.loc 1 892 5 discriminator 1 view .LVU190
 725               	.LBE41:
 893:tmk_core/common/action.c ****         wait_ms(1);
 894:tmk_core/common/action.c ****     }
 895:tmk_core/common/action.c ****     unregister_code(code);
 726               		.loc 1 895 5 is_stmt 1 view .LVU191
 727 0012 812F      		mov r24,r17
 728               	/* epilogue start */
 896:tmk_core/common/action.c **** }
 729               		.loc 1 896 1 is_stmt 0 view .LVU192
 730 0014 DF91      		pop r29
 731 0016 CF91      		pop r28
 732               	.LVL78:
 733               		.loc 1 896 1 view .LVU193
 734 0018 1F91      		pop r17
 735               	.LVL79:
 895:tmk_core/common/action.c **** }
 736               		.loc 1 895 5 view .LVU194
 737 001a 0C94 0000 		jmp unregister_code
 738               	.LVL80:
 739               	.L50:
 740               	.LBB44:
 893:tmk_core/common/action.c ****         wait_ms(1);
 741               		.loc 1 893 9 is_stmt 1 view .LVU195
 742               	.LBB42:
 743               	.LBI42:
 166:e:\game\msys2\mingw64\avr\include\util\delay.h **** {
 744               		.loc 2 166 1 view .LVU196
 745               	.LBB43:
 168:e:\game\msys2\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 746               		.loc 2 168 2 view .LVU197
 172:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 747               		.loc 2 172 2 view .LVU198
 173:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 748               		.loc 2 173 2 view .LVU199
 174:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 749               		.loc 2 174 2 view .LVU200
 184:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	#endif
 750               		.loc 2 184 3 view .LVU201
 751               		.loc 2 187 2 view .LVU202
 752 001e 8FE9      		ldi r24,lo8(3999)
 753 0020 9FE0      		ldi r25,hi8(3999)
 754 0022 0197      	1:	sbiw r24,1
 755 0024 01F4      		brne 1b
 756 0026 00C0      		rjmp .
 757 0028 0000      		nop
 758               	.LVL81:
 759               		.loc 2 187 2 is_stmt 0 view .LVU203
 760               	.LBE43:
 761               	.LBE42:
 892:tmk_core/common/action.c ****         wait_ms(1);
 762               		.loc 1 892 37 is_stmt 1 view .LVU204
 892:tmk_core/common/action.c ****         wait_ms(1);
 763               		.loc 1 892 38 is_stmt 0 view .LVU205
 764 002a 2197      		sbiw r28,1
 765               	.LVL82:
 892:tmk_core/common/action.c ****         wait_ms(1);
 766               		.loc 1 892 38 view .LVU206
 767 002c 00C0      		rjmp .L49
 768               	.LBE44:
 769               		.cfi_endproc
 770               	.LFE25:
 772               		.section	.text.tap_code,"ax",@progbits
 773               	.global	tap_code
 775               	tap_code:
 776               	.LVL83:
 777               	.LFB26:
 897:tmk_core/common/action.c **** 
 898:tmk_core/common/action.c **** /** \brief Tap a keycode with the default delay.
 899:tmk_core/common/action.c ****  *
 900:tmk_core/common/action.c ****  * \param code The basic keycode to tap. If `code` is `KC_CAPS`, the delay will be `TAP_HOLD_CAPS_D
 901:tmk_core/common/action.c ****  */
 902:tmk_core/common/action.c **** void tap_code(uint8_t code) { tap_code_delay(code, code == KC_CAPS ? TAP_HOLD_CAPS_DELAY : TAP_CODE
 778               		.loc 1 902 29 is_stmt 1 view -0
 779               		.cfi_startproc
 780               	/* prologue: function */
 781               	/* frame size = 0 */
 782               	/* stack size = 0 */
 783               	.L__stack_usage = 0
 784               		.loc 1 902 31 view .LVU208
 785 0000 70E0      		ldi r23,0
 786 0002 60E0      		ldi r22,0
 787 0004 8933      		cpi r24,lo8(57)
 788 0006 01F4      		brne .L52
 789 0008 60E5      		ldi r22,lo8(80)
 790 000a 70E0      		ldi r23,0
 791               	.L52:
 792               		.loc 1 902 31 is_stmt 0 discriminator 4 view .LVU209
 793 000c 0C94 0000 		jmp tap_code_delay
 794               	.LVL84:
 795               		.loc 1 902 31 discriminator 4 view .LVU210
 796               		.cfi_endproc
 797               	.LFE26:
 799               		.section	.text.register_mods,"ax",@progbits
 800               	.global	register_mods
 802               	register_mods:
 803               	.LVL85:
 804               	.LFB27:
 903:tmk_core/common/action.c **** 
 904:tmk_core/common/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 905:tmk_core/common/action.c ****  *
 906:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 907:tmk_core/common/action.c ****  */
 908:tmk_core/common/action.c **** void register_mods(uint8_t mods) {
 805               		.loc 1 908 34 is_stmt 1 view -0
 806               		.cfi_startproc
 807               	/* prologue: function */
 808               	/* frame size = 0 */
 809               	/* stack size = 0 */
 810               	.L__stack_usage = 0
 909:tmk_core/common/action.c ****     if (mods) {
 811               		.loc 1 909 5 view .LVU212
 812               		.loc 1 909 8 is_stmt 0 view .LVU213
 813 0000 8823      		tst r24
 814 0002 01F0      		breq .L54
 910:tmk_core/common/action.c ****         add_mods(mods);
 815               		.loc 1 910 9 is_stmt 1 view .LVU214
 816 0004 0E94 0000 		call add_mods
 817               	.LVL86:
 911:tmk_core/common/action.c ****         send_keyboard_report();
 818               		.loc 1 911 9 view .LVU215
 819 0008 0C94 0000 		jmp send_keyboard_report
 820               	.LVL87:
 821               	.L54:
 822               	/* epilogue start */
 912:tmk_core/common/action.c ****     }
 913:tmk_core/common/action.c **** }
 823               		.loc 1 913 1 is_stmt 0 view .LVU216
 824 000c 0895      		ret
 825               		.cfi_endproc
 826               	.LFE27:
 828               		.section	.text.unregister_mods,"ax",@progbits
 829               	.global	unregister_mods
 831               	unregister_mods:
 832               	.LVL88:
 833               	.LFB28:
 914:tmk_core/common/action.c **** 
 915:tmk_core/common/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 916:tmk_core/common/action.c ****  *
 917:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 918:tmk_core/common/action.c ****  */
 919:tmk_core/common/action.c **** void unregister_mods(uint8_t mods) {
 834               		.loc 1 919 36 is_stmt 1 view -0
 835               		.cfi_startproc
 836               	/* prologue: function */
 837               	/* frame size = 0 */
 838               	/* stack size = 0 */
 839               	.L__stack_usage = 0
 920:tmk_core/common/action.c ****     if (mods) {
 840               		.loc 1 920 5 view .LVU218
 841               		.loc 1 920 8 is_stmt 0 view .LVU219
 842 0000 8823      		tst r24
 843 0002 01F0      		breq .L56
 921:tmk_core/common/action.c ****         del_mods(mods);
 844               		.loc 1 921 9 is_stmt 1 view .LVU220
 845 0004 0E94 0000 		call del_mods
 846               	.LVL89:
 922:tmk_core/common/action.c ****         send_keyboard_report();
 847               		.loc 1 922 9 view .LVU221
 848 0008 0C94 0000 		jmp send_keyboard_report
 849               	.LVL90:
 850               	.L56:
 851               	/* epilogue start */
 923:tmk_core/common/action.c ****     }
 924:tmk_core/common/action.c **** }
 852               		.loc 1 924 1 is_stmt 0 view .LVU222
 853 000c 0895      		ret
 854               		.cfi_endproc
 855               	.LFE28:
 857               		.section	.text.process_action,"ax",@progbits
 858               	.global	process_action
 860               	process_action:
 861               	.LVL91:
 862               	.LFB22:
 240:tmk_core/common/action.c ****     keyevent_t event = record->event;
 863               		.loc 1 240 59 is_stmt 1 view -0
 864               		.cfi_startproc
 240:tmk_core/common/action.c ****     keyevent_t event = record->event;
 865               		.loc 1 240 59 is_stmt 0 view .LVU224
 866 0000 BF92      		push r11
 867               	.LCFI13:
 868               		.cfi_def_cfa_offset 3
 869               		.cfi_offset 11, -2
 870 0002 CF92      		push r12
 871               	.LCFI14:
 872               		.cfi_def_cfa_offset 4
 873               		.cfi_offset 12, -3
 874 0004 DF92      		push r13
 875               	.LCFI15:
 876               		.cfi_def_cfa_offset 5
 877               		.cfi_offset 13, -4
 878 0006 EF92      		push r14
 879               	.LCFI16:
 880               		.cfi_def_cfa_offset 6
 881               		.cfi_offset 14, -5
 882 0008 FF92      		push r15
 883               	.LCFI17:
 884               		.cfi_def_cfa_offset 7
 885               		.cfi_offset 15, -6
 886 000a 0F93      		push r16
 887               	.LCFI18:
 888               		.cfi_def_cfa_offset 8
 889               		.cfi_offset 16, -7
 890 000c 1F93      		push r17
 891               	.LCFI19:
 892               		.cfi_def_cfa_offset 9
 893               		.cfi_offset 17, -8
 894 000e CF93      		push r28
 895               	.LCFI20:
 896               		.cfi_def_cfa_offset 10
 897               		.cfi_offset 28, -9
 898 0010 DF93      		push r29
 899               	.LCFI21:
 900               		.cfi_def_cfa_offset 11
 901               		.cfi_offset 29, -10
 902               	/* prologue: function */
 903               	/* frame size = 0 */
 904               	/* stack size = 9 */
 905               	.L__stack_usage = 9
 906 0012 6C01      		movw r12,r24
 907 0014 D62F      		mov r29,r22
 240:tmk_core/common/action.c ****     keyevent_t event = record->event;
 908               		.loc 1 240 59 view .LVU225
 909 0016 C72F      		mov r28,r23
 241:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 910               		.loc 1 241 5 is_stmt 1 view .LVU226
 241:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 911               		.loc 1 241 16 is_stmt 0 view .LVU227
 912 0018 FC01      		movw r30,r24
 913 001a 1281      		ldd r17,Z+2
 914               	.LVL92:
 243:tmk_core/common/action.c **** #endif
 915               		.loc 1 243 5 is_stmt 1 view .LVU228
 243:tmk_core/common/action.c **** #endif
 916               		.loc 1 243 36 is_stmt 0 view .LVU229
 917 001c 0581      		ldd r16,Z+5
 918 001e 0295      		swap r16
 919 0020 0F70      		andi r16,lo8(15)
 920               	.LVL93:
 247:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 921               		.loc 1 247 5 is_stmt 1 view .LVU230
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 922               		.loc 1 249 5 view .LVU231
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 923               		.loc 1 249 9 is_stmt 0 view .LVU232
 924 0022 0E94 0000 		call is_oneshot_layer_active
 925               	.LVL94:
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 926               		.loc 1 249 9 view .LVU233
 927 0026 E82E      		mov r14,r24
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 928               		.loc 1 249 8 view .LVU234
 929 0028 8823      		tst r24
 930 002a 01F0      		breq .L59
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 931               		.loc 1 249 43 discriminator 1 view .LVU235
 932 002c E12E      		mov r14,r17
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 933               		.loc 1 249 35 discriminator 1 view .LVU236
 934 002e 1123      		tst r17
 935 0030 01F0      		breq .L59
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 936               		.loc 1 249 71 discriminator 2 view .LVU237
 937 0032 8C2F      		mov r24,r28
 938 0034 807F      		andi r24,lo8(-16)
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 939               		.loc 1 249 52 discriminator 2 view .LVU238
 940 0036 8034      		cpi r24,lo8(64)
 941 0038 01F0      		breq .L60
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 942               		.loc 1 249 87 discriminator 3 view .LVU239
 943 003a 80E2      		ldi r24,lo8(32)
 944               	.LVL95:
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 945               		.loc 1 249 87 discriminator 3 view .LVU240
 946 003c 8D0F      		add r24,r29
 247:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 947               		.loc 1 247 10 discriminator 3 view .LVU241
 948 003e E12C      		mov r14,__zero_reg__
 249:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 949               		.loc 1 249 84 discriminator 3 view .LVU242
 950 0040 8830      		cpi r24,lo8(8)
 951 0042 00F0      		brlo .L59
 952               	.L60:
 254:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 953               		.loc 1 254 9 is_stmt 1 view .LVU243
 954 0044 82E0      		ldi r24,lo8(2)
 955 0046 0E94 0000 		call clear_oneshot_layer_state
 956               	.LVL96:
 255:tmk_core/common/action.c ****     }
 957               		.loc 1 255 9 view .LVU244
 255:tmk_core/common/action.c ****     }
 958               		.loc 1 255 31 is_stmt 0 view .LVU245
 959 004a 0E94 0000 		call is_oneshot_layer_active
 960               	.LVL97:
 255:tmk_core/common/action.c ****     }
 961               		.loc 1 255 9 view .LVU246
 962 004e 91E0      		ldi r25,lo8(1)
 963 0050 E82E      		mov r14,r24
 964 0052 E926      		eor r14,r25
 965               	.LVL98:
 966               	.L59:
 259:tmk_core/common/action.c ****         /* Key and Mods */
 967               		.loc 1 259 5 is_stmt 1 view .LVU247
 259:tmk_core/common/action.c ****         /* Key and Mods */
 968               		.loc 1 259 24 is_stmt 0 view .LVU248
 969 0054 BC2E      		mov r11,r28
 970 0056 B294      		swap r11
 971 0058 9FE0      		ldi r25,lo8(15)
 972 005a B922      		and r11,r25
 259:tmk_core/common/action.c ****         /* Key and Mods */
 973               		.loc 1 259 5 view .LVU249
 974 005c EB2D      		mov r30,r11
 975 005e F0E0      		ldi r31,0
 976 0060 E050      		subi r30,lo8(-(gs(.L63)))
 977 0062 F040      		sbci r31,hi8(-(gs(.L63)))
 978 0064 0C94 0000 		jmp __tablejump2__
 979               		.section	.jumptables.gcc.process_action,"a",@progbits
 980               		.p2align	1
 981               	.L63:
 982 0000 0000      		.word gs(.L71)
 983 0002 0000      		.word gs(.L71)
 984 0004 0000      		.word gs(.L70)
 985 0006 0000      		.word gs(.L70)
 986 0008 0000      		.word gs(.L69)
 987 000a 0000      		.word gs(.L68)
 988 000c 0000      		.word gs(.L61)
 989 000e 0000      		.word gs(.L61)
 990 0010 0000      		.word gs(.L67)
 991 0012 0000      		.word gs(.L66)
 992 0014 0000      		.word gs(.L65)
 993 0016 0000      		.word gs(.L65)
 994 0018 0000      		.word gs(.L64)
 995 001a 0000      		.word gs(.L61)
 996 001c 0000      		.word gs(.L61)
 997 001e 0000      		.word gs(.L62)
 998               		.section	.text.process_action
 999               	.L71:
 1000               	.LBB45:
 263:tmk_core/common/action.c ****             if (event.pressed) {
 1001               		.loc 1 263 13 is_stmt 1 view .LVU250
 1002 0068 0C2F      		mov r16,r28
 1003               	.LVL99:
 263:tmk_core/common/action.c ****             if (event.pressed) {
 1004               		.loc 1 263 13 is_stmt 0 view .LVU251
 1005 006a 0F70      		andi r16,lo8(15)
 263:tmk_core/common/action.c ****             if (event.pressed) {
 1006               		.loc 1 263 44 view .LVU252
 1007 006c C07F      		andi r28,lo8(-16)
 1008               	.LVL100:
 263:tmk_core/common/action.c ****             if (event.pressed) {
 1009               		.loc 1 263 21 view .LVU253
 1010 006e 01F0      		breq .L72
 263:tmk_core/common/action.c ****             if (event.pressed) {
 1011               		.loc 1 263 21 discriminator 2 view .LVU254
 1012 0070 0295      		swap r16
 1013 0072 007F      		andi r16,lo8(-16)
 1014               	.L72:
 1015               	.LVL101:
 264:tmk_core/common/action.c ****                 if (mods) {
 1016               		.loc 1 264 13 is_stmt 1 discriminator 4 view .LVU255
 264:tmk_core/common/action.c ****                 if (mods) {
 1017               		.loc 1 264 16 is_stmt 0 discriminator 4 view .LVU256
 1018 0074 1123      		tst r17
 1019 0076 01F0      		breq .L73
 265:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1020               		.loc 1 265 17 is_stmt 1 view .LVU257
 265:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1021               		.loc 1 265 20 is_stmt 0 view .LVU258
 1022 0078 0023      		tst r16
 1023 007a 01F0      		breq .L170
 266:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1024               		.loc 1 266 21 is_stmt 1 view .LVU259
 266:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1025               		.loc 1 266 25 is_stmt 0 view .LVU260
 1026 007c 80E2      		ldi r24,lo8(32)
 1027 007e 8D0F      		add r24,r29
 266:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1028               		.loc 1 266 24 view .LVU261
 1029 0080 8830      		cpi r24,lo8(8)
 1030 0082 00F0      		brlo .L75
 266:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1031               		.loc 1 266 49 discriminator 1 view .LVU262
 1032 0084 D111      		cpse r29,__zero_reg__
 1033 0086 00C0      		rjmp .L76
 1034               	.L75:
 270:tmk_core/common/action.c ****                     } else {
 1035               		.loc 1 270 25 is_stmt 1 view .LVU263
 1036 0088 802F      		mov r24,r16
 1037 008a 0E94 0000 		call add_mods
 1038               	.LVL102:
 1039               	.L77:
 274:tmk_core/common/action.c ****                 }
 1040               		.loc 1 274 21 view .LVU264
 1041 008e 0E94 0000 		call send_keyboard_report
 1042               	.LVL103:
 276:tmk_core/common/action.c ****             } else {
 1043               		.loc 1 276 17 view .LVU265
 1044               	.L170:
 276:tmk_core/common/action.c ****             } else {
 1045               		.loc 1 276 17 is_stmt 0 view .LVU266
 1046               	.LBE45:
 555:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 1047               		.loc 1 555 75 is_stmt 1 view .LVU267
 556:tmk_core/common/action.c ****                         } else {
 1048               		.loc 1 556 29 view .LVU268
 1049 0092 8D2F      		mov r24,r29
 1050 0094 0E94 0000 		call register_code
 1051               	.LVL104:
 1052 0098 00C0      		rjmp .L61
 1053               	.LVL105:
 1054               	.L76:
 1055               	.LBB46:
 272:tmk_core/common/action.c ****                     }
 1056               		.loc 1 272 25 view .LVU269
 1057 009a 802F      		mov r24,r16
 1058 009c 0E94 0000 		call add_weak_mods
 1059               	.LVL106:
 1060 00a0 00C0      		rjmp .L77
 1061               	.L73:
 278:tmk_core/common/action.c ****                 if (mods) {
 1062               		.loc 1 278 17 view .LVU270
 1063 00a2 8D2F      		mov r24,r29
 1064 00a4 0E94 0000 		call unregister_code
 1065               	.LVL107:
 279:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1066               		.loc 1 279 17 view .LVU271
 279:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1067               		.loc 1 279 20 is_stmt 0 view .LVU272
 1068 00a8 0023      		tst r16
 1069 00aa 01F0      		breq .L61
 280:tmk_core/common/action.c ****                         del_mods(mods);
 1070               		.loc 1 280 21 is_stmt 1 view .LVU273
 280:tmk_core/common/action.c ****                         del_mods(mods);
 1071               		.loc 1 280 25 is_stmt 0 view .LVU274
 1072 00ac 80E2      		ldi r24,lo8(32)
 1073 00ae 8D0F      		add r24,r29
 280:tmk_core/common/action.c ****                         del_mods(mods);
 1074               		.loc 1 280 24 view .LVU275
 1075 00b0 8830      		cpi r24,lo8(8)
 1076 00b2 00F0      		brlo .L79
 280:tmk_core/common/action.c ****                         del_mods(mods);
 1077               		.loc 1 280 49 discriminator 1 view .LVU276
 1078 00b4 D111      		cpse r29,__zero_reg__
 1079 00b6 00C0      		rjmp .L80
 1080               	.L79:
 281:tmk_core/common/action.c ****                     } else {
 1081               		.loc 1 281 25 is_stmt 1 view .LVU277
 1082 00b8 802F      		mov r24,r16
 1083 00ba 0E94 0000 		call del_mods
 1084               	.LVL108:
 1085               	.L81:
 285:tmk_core/common/action.c ****                 }
 1086               		.loc 1 285 21 view .LVU278
 1087 00be 0E94 0000 		call send_keyboard_report
 1088               	.LVL109:
 1089               	.L61:
 285:tmk_core/common/action.c ****                 }
 1090               		.loc 1 285 21 is_stmt 0 view .LVU279
 1091               	.LBE46:
 670:tmk_core/common/action.c ****         case ACT_LAYER:
 1092               		.loc 1 670 5 is_stmt 1 view .LVU280
 1093 00c2 2B2D      		mov r18,r11
 1094 00c4 2850      		subi r18,8
 1095 00c6 330B      		sbc r19,r19
 1096 00c8 2430      		cpi r18,4
 1097 00ca 3105      		cpc r19,__zero_reg__
 1098 00cc 00F4      		brsh .L134
 677:tmk_core/common/action.c ****             break;
 1099               		.loc 1 677 13 view .LVU281
 1100 00ce 0E94 0000 		call host_keyboard_leds
 1101               	.LVL110:
 1102 00d2 0E94 0000 		call led_set
 1103               	.LVL111:
 678:tmk_core/common/action.c ****         default:
 1104               		.loc 1 678 13 view .LVU282
 1105               	.L134:
 723:tmk_core/common/action.c ****         record->event.pressed = false;
 1106               		.loc 1 723 5 view .LVU283
 723:tmk_core/common/action.c ****         record->event.pressed = false;
 1107               		.loc 1 723 8 is_stmt 0 view .LVU284
 1108 00d6 EE20      		tst r14
 1109 00d8 01F4      		brne .+2
 1110 00da 00C0      		rjmp .L58
 723:tmk_core/common/action.c ****         record->event.pressed = false;
 1111               		.loc 1 723 33 discriminator 1 view .LVU285
 1112 00dc 0E94 0000 		call get_oneshot_layer_state
 1113               	.LVL112:
 723:tmk_core/common/action.c ****         record->event.pressed = false;
 1114               		.loc 1 723 28 discriminator 1 view .LVU286
 1115 00e0 80FD      		sbrc r24,0
 1116 00e2 00C0      		rjmp .L58
 724:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1117               		.loc 1 724 9 is_stmt 1 view .LVU287
 724:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1118               		.loc 1 724 31 is_stmt 0 view .LVU288
 1119 00e4 F601      		movw r30,r12
 1120 00e6 1282      		std Z+2,__zero_reg__
 725:tmk_core/common/action.c ****         process_record(record);
 1121               		.loc 1 725 9 is_stmt 1 view .LVU289
 1122 00e8 0E94 0000 		call get_oneshot_layer
 1123               	.LVL113:
 1124 00ec 0E94 0000 		call layer_on
 1125               	.LVL114:
 726:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 1126               		.loc 1 726 9 view .LVU290
 1127 00f0 C601      		movw r24,r12
 1128 00f2 0E94 0000 		call process_record
 1129               	.LVL115:
 727:tmk_core/common/action.c ****     }
 1130               		.loc 1 727 9 view .LVU291
 1131 00f6 0E94 0000 		call get_oneshot_layer
 1132               	.LVL116:
 1133               	/* epilogue start */
 730:tmk_core/common/action.c **** 
 1134               		.loc 1 730 1 is_stmt 0 view .LVU292
 1135 00fa DF91      		pop r29
 1136               	.LVL117:
 730:tmk_core/common/action.c **** 
 1137               		.loc 1 730 1 view .LVU293
 1138 00fc CF91      		pop r28
 730:tmk_core/common/action.c **** 
 1139               		.loc 1 730 1 view .LVU294
 1140 00fe 1F91      		pop r17
 1141 0100 0F91      		pop r16
 1142 0102 FF90      		pop r15
 1143 0104 EF90      		pop r14
 1144               	.LVL118:
 730:tmk_core/common/action.c **** 
 1145               		.loc 1 730 1 view .LVU295
 1146 0106 DF90      		pop r13
 1147 0108 CF90      		pop r12
 1148               	.LVL119:
 730:tmk_core/common/action.c **** 
 1149               		.loc 1 730 1 view .LVU296
 1150 010a BF90      		pop r11
 727:tmk_core/common/action.c ****     }
 1151               		.loc 1 727 9 view .LVU297
 1152 010c 0C94 0000 		jmp layer_off
 1153               	.LVL120:
 1154               	.L80:
 1155               	.LBB47:
 283:tmk_core/common/action.c ****                     }
 1156               		.loc 1 283 25 is_stmt 1 view .LVU298
 1157 0110 802F      		mov r24,r16
 1158 0112 0E94 0000 		call del_weak_mods
 1159               	.LVL121:
 1160 0116 00C0      		rjmp .L81
 1161               	.LVL122:
 1162               	.L70:
 283:tmk_core/common/action.c ****                     }
 1163               		.loc 1 283 25 is_stmt 0 view .LVU299
 1164               	.LBE47:
 1165               	.LBB48:
 292:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1166               		.loc 1 292 13 is_stmt 1 view .LVU300
 1167 0118 FC2F      		mov r31,r28
 1168 011a FF70      		andi r31,lo8(15)
 1169 011c FF2E      		mov r15,r31
 292:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1170               		.loc 1 292 44 is_stmt 0 view .LVU301
 1171 011e C07F      		andi r28,lo8(-16)
 1172               	.LVL123:
 292:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1173               		.loc 1 292 21 view .LVU302
 1174 0120 C032      		cpi r28,lo8(32)
 1175 0122 01F0      		breq .L82
 292:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1176               		.loc 1 292 21 discriminator 2 view .LVU303
 1177 0124 F294      		swap r15
 1178 0126 80EF      		ldi r24,lo8(-16)
 1179 0128 F822      		and r15,r24
 1180               	.L82:
 1181               	.LVL124:
 293:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 1182               		.loc 1 293 13 is_stmt 1 discriminator 4 view .LVU304
 1183 012a DD23      		tst r29
 1184 012c 01F0      		breq .L83
 1185 012e D130      		cpi r29,lo8(1)
 1186 0130 01F0      		breq .L84
 348:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1187               		.loc 1 348 21 view .LVU305
 348:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1188               		.loc 1 348 24 is_stmt 0 view .LVU306
 1189 0132 1123      		tst r17
 1190 0134 01F0      		breq .L92
 349:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1191               		.loc 1 349 25 is_stmt 1 view .LVU307
 349:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1192               		.loc 1 349 28 is_stmt 0 view .LVU308
 1193 0136 0023      		tst r16
 1194 0138 01F0      		breq .L93
 351:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1195               		.loc 1 351 29 is_stmt 1 view .LVU309
 355:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 1196               		.loc 1 355 33 is_stmt 0 view .LVU310
 1197 013a F601      		movw r30,r12
 1198 013c 8581      		ldd r24,Z+5
 351:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1199               		.loc 1 351 32 view .LVU311
 1200 013e 80FF      		sbrs r24,0
 1201 0140 00C0      		rjmp .L170
 356:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 1202               		.loc 1 356 76 is_stmt 1 view .LVU312
 358:tmk_core/common/action.c ****                                 register_mods(mods);
 1203               		.loc 1 358 33 view .LVU313
 358:tmk_core/common/action.c ****                                 register_mods(mods);
 1204               		.loc 1 358 51 is_stmt 0 view .LVU314
 1205 0142 8F70      		andi r24,lo8(15)
 1206 0144 8583      		std Z+5,r24
 359:tmk_core/common/action.c ****                             } else
 1207               		.loc 1 359 33 is_stmt 1 view .LVU315
 1208 0146 00C0      		rjmp .L93
 1209               	.L83:
 297:tmk_core/common/action.c ****                         if (tap_count == 0) {
 1210               		.loc 1 297 21 view .LVU316
 297:tmk_core/common/action.c ****                         if (tap_count == 0) {
 1211               		.loc 1 297 24 is_stmt 0 view .LVU317
 1212 0148 1123      		tst r17
 1213 014a 01F0      		breq .L86
 298:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1214               		.loc 1 298 25 is_stmt 1 view .LVU318
 298:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1215               		.loc 1 298 28 is_stmt 0 view .LVU319
 1216 014c 0111      		cpse r16,__zero_reg__
 1217 014e 00C0      		rjmp .L87
 1218               	.L88:
 312:tmk_core/common/action.c ****                         }
 1219               		.loc 1 312 29 is_stmt 1 view .LVU320
 312:tmk_core/common/action.c ****                         }
 1220               		.loc 1 312 50 is_stmt 0 view .LVU321
 1221 0150 0E94 0000 		call get_oneshot_mods
 1222               	.LVL125:
 312:tmk_core/common/action.c ****                         }
 1223               		.loc 1 312 29 view .LVU322
 1224 0154 8F29      		or r24,r15
 1225               	.LVL126:
 1226               	.L169:
 312:tmk_core/common/action.c ****                         }
 1227               		.loc 1 312 29 view .LVU323
 1228               	.LBE48:
 482:tmk_core/common/action.c ****             } else {
 1229               		.loc 1 482 17 view .LVU324
 1230 0156 0E94 0000 		call register_mods
 1231               	.LVL127:
 1232 015a 00C0      		rjmp .L61
 1233               	.LVL128:
 1234               	.L87:
 1235               	.LBB51:
 301:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1236               		.loc 1 301 32 is_stmt 1 view .LVU325
 301:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1237               		.loc 1 301 35 is_stmt 0 view .LVU326
 1238 015c 0130      		cpi r16,lo8(1)
 1239 015e 01F4      		brne .L88
 302:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 1240               		.loc 1 302 65 is_stmt 1 view .LVU327
 303:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1241               		.loc 1 303 29 view .LVU328
 303:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1242               		.loc 1 303 53 is_stmt 0 view .LVU329
 1243 0160 0E94 0000 		call get_oneshot_mods
 1244               	.LVL129:
 303:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1245               		.loc 1 303 29 view .LVU330
 1246 0164 8F29      		or r24,r15
 1247 0166 0E94 0000 		call set_oneshot_mods
 1248               	.LVL130:
 1249 016a 00C0      		rjmp .L61
 1250               	.L86:
 315:tmk_core/common/action.c ****                             clear_oneshot_mods();
 1251               		.loc 1 315 25 is_stmt 1 view .LVU331
 315:tmk_core/common/action.c ****                             clear_oneshot_mods();
 1252               		.loc 1 315 28 is_stmt 0 view .LVU332
 1253 016c 0111      		cpse r16,__zero_reg__
 1254 016e 00C0      		rjmp .L89
 1255               	.L172:
 330:tmk_core/common/action.c ****                             unregister_mods(mods);
 1256               		.loc 1 330 29 is_stmt 1 view .LVU333
 1257 0170 0E94 0000 		call clear_oneshot_mods
 1258               	.LVL131:
 331:tmk_core/common/action.c ****                         }
 1259               		.loc 1 331 29 view .LVU334
 1260               	.L95:
 380:tmk_core/common/action.c ****                             unregister_mods(mods);
 1261               		.loc 1 380 67 view .LVU335
 381:tmk_core/common/action.c ****                         }
 1262               		.loc 1 381 29 view .LVU336
 1263 0174 8F2D      		mov r24,r15
 1264 0176 0E94 0000 		call unregister_mods
 1265               	.LVL132:
 1266 017a 00C0      		rjmp .L61
 1267               	.L89:
 318:tmk_core/common/action.c ****                             // Retain Oneshot mods
 1268               		.loc 1 318 32 view .LVU337
 318:tmk_core/common/action.c ****                             // Retain Oneshot mods
 1269               		.loc 1 318 35 is_stmt 0 view .LVU338
 1270 017c 0130      		cpi r16,lo8(1)
 1271 017e 01F4      		brne .+2
 1272 0180 00C0      		rjmp .L61
 1273 0182 00C0      		rjmp .L172
 1274               	.L84:
 337:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1275               		.loc 1 337 21 is_stmt 1 view .LVU339
 337:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1276               		.loc 1 337 24 is_stmt 0 view .LVU340
 1277 0184 1123      		tst r17
 1278 0186 01F0      		breq .L91
 338:tmk_core/common/action.c ****                             register_mods(mods);
 1279               		.loc 1 338 25 is_stmt 1 view .LVU341
 338:tmk_core/common/action.c ****                             register_mods(mods);
 1280               		.loc 1 338 28 is_stmt 0 view .LVU342
 1281 0188 0630      		cpi r16,lo8(6)
 1282 018a 00F0      		brlo .+2
 1283 018c 00C0      		rjmp .L61
 1284               	.L93:
 367:tmk_core/common/action.c ****                             register_mods(mods);
 1285               		.loc 1 367 67 is_stmt 1 view .LVU343
 368:tmk_core/common/action.c ****                         }
 1286               		.loc 1 368 29 view .LVU344
 1287 018e 8F2D      		mov r24,r15
 1288 0190 00C0      		rjmp .L169
 1289               	.L91:
 342:tmk_core/common/action.c ****                             unregister_mods(mods);
 1290               		.loc 1 342 25 view .LVU345
 342:tmk_core/common/action.c ****                             unregister_mods(mods);
 1291               		.loc 1 342 28 is_stmt 0 view .LVU346
 1292 0192 0530      		cpi r16,lo8(5)
 1293 0194 00F0      		brlo .+2
 1294 0196 00C0      		rjmp .L61
 1295 0198 00C0      		rjmp .L95
 1296               	.L92:
 371:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1297               		.loc 1 371 25 is_stmt 1 view .LVU347
 371:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1298               		.loc 1 371 28 is_stmt 0 view .LVU348
 1299 019a 0023      		tst r16
 1300 019c 01F0      		breq .L95
 372:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1301               		.loc 1 372 71 is_stmt 1 view .LVU349
 373:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1302               		.loc 1 373 29 view .LVU350
 373:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1303               		.loc 1 373 32 is_stmt 0 view .LVU351
 1304 019e D933      		cpi r29,lo8(57)
 1305 01a0 01F4      		brne .L133
 374:tmk_core/common/action.c ****                             } else {
 1306               		.loc 1 374 33 is_stmt 1 view .LVU352
 1307               	.LVL133:
 1308               	.LBB49:
 1309               	.LBI49:
 166:e:\game\msys2\mingw64\avr\include\util\delay.h **** {
 1310               		.loc 2 166 1 view .LVU353
 1311               	.LBB50:
 168:e:\game\msys2\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1312               		.loc 2 168 2 view .LVU354
 172:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1313               		.loc 2 172 2 view .LVU355
 173:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1314               		.loc 2 173 2 view .LVU356
 174:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 1315               		.loc 2 174 2 view .LVU357
 184:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	#endif
 1316               		.loc 2 184 3 view .LVU358
 1317               		.loc 2 187 2 view .LVU359
 1318 01a2 FFEF      		ldi r31,lo8(255999)
 1319 01a4 27EE      		ldi r18,hi8(255999)
 1320 01a6 33E0      		ldi r19,hlo8(255999)
 1321 01a8 F150      	1:	subi r31,1
 1322 01aa 2040      		sbci r18,0
 1323 01ac 3040      		sbci r19,0
 1324 01ae 01F4      		brne 1b
 1325               	.LVL134:
 1326               	.L173:
 1327               		.loc 2 187 2 is_stmt 0 view .LVU360
 1328               	.LBE50:
 1329               	.LBE49:
 1330               	.LBE51:
 1331               	.LBB52:
 1332               	.LBB53:
 1333 01b0 00C0      		rjmp .
 1334 01b2 0000      		nop
 1335               	.L133:
 1336               	.LBE53:
 1337               	.LBE52:
 569:tmk_core/common/action.c ****                         } else {
 1338               		.loc 1 569 29 is_stmt 1 view .LVU361
 1339 01b4 8D2F      		mov r24,r29
 1340 01b6 0E94 0000 		call unregister_code
 1341               	.LVL135:
 1342 01ba 00C0      		rjmp .L61
 1343               	.L69:
 391:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1344               		.loc 1 391 13 view .LVU362
 391:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1345               		.loc 1 391 33 is_stmt 0 view .LVU363
 1346 01bc 8C2F      		mov r24,r28
 1347 01be 8695      		lsr r24
 1348 01c0 8695      		lsr r24
 1349 01c2 8370      		andi r24,lo8(3)
 1350 01c4 01F0      		breq .L98
 1351 01c6 8130      		cpi r24,lo8(1)
 1352 01c8 01F0      		breq .+2
 1353 01ca 00C0      		rjmp .L61
 400:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1354               		.loc 1 400 21 is_stmt 1 view .LVU364
 401:tmk_core/common/action.c ****                     } else {
 1355               		.loc 1 401 25 is_stmt 0 view .LVU365
 1356 01cc 8D2F      		mov r24,r29
 1357 01ce 9C2F      		mov r25,r28
 1358 01d0 9370      		andi r25,lo8(3)
 400:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1359               		.loc 1 400 24 view .LVU366
 1360 01d2 1111      		cpse r17,__zero_reg__
 1361 01d4 00C0      		rjmp .L171
 403:tmk_core/common/action.c ****                     }
 1362               		.loc 1 403 25 is_stmt 1 view .LVU367
 1363 01d6 90E0      		ldi r25,0
 1364 01d8 80E0      		ldi r24,0
 1365               	.L171:
 1366 01da 0E94 0000 		call host_consumer_send
 1367               	.LVL136:
 1368 01de 00C0      		rjmp .L61
 1369               	.L98:
 393:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1370               		.loc 1 393 21 view .LVU368
 394:tmk_core/common/action.c ****                     } else {
 1371               		.loc 1 394 25 is_stmt 0 view .LVU369
 1372 01e0 8D2F      		mov r24,r29
 1373 01e2 9C2F      		mov r25,r28
 1374 01e4 9370      		andi r25,lo8(3)
 393:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1375               		.loc 1 393 24 view .LVU370
 1376 01e6 1111      		cpse r17,__zero_reg__
 1377 01e8 00C0      		rjmp .L167
 396:tmk_core/common/action.c ****                     }
 1378               		.loc 1 396 25 is_stmt 1 view .LVU371
 1379 01ea 90E0      		ldi r25,0
 1380 01ec 80E0      		ldi r24,0
 1381               	.L167:
 1382 01ee 0E94 0000 		call host_system_send
 1383               	.LVL137:
 1384 01f2 00C0      		rjmp .L61
 1385               	.L68:
 412:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 1386               		.loc 1 412 13 view .LVU372
 413:tmk_core/common/action.c ****             } else {
 1387               		.loc 1 413 17 is_stmt 0 view .LVU373
 1388 01f4 8D2F      		mov r24,r29
 412:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 1389               		.loc 1 412 16 view .LVU374
 1390 01f6 1123      		tst r17
 1391 01f8 01F0      		breq .L102
 413:tmk_core/common/action.c ****             } else {
 1392               		.loc 1 413 17 is_stmt 1 view .LVU375
 1393 01fa 0E94 0000 		call mousekey_on
 1394               	.LVL138:
 1395               	.L103:
 417:tmk_core/common/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 1396               		.loc 1 417 13 view .LVU376
 428:tmk_core/common/action.c ****                     break;
 1397               		.loc 1 428 21 view .LVU377
 1398 01fe 0E94 0000 		call mousekey_send
 1399               	.LVL139:
 429:tmk_core/common/action.c ****             }
 1400               		.loc 1 429 21 view .LVU378
 1401 0202 00C0      		rjmp .L61
 1402               	.L102:
 415:tmk_core/common/action.c ****             }
 1403               		.loc 1 415 17 view .LVU379
 1404 0204 0E94 0000 		call mousekey_off
 1405               	.LVL140:
 1406 0208 00C0      		rjmp .L103
 1407               	.L67:
 435:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1408               		.loc 1 435 13 view .LVU380
 435:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1409               		.loc 1 435 39 is_stmt 0 view .LVU381
 1410 020a 8C2F      		mov r24,r28
 1411 020c 8370      		andi r24,lo8(3)
 435:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1412               		.loc 1 435 16 view .LVU382
 1413 020e 01F0      		breq .+2
 1414 0210 00C0      		rjmp .L104
 437:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1415               		.loc 1 437 17 is_stmt 1 view .LVU383
 437:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1416               		.loc 1 437 20 is_stmt 0 view .LVU384
 1417 0212 1111      		cpse r17,__zero_reg__
 1418 0214 00C0      		rjmp .L61
 1419               	.LBB55:
 438:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1420               		.loc 1 438 21 is_stmt 1 view .LVU385
 1421               	.LVL141:
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1422               		.loc 1 439 21 view .LVU386
 438:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1423               		.loc 1 438 61 is_stmt 0 view .LVU387
 1424 0216 4D2F      		mov r20,r29
 1425 0218 4295      		swap r20
 1426 021a 4695      		lsr r20
 1427 021c 4770      		andi r20,lo8(7)
 438:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1428               		.loc 1 438 35 view .LVU388
 1429 021e 440F      		lsl r20
 1430 0220 440F      		lsl r20
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1431               		.loc 1 439 77 view .LVU389
 1432 0222 0D2F      		mov r16,r29
 1433               	.LVL142:
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1434               		.loc 1 439 77 view .LVU390
 1435 0224 0F70      		andi r16,lo8(15)
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1436               		.loc 1 439 44 view .LVU391
 1437 0226 10E0      		ldi r17,0
 1438               	.LVL143:
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1439               		.loc 1 439 44 view .LVU392
 1440 0228 30E0      		ldi r19,0
 1441 022a 20E0      		ldi r18,0
 439:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1442               		.loc 1 439 35 view .LVU393
 1443 022c 042E      		mov r0,r20
 1444 022e 00C0      		rjmp 2f
 1445               		1:
 1446 0230 000F      		lsl r16
 1447 0232 111F      		rol r17
 1448 0234 221F      		rol r18
 1449 0236 331F      		rol r19
 1450               		2:
 1451 0238 0A94      		dec r0
 1452 023a 02F4      		brpl 1b
 1453               	.LVL144:
 440:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1454               		.loc 1 440 21 is_stmt 1 view .LVU394
 440:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1455               		.loc 1 440 104 is_stmt 0 view .LVU395
 1456 023c 60E0      		ldi r22,0
 1457 023e 70E0      		ldi r23,0
 1458 0240 CB01      		movw r24,r22
 1459 0242 D4FF      		sbrs r29,4
 1460 0244 00C0      		rjmp .L105
 440:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1461               		.loc 1 440 94 discriminator 1 view .LVU396
 1462 0246 6FE0      		ldi r22,lo8(15)
 1463 0248 70E0      		ldi r23,0
 1464 024a 80E0      		ldi r24,0
 1465 024c 90E0      		ldi r25,0
 1466 024e 00C0      		rjmp 2f
 1467               		1:
 1468 0250 660F      		lsl r22
 1469 0252 771F      		rol r23
 1470 0254 881F      		rol r24
 1471 0256 991F      		rol r25
 1472               		2:
 1473 0258 4A95      		dec r20
 1474 025a 02F4      		brpl 1b
 440:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1475               		.loc 1 440 104 discriminator 1 view .LVU397
 1476 025c 6095      		com r22
 1477 025e 7095      		com r23
 1478 0260 8095      		com r24
 1479 0262 9095      		com r25
 1480               	.L105:
 1481               	.LVL145:
 441:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1482               		.loc 1 441 21 is_stmt 1 discriminator 4 view .LVU398
 441:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1483               		.loc 1 441 47 is_stmt 0 discriminator 4 view .LVU399
 1484 0264 C695      		lsr r28
 1485 0266 C695      		lsr r28
 1486               	.LVL146:
 441:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1487               		.loc 1 441 47 discriminator 4 view .LVU400
 1488 0268 C370      		andi r28,lo8(3)
 1489 026a 602B      		or r22,r16
 1490               	.LVL147:
 441:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1491               		.loc 1 441 47 discriminator 4 view .LVU401
 1492 026c 712B      		or r23,r17
 1493 026e 822B      		or r24,r18
 1494 0270 932B      		or r25,r19
 1495 0272 C230      		cpi r28,lo8(2)
 1496 0274 01F0      		breq .L106
 1497 0276 00F4      		brsh .L107
 1498 0278 C130      		cpi r28,lo8(1)
 1499 027a 01F0      		breq .L108
 443:tmk_core/common/action.c ****                             break;
 1500               		.loc 1 443 29 is_stmt 1 view .LVU402
 1501 027c 0E94 0000 		call default_layer_and
 1502               	.LVL148:
 444:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1503               		.loc 1 444 29 view .LVU403
 1504 0280 00C0      		rjmp .L61
 1505               	.L108:
 446:tmk_core/common/action.c ****                             break;
 1506               		.loc 1 446 29 view .LVU404
 1507 0282 0E94 0000 		call default_layer_or
 1508               	.LVL149:
 447:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1509               		.loc 1 447 29 view .LVU405
 1510 0286 00C0      		rjmp .L61
 1511               	.L106:
 449:tmk_core/common/action.c ****                             break;
 1512               		.loc 1 449 29 view .LVU406
 1513 0288 0E94 0000 		call default_layer_xor
 1514               	.LVL150:
 450:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1515               		.loc 1 450 29 view .LVU407
 1516 028c 00C0      		rjmp .L61
 1517               	.L107:
 452:tmk_core/common/action.c ****                             break;
 1518               		.loc 1 452 29 view .LVU408
 1519 028e 0E94 0000 		call default_layer_set
 1520               	.LVL151:
 453:tmk_core/common/action.c ****                     }
 1521               		.loc 1 453 29 view .LVU409
 1522 0292 00C0      		rjmp .L61
 1523               	.LVL152:
 1524               	.L104:
 453:tmk_core/common/action.c ****                     }
 1525               		.loc 1 453 29 is_stmt 0 view .LVU410
 1526               	.LBE55:
 458:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1527               		.loc 1 458 17 is_stmt 1 view .LVU411
 458:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1528               		.loc 1 458 21 is_stmt 0 view .LVU412
 1529 0294 8695      		lsr r24
 1530 0296 1123      		tst r17
 1531 0298 01F0      		breq .L110
 458:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1532               		.loc 1 458 21 discriminator 1 view .LVU413
 1533 029a 8C2F      		mov r24,r28
 1534 029c 8170      		andi r24,lo8(1)
 1535               	.L110:
 458:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1536               		.loc 1 458 20 discriminator 4 view .LVU414
 1537 029e 8823      		tst r24
 1538 02a0 01F4      		brne .+2
 1539 02a2 00C0      		rjmp .L61
 1540               	.LBB56:
 459:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1541               		.loc 1 459 21 is_stmt 1 view .LVU415
 1542               	.LVL153:
 460:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1543               		.loc 1 460 21 view .LVU416
 459:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1544               		.loc 1 459 61 is_stmt 0 view .LVU417
 1545 02a4 4D2F      		mov r20,r29
 1546 02a6 4295      		swap r20
 1547 02a8 4695      		lsr r20
 1548 02aa 4770      		andi r20,lo8(7)
 459:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1549               		.loc 1 459 35 view .LVU418
 1550 02ac 440F      		lsl r20
 1551 02ae 440F      		lsl r20
 460:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1552               		.loc 1 460 77 view .LVU419
 1553 02b0 0D2F      		mov r16,r29
 1554               	.LVL154:
 460:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1555               		.loc 1 460 77 view .LVU420
 1556 02b2 0F70      		andi r16,lo8(15)
 460:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1557               		.loc 1 460 44 view .LVU421
 1558 02b4 10E0      		ldi r17,0
 1559               	.LVL155:
 460:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1560               		.loc 1 460 44 view .LVU422
 1561 02b6 30E0      		ldi r19,0
 1562 02b8 20E0      		ldi r18,0
 460:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1563               		.loc 1 460 35 view .LVU423
 1564 02ba 042E      		mov r0,r20
 1565 02bc 00C0      		rjmp 2f
 1566               		1:
 1567 02be 000F      		lsl r16
 1568 02c0 111F      		rol r17
 1569 02c2 221F      		rol r18
 1570 02c4 331F      		rol r19
 1571               		2:
 1572 02c6 0A94      		dec r0
 1573 02c8 02F4      		brpl 1b
 1574               	.LVL156:
 461:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1575               		.loc 1 461 21 is_stmt 1 view .LVU424
 461:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1576               		.loc 1 461 104 is_stmt 0 view .LVU425
 1577 02ca 60E0      		ldi r22,0
 1578 02cc 70E0      		ldi r23,0
 1579 02ce CB01      		movw r24,r22
 1580 02d0 D4FF      		sbrs r29,4
 1581 02d2 00C0      		rjmp .L111
 461:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1582               		.loc 1 461 94 discriminator 1 view .LVU426
 1583 02d4 6FE0      		ldi r22,lo8(15)
 1584 02d6 70E0      		ldi r23,0
 1585 02d8 80E0      		ldi r24,0
 1586 02da 90E0      		ldi r25,0
 1587 02dc 00C0      		rjmp 2f
 1588               		1:
 1589 02de 660F      		lsl r22
 1590 02e0 771F      		rol r23
 1591 02e2 881F      		rol r24
 1592 02e4 991F      		rol r25
 1593               		2:
 1594 02e6 4A95      		dec r20
 1595 02e8 02F4      		brpl 1b
 461:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1596               		.loc 1 461 104 discriminator 1 view .LVU427
 1597 02ea 6095      		com r22
 1598 02ec 7095      		com r23
 1599 02ee 8095      		com r24
 1600 02f0 9095      		com r25
 1601               	.L111:
 1602               	.LVL157:
 462:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1603               		.loc 1 462 21 is_stmt 1 discriminator 4 view .LVU428
 462:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1604               		.loc 1 462 47 is_stmt 0 discriminator 4 view .LVU429
 1605 02f2 C695      		lsr r28
 1606 02f4 C695      		lsr r28
 1607               	.LVL158:
 462:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1608               		.loc 1 462 47 discriminator 4 view .LVU430
 1609 02f6 C370      		andi r28,lo8(3)
 1610 02f8 602B      		or r22,r16
 1611               	.LVL159:
 462:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1612               		.loc 1 462 47 discriminator 4 view .LVU431
 1613 02fa 712B      		or r23,r17
 1614 02fc 822B      		or r24,r18
 1615 02fe 932B      		or r25,r19
 1616 0300 C230      		cpi r28,lo8(2)
 1617 0302 01F0      		breq .L112
 1618 0304 00F4      		brsh .L113
 1619 0306 C130      		cpi r28,lo8(1)
 1620 0308 01F0      		breq .L114
 464:tmk_core/common/action.c ****                             break;
 1621               		.loc 1 464 29 is_stmt 1 view .LVU432
 1622 030a 0E94 0000 		call layer_and
 1623               	.LVL160:
 465:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1624               		.loc 1 465 29 view .LVU433
 1625 030e 00C0      		rjmp .L61
 1626               	.L114:
 467:tmk_core/common/action.c ****                             break;
 1627               		.loc 1 467 29 view .LVU434
 1628 0310 0E94 0000 		call layer_or
 1629               	.LVL161:
 468:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1630               		.loc 1 468 29 view .LVU435
 1631 0314 00C0      		rjmp .L61
 1632               	.L112:
 470:tmk_core/common/action.c ****                             break;
 1633               		.loc 1 470 29 view .LVU436
 1634 0316 0E94 0000 		call layer_xor
 1635               	.LVL162:
 471:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1636               		.loc 1 471 29 view .LVU437
 1637 031a 00C0      		rjmp .L61
 1638               	.L113:
 473:tmk_core/common/action.c ****                             break;
 1639               		.loc 1 473 29 view .LVU438
 1640 031c 0E94 0000 		call layer_state_set
 1641               	.LVL163:
 474:tmk_core/common/action.c ****                     }
 1642               		.loc 1 474 29 view .LVU439
 1643 0320 00C0      		rjmp .L61
 1644               	.LVL164:
 1645               	.L66:
 474:tmk_core/common/action.c ****                     }
 1646               		.loc 1 474 29 is_stmt 0 view .LVU440
 1647               	.LBE56:
 480:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1648               		.loc 1 480 13 is_stmt 1 view .LVU441
 1649 0322 CF70      		andi r28,lo8(15)
 1650               	.LVL165:
 480:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1651               		.loc 1 480 16 is_stmt 0 view .LVU442
 1652 0324 1123      		tst r17
 1653 0326 01F0      		breq .L115
 481:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 1654               		.loc 1 481 17 is_stmt 1 view .LVU443
 1655 0328 8C2F      		mov r24,r28
 1656 032a 0E94 0000 		call layer_on
 1657               	.LVL166:
 482:tmk_core/common/action.c ****             } else {
 1658               		.loc 1 482 17 view .LVU444
 1659 032e 8D2F      		mov r24,r29
 1660 0330 00C0      		rjmp .L169
 1661               	.L115:
 484:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 1662               		.loc 1 484 17 view .LVU445
 1663 0332 8D2F      		mov r24,r29
 1664 0334 0E94 0000 		call unregister_mods
 1665               	.LVL167:
 485:tmk_core/common/action.c ****             }
 1666               		.loc 1 485 17 view .LVU446
 1667 0338 8C2F      		mov r24,r28
 1668               	.LVL168:
 1669               	.L166:
 572:tmk_core/common/action.c ****                         }
 1670               		.loc 1 572 29 is_stmt 0 view .LVU447
 1671 033a 0E94 0000 		call layer_off
 1672               	.LVL169:
 1673 033e 00C0      		rjmp .L61
 1674               	.L65:
 491:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1675               		.loc 1 491 13 is_stmt 1 view .LVU448
 1676 0340 D23F      		cpi r29,lo8(-14)
 1677 0342 01F0      		breq .L116
 1678 0344 00F4      		brsh .L117
 1679 0346 D03F      		cpi r29,lo8(-16)
 1680 0348 01F0      		breq .L118
 1681 034a D13F      		cpi r29,lo8(-15)
 1682 034c 01F0      		breq .L119
 1683               	.L120:
 553:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1684               		.loc 1 553 21 view .LVU449
 553:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1685               		.loc 1 553 24 is_stmt 0 view .LVU450
 1686 034e 1123      		tst r17
 1687 0350 01F4      		brne .+2
 1688 0352 00C0      		rjmp .L129
 554:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1689               		.loc 1 554 25 is_stmt 1 view .LVU451
 554:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1690               		.loc 1 554 28 is_stmt 0 view .LVU452
 1691 0354 0111      		cpse r16,__zero_reg__
 1692 0356 00C0      		rjmp .L170
 558:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 1693               		.loc 1 558 76 is_stmt 1 view .LVU453
 559:tmk_core/common/action.c ****                         }
 1694               		.loc 1 559 29 view .LVU454
 1695 0358 8C2F      		mov r24,r28
 1696 035a 8F71      		andi r24,lo8(31)
 1697 035c 00C0      		rjmp .L168
 1698               	.L117:
 1699 035e D33F      		cpi r29,lo8(-13)
 1700 0360 01F0      		breq .L121
 1701 0362 D43F      		cpi r29,lo8(-12)
 1702 0364 01F4      		brne .L120
 539:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1703               		.loc 1 539 21 view .LVU455
 539:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1704               		.loc 1 539 24 is_stmt 0 view .LVU456
 1705 0366 1123      		tst r17
 1706 0368 01F0      		breq .L128
 540:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1707               		.loc 1 540 25 is_stmt 1 view .LVU457
 540:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1708               		.loc 1 540 50 is_stmt 0 view .LVU458
 1709 036a CF71      		andi r28,lo8(31)
 1710               	.LVL170:
 540:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1711               		.loc 1 540 25 view .LVU459
 1712 036c 8C2F      		mov r24,r28
 1713 036e 0E94 0000 		call layer_on
 1714               	.LVL171:
 541:tmk_core/common/action.c ****                     } else {
 1715               		.loc 1 541 25 is_stmt 1 view .LVU460
 1716 0372 63E0      		ldi r22,lo8(3)
 1717 0374 8C2F      		mov r24,r28
 1718 0376 0E94 0000 		call set_oneshot_layer
 1719               	.LVL172:
 1720 037a 00C0      		rjmp .L61
 1721               	.LVL173:
 1722               	.L118:
 494:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1723               		.loc 1 494 21 view .LVU461
 494:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1724               		.loc 1 494 24 is_stmt 0 view .LVU462
 1725 037c 1123      		tst r17
 1726 037e 01F0      		breq .L123
 495:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1727               		.loc 1 495 25 is_stmt 1 view .LVU463
 495:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1728               		.loc 1 495 28 is_stmt 0 view .LVU464
 1729 0380 0530      		cpi r16,lo8(5)
 1730 0382 00F0      		brlo .+2
 1731 0384 00C0      		rjmp .L61
 1732               	.L124:
 496:tmk_core/common/action.c ****                         }
 1733               		.loc 1 496 29 is_stmt 1 view .LVU465
 1734 0386 8C2F      		mov r24,r28
 1735 0388 8F71      		andi r24,lo8(31)
 1736 038a 0E94 0000 		call layer_invert
 1737               	.LVL174:
 1738 038e 00C0      		rjmp .L61
 1739               	.L123:
 499:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1740               		.loc 1 499 25 view .LVU466
 499:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1741               		.loc 1 499 28 is_stmt 0 view .LVU467
 1742 0390 0630      		cpi r16,lo8(6)
 1743 0392 00F0      		brlo .+2
 1744 0394 00C0      		rjmp .L61
 1745 0396 00C0      		rjmp .L124
 1746               	.L119:
 505:tmk_core/common/action.c ****                     break;
 1747               		.loc 1 505 21 is_stmt 1 view .LVU468
 1748 0398 8C2F      		mov r24,r28
 1749 039a 8F71      		andi r24,lo8(31)
 505:tmk_core/common/action.c ****                     break;
 1750               		.loc 1 505 68 is_stmt 0 view .LVU469
 1751 039c 1123      		tst r17
 1752 039e 01F0      		breq .L166
 1753               	.L168:
 559:tmk_core/common/action.c ****                         }
 1754               		.loc 1 559 29 view .LVU470
 1755 03a0 0E94 0000 		call layer_on
 1756               	.LVL175:
 1757 03a4 00C0      		rjmp .L61
 1758               	.L116:
 508:tmk_core/common/action.c ****                     break;
 1759               		.loc 1 508 21 is_stmt 1 view .LVU471
 1760 03a6 8C2F      		mov r24,r28
 1761 03a8 8F71      		andi r24,lo8(31)
 508:tmk_core/common/action.c ****                     break;
 1762               		.loc 1 508 69 is_stmt 0 view .LVU472
 1763 03aa 1123      		tst r17
 1764 03ac 01F0      		breq .L168
 1765 03ae 00C0      		rjmp .L166
 1766               	.L121:
 511:tmk_core/common/action.c ****                     break;
 1767               		.loc 1 511 21 is_stmt 1 view .LVU473
 511:tmk_core/common/action.c ****                     break;
 1768               		.loc 1 511 70 is_stmt 0 view .LVU474
 1769 03b0 1123      		tst r17
 1770 03b2 01F0      		breq .L127
 511:tmk_core/common/action.c ****                     break;
 1771               		.loc 1 511 37 discriminator 1 view .LVU475
 1772 03b4 8C2F      		mov r24,r28
 1773 03b6 8F71      		andi r24,lo8(31)
 1774 03b8 0E94 0000 		call layer_move
 1775               	.LVL176:
 1776 03bc 00C0      		rjmp .L61
 1777               	.L127:
 511:tmk_core/common/action.c ****                     break;
 1778               		.loc 1 511 72 discriminator 2 view .LVU476
 1779 03be 0E94 0000 		call layer_clear
 1780               	.LVL177:
 1781 03c2 00C0      		rjmp .L61
 1782               	.L128:
 543:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1783               		.loc 1 543 25 is_stmt 1 view .LVU477
 1784 03c4 81E0      		ldi r24,lo8(1)
 1785 03c6 0E94 0000 		call clear_oneshot_layer_state
 1786               	.LVL178:
 544:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1787               		.loc 1 544 25 view .LVU478
 544:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1788               		.loc 1 544 28 is_stmt 0 view .LVU479
 1789 03ca 0230      		cpi r16,lo8(2)
 1790 03cc 00F4      		brsh .+2
 1791 03ce 00C0      		rjmp .L61
 545:tmk_core/common/action.c ****                         }
 1792               		.loc 1 545 29 is_stmt 1 view .LVU480
 1793 03d0 82E0      		ldi r24,lo8(2)
 1794 03d2 0E94 0000 		call clear_oneshot_layer_state
 1795               	.LVL179:
 1796 03d6 00C0      		rjmp .L61
 1797               	.L129:
 562:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1798               		.loc 1 562 25 view .LVU481
 562:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1799               		.loc 1 562 28 is_stmt 0 view .LVU482
 1800 03d8 0023      		tst r16
 1801 03da 01F0      		breq .L131
 563:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1802               		.loc 1 563 77 is_stmt 1 view .LVU483
 564:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1803               		.loc 1 564 29 view .LVU484
 564:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1804               		.loc 1 564 32 is_stmt 0 view .LVU485
 1805 03dc D933      		cpi r29,lo8(57)
 1806 03de 01F0      		breq .+2
 1807 03e0 00C0      		rjmp .L133
 565:tmk_core/common/action.c ****                             } else {
 1808               		.loc 1 565 33 is_stmt 1 view .LVU486
 1809               	.LVL180:
 1810               	.LBB57:
 1811               	.LBI52:
 166:e:\game\msys2\mingw64\avr\include\util\delay.h **** {
 1812               		.loc 2 166 1 view .LVU487
 1813               	.LBB54:
 168:e:\game\msys2\mingw64\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1814               		.loc 2 168 2 view .LVU488
 172:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1815               		.loc 2 172 2 view .LVU489
 173:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1816               		.loc 2 173 2 view .LVU490
 174:e:\game\msys2\mingw64\avr\include\util\delay.h **** 
 1817               		.loc 2 174 2 view .LVU491
 184:e:\game\msys2\mingw64\avr\include\util\delay.h **** 	#endif
 1818               		.loc 2 184 3 view .LVU492
 1819               		.loc 2 187 2 view .LVU493
 1820 03e2 8FEF      		ldi r24,lo8(255999)
 1821 03e4 97EE      		ldi r25,hi8(255999)
 1822 03e6 E3E0      		ldi r30,hlo8(255999)
 1823 03e8 8150      	1:	subi r24,1
 1824 03ea 9040      		sbci r25,0
 1825 03ec E040      		sbci r30,0
 1826 03ee 01F4      		brne 1b
 1827 03f0 00C0      		rjmp .L173
 1828               	.LVL181:
 1829               	.L131:
 1830               		.loc 2 187 2 is_stmt 0 view .LVU494
 1831               	.LBE54:
 1832               	.LBE57:
 571:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 1833               		.loc 1 571 79 is_stmt 1 view .LVU495
 572:tmk_core/common/action.c ****                         }
 1834               		.loc 1 572 29 view .LVU496
 1835 03f2 8C2F      		mov r24,r28
 1836 03f4 8F71      		andi r24,lo8(31)
 1837 03f6 00C0      		rjmp .L166
 1838               	.L64:
 583:tmk_core/common/action.c ****             break;
 1839               		.loc 1 583 13 view .LVU497
 583:tmk_core/common/action.c ****             break;
 1840               		.loc 1 583 83 is_stmt 0 view .LVU498
 1841 03f8 4C2F      		mov r20,r28
 1842 03fa 4F70      		andi r20,lo8(15)
 583:tmk_core/common/action.c ****             break;
 1843               		.loc 1 583 13 view .LVU499
 1844 03fc 6D2F      		mov r22,r29
 1845 03fe C601      		movw r24,r12
 1846 0400 0E94 0000 		call action_get_macro
 1847               	.LVL182:
 1848 0404 0E94 0000 		call action_macro_play
 1849               	.LVL183:
 584:tmk_core/common/action.c **** #endif
 1850               		.loc 1 584 13 is_stmt 1 view .LVU500
 1851 0408 00C0      		rjmp .L61
 1852               	.L62:
 661:tmk_core/common/action.c ****             break;
 1853               		.loc 1 661 13 view .LVU501
 661:tmk_core/common/action.c ****             break;
 1854               		.loc 1 661 64 is_stmt 0 view .LVU502
 1855 040a 4C2F      		mov r20,r28
 1856 040c 4F70      		andi r20,lo8(15)
 661:tmk_core/common/action.c ****             break;
 1857               		.loc 1 661 13 view .LVU503
 1858 040e 6D2F      		mov r22,r29
 1859 0410 C601      		movw r24,r12
 1860 0412 0E94 0000 		call action_function
 1861               	.LVL184:
 662:tmk_core/common/action.c **** #endif
 1862               		.loc 1 662 13 is_stmt 1 view .LVU504
 1863 0416 00C0      		rjmp .L61
 1864               	.LVL185:
 1865               	.L58:
 1866               	/* epilogue start */
 730:tmk_core/common/action.c **** 
 1867               		.loc 1 730 1 is_stmt 0 view .LVU505
 1868 0418 DF91      		pop r29
 1869               	.LVL186:
 730:tmk_core/common/action.c **** 
 1870               		.loc 1 730 1 view .LVU506
 1871 041a CF91      		pop r28
 730:tmk_core/common/action.c **** 
 1872               		.loc 1 730 1 view .LVU507
 1873 041c 1F91      		pop r17
 1874 041e 0F91      		pop r16
 1875 0420 FF90      		pop r15
 1876 0422 EF90      		pop r14
 1877               	.LVL187:
 730:tmk_core/common/action.c **** 
 1878               		.loc 1 730 1 view .LVU508
 1879 0424 DF90      		pop r13
 1880 0426 CF90      		pop r12
 1881               	.LVL188:
 730:tmk_core/common/action.c **** 
 1882               		.loc 1 730 1 view .LVU509
 1883 0428 BF90      		pop r11
 1884 042a 0895      		ret
 1885               		.cfi_endproc
 1886               	.LFE22:
 1888               		.section	.text.process_record_handler,"ax",@progbits
 1889               	.global	process_record_handler
 1891               	process_record_handler:
 1892               	.LVL189:
 1893               	.LFB21:
 208:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1894               		.loc 1 208 50 is_stmt 1 view -0
 1895               		.cfi_startproc
 208:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1896               		.loc 1 208 50 is_stmt 0 view .LVU511
 1897 0000 0F93      		push r16
 1898               	.LCFI22:
 1899               		.cfi_def_cfa_offset 3
 1900               		.cfi_offset 16, -2
 1901 0002 1F93      		push r17
 1902               	.LCFI23:
 1903               		.cfi_def_cfa_offset 4
 1904               		.cfi_offset 17, -3
 1905 0004 CF93      		push r28
 1906               	.LCFI24:
 1907               		.cfi_def_cfa_offset 5
 1908               		.cfi_offset 28, -4
 1909 0006 DF93      		push r29
 1910               	.LCFI25:
 1911               		.cfi_def_cfa_offset 6
 1912               		.cfi_offset 29, -5
 1913               	/* prologue: function */
 1914               	/* frame size = 0 */
 1915               	/* stack size = 4 */
 1916               	.L__stack_usage = 4
 1917 0008 EC01      		movw r28,r24
 209:tmk_core/common/action.c ****     dprint("ACTION: ");
 1918               		.loc 1 209 5 is_stmt 1 view .LVU512
 209:tmk_core/common/action.c ****     dprint("ACTION: ");
 1919               		.loc 1 209 23 is_stmt 0 view .LVU513
 1920 000a 6881      		ld r22,Y
 1921 000c 7981      		ldd r23,Y+1
 1922 000e 8A81      		ldd r24,Y+2
 1923               	.LVL190:
 209:tmk_core/common/action.c ****     dprint("ACTION: ");
 1924               		.loc 1 209 23 view .LVU514
 1925 0010 0E94 0000 		call store_or_get_action
 1926               	.LVL191:
 1927 0014 8C01      		movw r16,r24
 1928               	.LVL192:
 210:tmk_core/common/action.c ****     debug_action(action);
 1929               		.loc 1 210 23 is_stmt 1 view .LVU515
 211:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 1930               		.loc 1 211 5 view .LVU516
 213:tmk_core/common/action.c ****     layer_debug();
 1931               		.loc 1 213 29 view .LVU517
 214:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 1932               		.loc 1 214 5 view .LVU518
 1933 0016 0E94 0000 		call layer_debug
 1934               	.LVL193:
 215:tmk_core/common/action.c ****     default_layer_debug();
 1935               		.loc 1 215 37 view .LVU519
 216:tmk_core/common/action.c **** #endif
 1936               		.loc 1 216 5 view .LVU520
 1937 001a 0E94 0000 		call default_layer_debug
 1938               	.LVL194:
 218:tmk_core/common/action.c **** 
 1939               		.loc 1 218 15 view .LVU521
 220:tmk_core/common/action.c **** }
 1940               		.loc 1 220 5 view .LVU522
 220:tmk_core/common/action.c **** }
 1941               		.loc 1 220 5 is_stmt 0 view .LVU523
 1942 001e B801      		movw r22,r16
 1943 0020 CE01      		movw r24,r28
 1944               	/* epilogue start */
 221:tmk_core/common/action.c **** 
 1945               		.loc 1 221 1 view .LVU524
 1946 0022 DF91      		pop r29
 1947 0024 CF91      		pop r28
 1948               	.LVL195:
 221:tmk_core/common/action.c **** 
 1949               		.loc 1 221 1 view .LVU525
 1950 0026 1F91      		pop r17
 1951 0028 0F91      		pop r16
 1952               	.LVL196:
 220:tmk_core/common/action.c **** }
 1953               		.loc 1 220 5 view .LVU526
 1954 002a 0C94 0000 		jmp process_action
 1955               	.LVL197:
 220:tmk_core/common/action.c **** }
 1956               		.loc 1 220 5 view .LVU527
 1957               		.cfi_endproc
 1958               	.LFE21:
 1960               		.section	.text.process_record,"ax",@progbits
 1961               	.global	process_record
 1963               	process_record:
 1964               	.LVL198:
 1965               	.LFB20:
 190:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1966               		.loc 1 190 42 is_stmt 1 view -0
 1967               		.cfi_startproc
 190:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 1968               		.loc 1 190 42 is_stmt 0 view .LVU529
 1969 0000 CF93      		push r28
 1970               	.LCFI26:
 1971               		.cfi_def_cfa_offset 3
 1972               		.cfi_offset 28, -2
 1973 0002 DF93      		push r29
 1974               	.LCFI27:
 1975               		.cfi_def_cfa_offset 4
 1976               		.cfi_offset 29, -3
 1977               	/* prologue: function */
 1978               	/* frame size = 0 */
 1979               	/* stack size = 2 */
 1980               	.L__stack_usage = 2
 1981 0004 EC01      		movw r28,r24
 191:tmk_core/common/action.c ****         return;
 1982               		.loc 1 191 5 is_stmt 1 view .LVU530
 1983               	.LBB60:
 1984               	.LBI60:
 1985               		.file 4 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #pragma once
  19:tmk_core/common/keyboard.h **** 
  20:tmk_core/common/keyboard.h **** #include <stdbool.h>
  21:tmk_core/common/keyboard.h **** #include <stdint.h>
  22:tmk_core/common/keyboard.h **** 
  23:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  24:tmk_core/common/keyboard.h **** extern "C" {
  25:tmk_core/common/keyboard.h **** #endif
  26:tmk_core/common/keyboard.h **** 
  27:tmk_core/common/keyboard.h **** /* key matrix position */
  28:tmk_core/common/keyboard.h **** typedef struct {
  29:tmk_core/common/keyboard.h ****     uint8_t col;
  30:tmk_core/common/keyboard.h ****     uint8_t row;
  31:tmk_core/common/keyboard.h **** } keypos_t;
  32:tmk_core/common/keyboard.h **** 
  33:tmk_core/common/keyboard.h **** /* key event */
  34:tmk_core/common/keyboard.h **** typedef struct {
  35:tmk_core/common/keyboard.h ****     keypos_t key;
  36:tmk_core/common/keyboard.h ****     bool     pressed;
  37:tmk_core/common/keyboard.h ****     uint16_t time;
  38:tmk_core/common/keyboard.h **** } keyevent_t;
  39:tmk_core/common/keyboard.h **** 
  40:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  41:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  42:tmk_core/common/keyboard.h **** 
  43:tmk_core/common/keyboard.h **** /* Rules for No Event:
  44:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  45:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  46:tmk_core/common/keyboard.h ****  */
  47:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1986               		.loc 4 47 20 view .LVU531
 1987               	.LBB61:
 1988               		.loc 4 47 51 view .LVU532
 1989               		.loc 4 47 74 is_stmt 0 view .LVU533
 1990 0006 8B81      		ldd r24,Y+3
 1991 0008 9C81      		ldd r25,Y+4
 1992               	.LVL199:
 1993               		.loc 4 47 74 view .LVU534
 1994 000a 892B      		or r24,r25
 1995 000c 01F0      		breq .L175
 1996 000e 8881      		ld r24,Y
 1997 0010 9981      		ldd r25,Y+1
 1998 0012 8923      		and r24,r25
 1999 0014 8F3F      		cpi r24,lo8(-1)
 2000 0016 01F4      		brne .L191
 2001               	.L175:
 2002               	/* epilogue start */
 2003               	.LBE61:
 2004               	.LBE60:
 206:tmk_core/common/action.c **** 
 2005               		.loc 1 206 1 view .LVU535
 2006 0018 DF91      		pop r29
 2007 001a CF91      		pop r28
 2008               	.LVL200:
 206:tmk_core/common/action.c **** 
 2009               		.loc 1 206 1 view .LVU536
 2010 001c 0895      		ret
 2011               	.LVL201:
 2012               	.L180:
 204:tmk_core/common/action.c ****     post_process_record_quantum(record);
 2013               		.loc 1 204 5 is_stmt 1 view .LVU537
 2014 001e CE01      		movw r24,r28
 2015 0020 0E94 0000 		call process_record_handler
 2016               	.LVL202:
 205:tmk_core/common/action.c **** }
 2017               		.loc 1 205 5 view .LVU538
 2018 0024 CE01      		movw r24,r28
 2019               	/* epilogue start */
 206:tmk_core/common/action.c **** 
 2020               		.loc 1 206 1 is_stmt 0 view .LVU539
 2021 0026 DF91      		pop r29
 2022 0028 CF91      		pop r28
 2023               	.LVL203:
 205:tmk_core/common/action.c **** }
 2024               		.loc 1 205 5 view .LVU540
 2025 002a 0C94 0000 		jmp post_process_record_quantum
 2026               	.LVL204:
 2027               	.L191:
 195:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 2028               		.loc 1 195 5 is_stmt 1 view .LVU541
 195:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 2029               		.loc 1 195 10 is_stmt 0 view .LVU542
 2030 002e CE01      		movw r24,r28
 2031 0030 0E94 0000 		call process_record_quantum
 2032               	.LVL205:
 195:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 2033               		.loc 1 195 8 view .LVU543
 2034 0034 8111      		cpse r24,__zero_reg__
 2035 0036 00C0      		rjmp .L180
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2036               		.loc 1 197 9 is_stmt 1 view .LVU544
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2037               		.loc 1 197 13 is_stmt 0 view .LVU545
 2038 0038 0E94 0000 		call is_oneshot_layer_active
 2039               	.LVL206:
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2040               		.loc 1 197 12 view .LVU546
 2041 003c 8823      		tst r24
 2042 003e 01F0      		breq .L175
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2043               		.loc 1 197 39 discriminator 1 view .LVU547
 2044 0040 8A81      		ldd r24,Y+2
 2045 0042 8823      		tst r24
 2046 0044 01F0      		breq .L175
 198:tmk_core/common/action.c ****         }
 2047               		.loc 1 198 13 is_stmt 1 view .LVU548
 2048 0046 82E0      		ldi r24,lo8(2)
 2049               	/* epilogue start */
 206:tmk_core/common/action.c **** 
 2050               		.loc 1 206 1 is_stmt 0 view .LVU549
 2051 0048 DF91      		pop r29
 2052 004a CF91      		pop r28
 2053               	.LVL207:
 198:tmk_core/common/action.c ****         }
 2054               		.loc 1 198 13 view .LVU550
 2055 004c 0C94 0000 		jmp clear_oneshot_layer_state
 2056               	.LVL208:
 2057               		.cfi_endproc
 2058               	.LFE20:
 2060               		.section	.text.process_record_nocache,"ax",@progbits
 2061               	.global	process_record_nocache
 2063               	process_record_nocache:
 2064               	.LVL209:
 2065               	.LFB16:
 148:tmk_core/common/action.c ****     disable_action_cache = true;
 2066               		.loc 1 148 50 is_stmt 1 view -0
 2067               		.cfi_startproc
 2068               	/* prologue: function */
 2069               	/* frame size = 0 */
 2070               	/* stack size = 0 */
 2071               	.L__stack_usage = 0
 149:tmk_core/common/action.c ****     process_record(record);
 2072               		.loc 1 149 5 view .LVU552
 149:tmk_core/common/action.c ****     process_record(record);
 2073               		.loc 1 149 26 is_stmt 0 view .LVU553
 2074 0000 21E0      		ldi r18,lo8(1)
 2075 0002 2093 0000 		sts disable_action_cache,r18
 150:tmk_core/common/action.c ****     disable_action_cache = false;
 2076               		.loc 1 150 5 is_stmt 1 view .LVU554
 2077 0006 0E94 0000 		call process_record
 2078               	.LVL210:
 151:tmk_core/common/action.c **** }
 2079               		.loc 1 151 5 view .LVU555
 151:tmk_core/common/action.c **** }
 2080               		.loc 1 151 26 is_stmt 0 view .LVU556
 2081 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 2082               	/* epilogue start */
 152:tmk_core/common/action.c **** #else
 2083               		.loc 1 152 1 view .LVU557
 2084 000e 0895      		ret
 2085               		.cfi_endproc
 2086               	.LFE16:
 2088               		.section	.text.register_weak_mods,"ax",@progbits
 2089               	.global	register_weak_mods
 2091               	register_weak_mods:
 2092               	.LVL211:
 2093               	.LFB29:
 925:tmk_core/common/action.c **** 
 926:tmk_core/common/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 927:tmk_core/common/action.c ****  *
 928:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 929:tmk_core/common/action.c ****  */
 930:tmk_core/common/action.c **** void register_weak_mods(uint8_t mods) {
 2094               		.loc 1 930 39 is_stmt 1 view -0
 2095               		.cfi_startproc
 2096               	/* prologue: function */
 2097               	/* frame size = 0 */
 2098               	/* stack size = 0 */
 2099               	.L__stack_usage = 0
 931:tmk_core/common/action.c ****     if (mods) {
 2100               		.loc 1 931 5 view .LVU559
 2101               		.loc 1 931 8 is_stmt 0 view .LVU560
 2102 0000 8823      		tst r24
 2103 0002 01F0      		breq .L194
 932:tmk_core/common/action.c ****         add_weak_mods(mods);
 2104               		.loc 1 932 9 is_stmt 1 view .LVU561
 2105 0004 0E94 0000 		call add_weak_mods
 2106               	.LVL212:
 933:tmk_core/common/action.c ****         send_keyboard_report();
 2107               		.loc 1 933 9 view .LVU562
 2108 0008 0C94 0000 		jmp send_keyboard_report
 2109               	.LVL213:
 2110               	.L194:
 2111               	/* epilogue start */
 934:tmk_core/common/action.c ****     }
 935:tmk_core/common/action.c **** }
 2112               		.loc 1 935 1 is_stmt 0 view .LVU563
 2113 000c 0895      		ret
 2114               		.cfi_endproc
 2115               	.LFE29:
 2117               		.section	.text.unregister_weak_mods,"ax",@progbits
 2118               	.global	unregister_weak_mods
 2120               	unregister_weak_mods:
 2121               	.LVL214:
 2122               	.LFB30:
 936:tmk_core/common/action.c **** 
 937:tmk_core/common/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 938:tmk_core/common/action.c ****  *
 939:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 940:tmk_core/common/action.c ****  */
 941:tmk_core/common/action.c **** void unregister_weak_mods(uint8_t mods) {
 2123               		.loc 1 941 41 is_stmt 1 view -0
 2124               		.cfi_startproc
 2125               	/* prologue: function */
 2126               	/* frame size = 0 */
 2127               	/* stack size = 0 */
 2128               	.L__stack_usage = 0
 942:tmk_core/common/action.c ****     if (mods) {
 2129               		.loc 1 942 5 view .LVU565
 2130               		.loc 1 942 8 is_stmt 0 view .LVU566
 2131 0000 8823      		tst r24
 2132 0002 01F0      		breq .L196
 943:tmk_core/common/action.c ****         del_weak_mods(mods);
 2133               		.loc 1 943 9 is_stmt 1 view .LVU567
 2134 0004 0E94 0000 		call del_weak_mods
 2135               	.LVL215:
 944:tmk_core/common/action.c ****         send_keyboard_report();
 2136               		.loc 1 944 9 view .LVU568
 2137 0008 0C94 0000 		jmp send_keyboard_report
 2138               	.LVL216:
 2139               	.L196:
 2140               	/* epilogue start */
 945:tmk_core/common/action.c ****     }
 946:tmk_core/common/action.c **** }
 2141               		.loc 1 946 1 is_stmt 0 view .LVU569
 2142 000c 0895      		ret
 2143               		.cfi_endproc
 2144               	.LFE30:
 2146               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 2147               	.global	clear_keyboard_but_mods_and_keys
 2149               	clear_keyboard_but_mods_and_keys:
 2150               	.LFB33:
 947:tmk_core/common/action.c **** 
 948:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 949:tmk_core/common/action.c ****  *
 950:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 951:tmk_core/common/action.c ****  */
 952:tmk_core/common/action.c **** void clear_keyboard(void) {
 953:tmk_core/common/action.c ****     clear_mods();
 954:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 955:tmk_core/common/action.c **** }
 956:tmk_core/common/action.c **** 
 957:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 958:tmk_core/common/action.c ****  *
 959:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 960:tmk_core/common/action.c ****  */
 961:tmk_core/common/action.c **** void clear_keyboard_but_mods(void) {
 962:tmk_core/common/action.c ****     clear_keys();
 963:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 964:tmk_core/common/action.c **** }
 965:tmk_core/common/action.c **** 
 966:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 967:tmk_core/common/action.c ****  *
 968:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 969:tmk_core/common/action.c ****  */
 970:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys() {
 2151               		.loc 1 970 41 is_stmt 1 view -0
 2152               		.cfi_startproc
 2153               	/* prologue: function */
 2154               	/* frame size = 0 */
 2155               	/* stack size = 0 */
 2156               	.L__stack_usage = 0
 971:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 972:tmk_core/common/action.c ****     host_system_send(0);
 2157               		.loc 1 972 5 view .LVU571
 2158 0000 90E0      		ldi r25,0
 2159 0002 80E0      		ldi r24,0
 2160 0004 0E94 0000 		call host_system_send
 2161               	.LVL217:
 973:tmk_core/common/action.c ****     host_consumer_send(0);
 2162               		.loc 1 973 5 view .LVU572
 2163 0008 90E0      		ldi r25,0
 2164 000a 80E0      		ldi r24,0
 2165 000c 0E94 0000 		call host_consumer_send
 2166               	.LVL218:
 974:tmk_core/common/action.c **** #endif
 975:tmk_core/common/action.c ****     clear_weak_mods();
 2167               		.loc 1 975 5 view .LVU573
 2168 0010 0E94 0000 		call clear_weak_mods
 2169               	.LVL219:
 976:tmk_core/common/action.c ****     clear_macro_mods();
 2170               		.loc 1 976 5 view .LVU574
 2171 0014 0E94 0000 		call clear_macro_mods
 2172               	.LVL220:
 977:tmk_core/common/action.c ****     send_keyboard_report();
 2173               		.loc 1 977 5 view .LVU575
 2174 0018 0E94 0000 		call send_keyboard_report
 2175               	.LVL221:
 978:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 979:tmk_core/common/action.c ****     mousekey_clear();
 2176               		.loc 1 979 5 view .LVU576
 2177 001c 0E94 0000 		call mousekey_clear
 2178               	.LVL222:
 980:tmk_core/common/action.c ****     mousekey_send();
 2179               		.loc 1 980 5 view .LVU577
 2180 0020 0C94 0000 		jmp mousekey_send
 2181               	.LVL223:
 2182               		.cfi_endproc
 2183               	.LFE33:
 2185               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 2186               	.global	clear_keyboard_but_mods
 2188               	clear_keyboard_but_mods:
 2189               	.LFB32:
 961:tmk_core/common/action.c ****     clear_keys();
 2190               		.loc 1 961 36 view -0
 2191               		.cfi_startproc
 2192               	/* prologue: function */
 2193               	/* frame size = 0 */
 2194               	/* stack size = 0 */
 2195               	.L__stack_usage = 0
 962:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 2196               		.loc 1 962 5 view .LVU579
 2197 0000 0E94 0000 		call clear_keys
 2198               	.LVL224:
 963:tmk_core/common/action.c **** }
 2199               		.loc 1 963 5 view .LVU580
 2200 0004 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 2201               	.LVL225:
 2202               		.cfi_endproc
 2203               	.LFE32:
 2205               		.section	.text.clear_keyboard,"ax",@progbits
 2206               	.global	clear_keyboard
 2208               	clear_keyboard:
 2209               	.LFB31:
 952:tmk_core/common/action.c ****     clear_mods();
 2210               		.loc 1 952 27 view -0
 2211               		.cfi_startproc
 2212               	/* prologue: function */
 2213               	/* frame size = 0 */
 2214               	/* stack size = 0 */
 2215               	.L__stack_usage = 0
 953:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 2216               		.loc 1 953 5 view .LVU582
 2217 0000 0E94 0000 		call clear_mods
 2218               	.LVL226:
 954:tmk_core/common/action.c **** }
 2219               		.loc 1 954 5 view .LVU583
 2220 0004 0C94 0000 		jmp clear_keyboard_but_mods
 2221               	.LVL227:
 2222               		.cfi_endproc
 2223               	.LFE31:
 2225               		.section	.text.is_tap_action,"ax",@progbits
 2226               	.global	is_tap_action
 2228               	is_tap_action:
 2229               	.LVL228:
 2230               	.LFB35:
 981:tmk_core/common/action.c **** #endif
 982:tmk_core/common/action.c **** }
 983:tmk_core/common/action.c **** 
 984:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 985:tmk_core/common/action.c ****  *
 986:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 987:tmk_core/common/action.c ****  */
 988:tmk_core/common/action.c **** bool is_tap_key(keypos_t key) {
 989:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 990:tmk_core/common/action.c ****     return is_tap_action(action);
 991:tmk_core/common/action.c **** }
 992:tmk_core/common/action.c **** 
 993:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 994:tmk_core/common/action.c ****  *
 995:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 996:tmk_core/common/action.c ****  */
 997:tmk_core/common/action.c **** bool is_tap_action(action_t action) {
 2231               		.loc 1 997 37 view -0
 2232               		.cfi_startproc
 2233               	/* prologue: function */
 2234               	/* frame size = 0 */
 2235               	/* stack size = 0 */
 2236               	.L__stack_usage = 0
 998:tmk_core/common/action.c ****     switch (action.kind.id) {
 2237               		.loc 1 998 5 view .LVU585
 2238               		.loc 1 998 24 is_stmt 0 view .LVU586
 2239 0000 E92F      		mov r30,r25
 2240 0002 E295      		swap r30
 2241 0004 EF70      		andi r30,lo8(15)
 2242               		.loc 1 998 5 view .LVU587
 2243 0006 E250      		subi r30,lo8(-(-2))
 2244 0008 EE30      		cpi r30,lo8(14)
 2245 000a 00F4      		brsh .L210
 2246 000c F0E0      		ldi r31,0
 2247 000e E050      		subi r30,lo8(-(gs(.L204)))
 2248 0010 F040      		sbci r31,hi8(-(gs(.L204)))
 2249 0012 0C94 0000 		jmp __tablejump2__
 2250               		.section	.jumptables.gcc.is_tap_action,"a",@progbits
 2251               		.p2align	1
 2252               	.L204:
 2253 0000 0000      		.word gs(.L205)
 2254 0002 0000      		.word gs(.L205)
 2255 0004 0000      		.word gs(.L210)
 2256 0006 0000      		.word gs(.L210)
 2257 0008 0000      		.word gs(.L206)
 2258 000a 0000      		.word gs(.L210)
 2259 000c 0000      		.word gs(.L210)
 2260 000e 0000      		.word gs(.L210)
 2261 0010 0000      		.word gs(.L205)
 2262 0012 0000      		.word gs(.L205)
 2263 0014 0000      		.word gs(.L203)
 2264 0016 0000      		.word gs(.L210)
 2265 0018 0000      		.word gs(.L210)
 2266 001a 0000      		.word gs(.L203)
 2267               		.section	.text.is_tap_action
 2268               	.L205:
 999:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1000:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1001:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1002:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1003:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 2269               		.loc 1 1003 13 is_stmt 1 view .LVU588
 2270 0016 803F      		cpi r24,lo8(-16)
 2271 0018 01F0      		breq .L213
 2272 001a 00F4      		brsh .L207
 2273 001c 883E      		cpi r24,lo8(-24)
 2274 001e 00F4      		brsh .L210
 2275               	.L213:
1004:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
1005:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
1006:tmk_core/common/action.c ****                 case OP_ONESHOT:
1007:tmk_core/common/action.c ****                     return true;
 2276               		.loc 1 1007 28 is_stmt 0 view .LVU589
 2277 0020 81E0      		ldi r24,lo8(1)
 2278               	.LVL229:
 2279               	/* epilogue start */
1008:tmk_core/common/action.c ****             }
1009:tmk_core/common/action.c ****             return false;
1010:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1011:tmk_core/common/action.c ****             switch (action.swap.code) {
1012:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
1013:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
1014:tmk_core/common/action.c ****                     return true;
1015:tmk_core/common/action.c ****             }
1016:tmk_core/common/action.c ****             return false;
1017:tmk_core/common/action.c ****         case ACT_MACRO:
1018:tmk_core/common/action.c ****         case ACT_FUNCTION:
1019:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) {
1020:tmk_core/common/action.c ****                 return true;
1021:tmk_core/common/action.c ****             }
1022:tmk_core/common/action.c ****             return false;
1023:tmk_core/common/action.c ****     }
1024:tmk_core/common/action.c ****     return false;
1025:tmk_core/common/action.c **** }
 2280               		.loc 1 1025 1 view .LVU590
 2281 0022 0895      		ret
 2282               	.LVL230:
 2283               	.L207:
 2284               		.loc 1 1025 1 view .LVU591
 2285 0024 843F      		cpi r24,lo8(-12)
 2286 0026 01F0      		breq .L213
 2287               	.L210:
1009:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2288               		.loc 1 1009 20 view .LVU592
 2289 0028 80E0      		ldi r24,0
 2290               	.LVL231:
1009:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2291               		.loc 1 1009 20 view .LVU593
 2292 002a 0895      		ret
 2293               	.LVL232:
 2294               	.L206:
1011:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 2295               		.loc 1 1011 13 is_stmt 1 view .LVU594
 2296 002c 883E      		cpi r24,lo8(-24)
 2297 002e 00F0      		brlo .L213
 2298 0030 813F      		cpi r24,lo8(-15)
 2299 0032 01F4      		brne .L210
 2300 0034 00C0      		rjmp .L213
 2301               	.L203:
1019:tmk_core/common/action.c ****                 return true;
 2302               		.loc 1 1019 13 view .LVU595
1019:tmk_core/common/action.c ****                 return true;
 2303               		.loc 1 1019 16 is_stmt 0 view .LVU596
 2304 0036 93FB      		bst r25,3
 2305 0038 8827      		clr r24
 2306 003a 80F9      		bld r24,0
 2307               	.LVL233:
1019:tmk_core/common/action.c ****                 return true;
 2308               		.loc 1 1019 16 view .LVU597
 2309 003c 0895      		ret
 2310               		.cfi_endproc
 2311               	.LFE35:
 2313               		.section	.text.is_tap_key,"ax",@progbits
 2314               	.global	is_tap_key
 2316               	is_tap_key:
 2317               	.LVL234:
 2318               	.LFB34:
 988:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 2319               		.loc 1 988 31 is_stmt 1 view -0
 2320               		.cfi_startproc
 2321               	/* prologue: function */
 2322               	/* frame size = 0 */
 2323               	/* stack size = 0 */
 2324               	.L__stack_usage = 0
 989:tmk_core/common/action.c ****     return is_tap_action(action);
 2325               		.loc 1 989 5 view .LVU599
 989:tmk_core/common/action.c ****     return is_tap_action(action);
 2326               		.loc 1 989 23 is_stmt 0 view .LVU600
 2327 0000 0E94 0000 		call layer_switch_get_action
 2328               	.LVL235:
 990:tmk_core/common/action.c **** }
 2329               		.loc 1 990 5 is_stmt 1 view .LVU601
 990:tmk_core/common/action.c **** }
 2330               		.loc 1 990 12 is_stmt 0 view .LVU602
 2331 0004 0C94 0000 		jmp is_tap_action
 2332               	.LVL236:
 2333               		.cfi_endproc
 2334               	.LFE34:
 2336               		.section	.text.debug_event,"ax",@progbits
 2337               	.global	debug_event
 2339               	debug_event:
 2340               	.LFB36:
1026:tmk_core/common/action.c **** 
1027:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1028:tmk_core/common/action.c ****  *
1029:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1030:tmk_core/common/action.c ****  */
1031:tmk_core/common/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 2341               		.loc 1 1031 36 is_stmt 1 view -0
 2342               		.cfi_startproc
 2343 0000 CF93      		push r28
 2344               	.LCFI28:
 2345               		.cfi_def_cfa_offset 3
 2346               		.cfi_offset 28, -2
 2347 0002 DF93      		push r29
 2348               	.LCFI29:
 2349               		.cfi_def_cfa_offset 4
 2350               		.cfi_offset 29, -3
 2351 0004 00D0      		rcall .
 2352 0006 00D0      		rcall .
 2353 0008 0F92      		push __tmp_reg__
 2354               	.LCFI30:
 2355               		.cfi_def_cfa_offset 9
 2356 000a CDB7      		in r28,__SP_L__
 2357 000c DEB7      		in r29,__SP_H__
 2358               	.LCFI31:
 2359               		.cfi_def_cfa_register 28
 2360               	/* prologue: function */
 2361               	/* frame size = 5 */
 2362               	/* stack size = 7 */
 2363               	.L__stack_usage = 7
 2364               		.loc 1 1031 138 view .LVU604
 2365               	/* epilogue start */
 2366               		.loc 1 1031 1 is_stmt 0 view .LVU605
 2367 000e 0F90      		pop __tmp_reg__
 2368 0010 0F90      		pop __tmp_reg__
 2369 0012 0F90      		pop __tmp_reg__
 2370 0014 0F90      		pop __tmp_reg__
 2371 0016 0F90      		pop __tmp_reg__
 2372 0018 DF91      		pop r29
 2373 001a CF91      		pop r28
 2374 001c 0895      		ret
 2375               		.cfi_endproc
 2376               	.LFE36:
 2378               		.section	.text.debug_record,"ax",@progbits
 2379               	.global	debug_record
 2381               	debug_record:
 2382               	.LFB37:
1032:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1033:tmk_core/common/action.c ****  *
1034:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1035:tmk_core/common/action.c ****  */
1036:tmk_core/common/action.c **** void debug_record(keyrecord_t record) {
 2383               		.loc 1 1036 39 is_stmt 1 view -0
 2384               		.cfi_startproc
 2385 0000 CF93      		push r28
 2386               	.LCFI32:
 2387               		.cfi_def_cfa_offset 3
 2388               		.cfi_offset 28, -2
 2389 0002 DF93      		push r29
 2390               	.LCFI33:
 2391               		.cfi_def_cfa_offset 4
 2392               		.cfi_offset 29, -3
 2393 0004 00D0      		rcall .
 2394 0006 00D0      		rcall .
 2395 0008 00D0      		rcall .
 2396               	.LCFI34:
 2397               		.cfi_def_cfa_offset 10
 2398 000a CDB7      		in r28,__SP_L__
 2399 000c DEB7      		in r29,__SP_H__
 2400               	.LCFI35:
 2401               		.cfi_def_cfa_register 28
 2402               	/* prologue: function */
 2403               	/* frame size = 6 */
 2404               	/* stack size = 8 */
 2405               	.L__stack_usage = 8
1037:tmk_core/common/action.c ****     debug_event(record.event);
 2406               		.loc 1 1037 5 view .LVU607
1038:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
1039:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 2407               		.loc 1 1039 77 view .LVU608
 2408               	/* epilogue start */
1040:tmk_core/common/action.c **** #endif
1041:tmk_core/common/action.c **** }
 2409               		.loc 1 1041 1 is_stmt 0 view .LVU609
 2410 000e 2696      		adiw r28,6
 2411 0010 0FB6      		in __tmp_reg__,__SREG__
 2412 0012 F894      		cli
 2413 0014 DEBF      		out __SP_H__,r29
 2414 0016 0FBE      		out __SREG__,__tmp_reg__
 2415 0018 CDBF      		out __SP_L__,r28
 2416 001a DF91      		pop r29
 2417 001c CF91      		pop r28
 2418 001e 0895      		ret
 2419               		.cfi_endproc
 2420               	.LFE37:
 2422               		.section	.text.debug_action,"ax",@progbits
 2423               	.global	debug_action
 2425               	debug_action:
 2426               	.LVL237:
 2427               	.LFB38:
1042:tmk_core/common/action.c **** 
1043:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1044:tmk_core/common/action.c ****  *
1045:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1046:tmk_core/common/action.c ****  */
1047:tmk_core/common/action.c **** void debug_action(action_t action) {
 2428               		.loc 1 1047 36 is_stmt 1 view -0
 2429               		.cfi_startproc
 2430               	/* prologue: function */
 2431               	/* frame size = 0 */
 2432               	/* stack size = 0 */
 2433               	.L__stack_usage = 0
1048:tmk_core/common/action.c ****     switch (action.kind.id) {
 2434               		.loc 1 1048 5 view .LVU611
1049:tmk_core/common/action.c ****         case ACT_LMODS:
1050:tmk_core/common/action.c ****             dprint("ACT_LMODS");
1051:tmk_core/common/action.c ****             break;
1052:tmk_core/common/action.c ****         case ACT_RMODS:
1053:tmk_core/common/action.c ****             dprint("ACT_RMODS");
1054:tmk_core/common/action.c ****             break;
1055:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1056:tmk_core/common/action.c ****             dprint("ACT_LMODS_TAP");
1057:tmk_core/common/action.c ****             break;
1058:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1059:tmk_core/common/action.c ****             dprint("ACT_RMODS_TAP");
1060:tmk_core/common/action.c ****             break;
1061:tmk_core/common/action.c ****         case ACT_USAGE:
1062:tmk_core/common/action.c ****             dprint("ACT_USAGE");
1063:tmk_core/common/action.c ****             break;
1064:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
1065:tmk_core/common/action.c ****             dprint("ACT_MOUSEKEY");
1066:tmk_core/common/action.c ****             break;
1067:tmk_core/common/action.c ****         case ACT_LAYER:
1068:tmk_core/common/action.c ****             dprint("ACT_LAYER");
1069:tmk_core/common/action.c ****             break;
1070:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
1071:tmk_core/common/action.c ****             dprint("ACT_LAYER_MODS");
1072:tmk_core/common/action.c ****             break;
1073:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1074:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP");
1075:tmk_core/common/action.c ****             break;
1076:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1077:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1078:tmk_core/common/action.c ****             break;
1079:tmk_core/common/action.c ****         case ACT_MACRO:
1080:tmk_core/common/action.c ****             dprint("ACT_MACRO");
1081:tmk_core/common/action.c ****             break;
1082:tmk_core/common/action.c ****         case ACT_FUNCTION:
1083:tmk_core/common/action.c ****             dprint("ACT_FUNCTION");
1084:tmk_core/common/action.c ****             break;
1085:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1086:tmk_core/common/action.c ****             dprint("ACT_SWAP_HANDS");
1087:tmk_core/common/action.c ****             break;
1088:tmk_core/common/action.c ****         default:
1089:tmk_core/common/action.c ****             dprint("UNKNOWN");
1090:tmk_core/common/action.c ****             break;
1091:tmk_core/common/action.c ****     }
1092:tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
 2435               		.loc 1 1092 75 view .LVU612
 2436               	/* epilogue start */
1093:tmk_core/common/action.c **** }
 2437               		.loc 1 1093 1 is_stmt 0 view .LVU613
 2438 0000 0895      		ret
 2439               		.cfi_endproc
 2440               	.LFE38:
 2442               		.section	.rodata.CSWTCH.12,"a"
 2445               	CSWTCH.12:
 2446 0000 E200      		.word	226
 2447 0002 E900      		.word	233
 2448 0004 EA00      		.word	234
 2449 0006 B500      		.word	181
 2450 0008 B600      		.word	182
 2451 000a B700      		.word	183
 2452 000c CD00      		.word	205
 2453 000e 8301      		.word	387
 2454 0010 CC00      		.word	204
 2455 0012 8A01      		.word	394
 2456 0014 9201      		.word	402
 2457 0016 9401      		.word	404
 2458 0018 2102      		.word	545
 2459 001a 2302      		.word	547
 2460 001c 2402      		.word	548
 2461 001e 2502      		.word	549
 2462 0020 2602      		.word	550
 2463 0022 2702      		.word	551
 2464 0024 2A02      		.word	554
 2465 0026 B300      		.word	179
 2466 0028 B400      		.word	180
 2467 002a 6F00      		.word	111
 2468 002c 7000      		.word	112
 2469               		.section	.rodata.CSWTCH.11,"a"
 2472               	CSWTCH.11:
 2473 0000 81        		.byte	-127
 2474 0001 82        		.byte	-126
 2475 0002 83        		.byte	-125
 2476               	.global	disable_action_cache
 2477               		.section	.bss.disable_action_cache,"aw",@nobits
 2480               	disable_action_cache:
 2481 0000 00        		.zero	1
 2482               		.comm	tp_buttons,2,1
 2483               		.text
 2484               	.Letext0:
 2485               		.file 5 "e:\\game\\msys2\\mingw64\\avr\\include\\stdint.h"
 2486               		.file 6 "tmk_core/common/keycode.h"
 2487               		.file 7 "tmk_core/common/host.h"
 2488               		.file 8 "quantum/mousekey.h"
 2489               		.file 9 "quantum/command.h"
 2490               		.file 10 "tmk_core/common/action_code.h"
 2491               		.file 11 "tmk_core/common/action.h"
 2492               		.file 12 "tmk_core/common/action_layer.h"
 2493               		.file 13 "tmk_core/common/action_util.h"
 2494               		.file 14 "tmk_core/common/avr/xprintf.h"
 2495               		.file 15 "tmk_core/common/debug.h"
 2496               		.file 16 "quantum/led.h"
 2497               		.file 17 "tmk_core/common/action_macro.h"
 2498               		.file 18 "tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:2      *ABS*:000000000000003e __SP_H__
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:3      *ABS*:000000000000003d __SP_L__
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:4      *ABS*:000000000000003f __SREG__
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:5      *ABS*:0000000000000000 __tmp_reg__
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:6      *ABS*:0000000000000001 __zero_reg__
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:13     .text.action_exec:0000000000000000 action_exec
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:132    .text.process_record_quantum:0000000000000000 process_record_quantum
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:154    .text.post_process_record_quantum:0000000000000000 post_process_record_quantum
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:173    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:198    .text.register_code:0000000000000000 register_code
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:2472   .rodata.CSWTCH.11:0000000000000000 CSWTCH.11
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:2445   .rodata.CSWTCH.12:0000000000000000 CSWTCH.12
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:521    .text.unregister_code:0000000000000000 unregister_code
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:689    .text.tap_code_delay:0000000000000000 tap_code_delay
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:775    .text.tap_code:0000000000000000 tap_code
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:802    .text.register_mods:0000000000000000 register_mods
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:831    .text.unregister_mods:0000000000000000 unregister_mods
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:860    .text.process_action:0000000000000000 process_action
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:1963   .text.process_record:0000000000000000 process_record
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:1891   .text.process_record_handler:0000000000000000 process_record_handler
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:2063   .text.process_record_nocache:0000000000000000 process_record_nocache
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:2480   .bss.disable_action_cache:0000000000000000 disable_action_cache
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:2091   .text.register_weak_mods:0000000000000000 register_weak_mods
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:2120   .text.unregister_weak_mods:0000000000000000 unregister_weak_mods
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:2149   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:2188   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:2208   .text.clear_keyboard:0000000000000000 clear_keyboard
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:2228   .text.is_tap_action:0000000000000000 is_tap_action
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:2316   .text.is_tap_key:0000000000000000 is_tap_key
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:2339   .text.debug_event:0000000000000000 debug_event
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:2381   .text.debug_record:0000000000000000 debug_record
C:\Users\Roningo\AppData\Local\Temp\ccOrLZUU.s:2425   .text.debug_action:0000000000000000 debug_action
                            *COM*:0000000000000002 tp_buttons

UNDEFINED SYMBOLS
clear_weak_mods
action_tapping_process
layer_switch_get_action
host_keyboard_leds
add_key
send_keyboard_report
del_key
command_proc
keyboard_report
is_key_pressed
add_mods
host_system_send
host_consumer_send
mousekey_on
mousekey_send
del_mods
mousekey_off
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
led_set
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
set_oneshot_layer
layer_invert
layer_move
layer_clear
action_get_macro
action_macro_play
action_function
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
mousekey_clear
clear_keys
clear_mods
__do_copy_data
__do_clear_bss
